/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "ExpandedDataStruct_Test.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept

/**This data structure contains the {@link SimpleDataStruct} as super class.
In C the <code>struct</code> is defined as:
<pre class="CCode">
typedef struct ExpandedDataStruct_Test_t
{
union { ExpandableDataStruct_Test_s super;} base;
double e;
double f;
} ExpandedDataStruct_Test_s;
</pre>
The superclass is wrapped with an union, because the access is written anytime <code>ref.base.super</code>,
but the <code>union</code> doesn't contain an element <code>ObjectJc object</code> here. That is
because the base class in not based on ObjectJc.
*/


const char sign_Mtbl_ExpandedDataStruct_Test[] = "ExpandedDataStruct_Test"; //to mark method tables of all implementations


/*Constructor *//**J2C: autogenerated as default constructor. */
struct ExpandedDataStruct_Test_t* ctorM_ExpandedDataStruct_Test(MemC mthis, ThCxt* _thCxt)
{ ExpandedDataStruct_Test_s* ythis = PTR_MemC(mthis, ExpandedDataStruct_Test_s);  //reference casting to the real class.
  int sizeObj = size_MemC(mthis);
  STACKTRC_TENTRY("ctor_ExpandedDataStruct_Test");
  if(sizeof(ExpandedDataStruct_Test_s) > sizeObj) THROW_s0(IllegalArgumentException, "faut size", sizeObj);
  //J2C:super Constructor
  ctorM_SimpleDataStruct_Test(/*static*/mthis, _thCxt);
  //j2c: Initialize all class variables:
  {
  }/*J2C:No body for constructor*/

  STACKTRC_LEAVE;
  return ythis;
}


 extern struct ClassJc_t const reflection_SimpleDataStruct_Test_s;
 static struct superClasses_ExpandedDataStruct_Test_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_ExpandedDataStruct_Test_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_SimpleDataStruct_Test_s, 0 /*J2C: no Mtbl*/ }
   }
 };

extern struct ClassJc_t const reflection_ExpandedDataStruct_Test_s;
const struct Reflection_Fields_ExpandedDataStruct_Test_s_t
{ ObjectArrayJc head; FieldJc data[2];
} reflection_Fields_ExpandedDataStruct_Test_s =
{ CONST_ObjectArrayJc(FieldJc, 2, OBJTYPE_FieldJc, null, &reflection_Fields_ExpandedDataStruct_Test_s)
, {
     { "e"
    , 0 //nrofArrayElements
    , REFLECTION_double
    , 8 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ExpandedDataStruct_Test_s*)(0x1000))->e) - (int32)(ExpandedDataStruct_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ExpandedDataStruct_Test_s
    }
   , { "f"
    , 0 //nrofArrayElements
    , REFLECTION_double
    , 8 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ExpandedDataStruct_Test_s*)(0x1000))->f) - (int32)(ExpandedDataStruct_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ExpandedDataStruct_Test_s
    }
} };
const ClassJc reflection_ExpandedDataStruct_Test_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "ExpandedDataStruct_Test_s"
,  0 //position of ObjectJc
, sizeof(ExpandedDataStruct_Test_s)
, (FieldJcArray const*)&reflection_Fields_ExpandedDataStruct_Test_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_ExpandedDataStruct_Test_s //superclass
, null //interfaces
, 0    //modifiers
};
