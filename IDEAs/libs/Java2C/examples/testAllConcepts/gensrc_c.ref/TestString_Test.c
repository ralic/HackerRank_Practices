/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "TestString_Test.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "Jc/DateJc.h"  //embedded type in block
#include "Jc/SystemJc.h"  //reference-association: SystemJc
#include "Jc/ThreadJc.h"  //reference-association: ThreadJc_s
#include "TestString_classic_Test.h"  //reference-association: TestString_classic_Test_s

/**This class contains some examples to test String functionality.
<br><br>
<b>Situation for String preparation in C:</b>
A String preparation in C in embedded applications is often necessary in situations of error reporting
or output of states. The typically choice is usage of <code>sprintf(buffer, "text-format", arguments, ...)</code>.
This approach have some risks which may produce errors in runtime:
<ul>
<li>The type of arguments should be matched to the designation of parts in text-format.
An error of detail is possible, the user should programmed carefully. The compiler doesn't detect errors.
<li>If the size of <code>buffer</code> is less, an overflow isn't detect. An overflow may occur, if a value is unexpected,
and the numbering formating produce a less longer output. <code>char*</code>-Arguments are critically too,
because there length may be rate faulty because that is depending of outer code.
<li>If a <code>char*</code> is used as argument, and the pointer is faulty, an unexpected buffer overflow
may be produced in the <code>sprintf</code>.
<li>The buffer should be provided by the users environment. If the buffer is defined in Stack,
and the String is produced and used temporary, it's okay. But a software correction in calling routines,
which doesn't uses to pointer to the buffer for copy, instead save the pointer, are not detected at compile time.
</ul>
The usage of <code>sprintf(...)</code> in C should implement carefully, it is sensitive.
<br><br>
The usage of Strings in Java is some more unsensitive and simple. But the standard-Java uses the system of garbage collection
to accomplish this requirements. This may not able to use in all situations of embedded control-software.
The preparation of Strings may realized in Java in three ways:
<ul>
<li>Simple concatenations of Strings just like <code>String result = "value=" + value</code>. This variant needs a buffer,
which is allocated in the heap and managed by garbage collection.
<li>Usage of a StringBuffer or StringBuilder.
The adequate code is <code>result.setLength(0); result.append("value=").append(value);</code>
The StringBuffer-Object can be allocated as an element of any class, the memory space is allocated
in the instance including the buffer itself, hence no dynamic memory allocation is necessary.
<li>Java knows a adequate to <code>sprintf</code> approach using <code>String.format(formatString, arguments ...)</code>.
This method is some more safety as the C-<code>sprintf</code>, because a buffer overflow is detected and the types
of arguments are well known. But the method works with dynamic memory only.
</ul>
If embedded software written in Java and translated to C shouldn't used dynamic memory and garbage collection,
the second approach using <code>StringBuffer</code> is proper. The <code>StringBuffer</code> can be defined
as embedded Buffer with a fix length inside a class type. Examples using such a fix <code>StringBuffer</code>
allocated in the Stack too are test and shown in the method {@link #testStringBuffer()}.
<br><br>
If the garbage collector is able to use, a String concatenation is able to use. The user doesn't need to
provide any buffers.

*/


const char sign_Mtbl_TestString_Test[] = "TestString_Test"; //to mark method tables of all implementations

typedef struct MtblDef_TestString_Test_t { Mtbl_TestString_Test mtbl; MtblHeadJc end; } MtblDef_TestString_Test;
 extern MtblDef_TestString_Test const mtblTestString_Test;
StringJc empty_TestString_Test = CONST_z_StringJc("                                     ");

/*Constructor */
struct TestString_Test_t* ctorO_TestString_Test(ObjectJc* othis, struct StringBuilderJc_t* bufferInit, ThCxt* _thCxt)
{ TestString_Test_s* ythis = (TestString_Test_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_TestString_Test");
  checkConsistence_ObjectJc(othis, sizeof(TestString_Test_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_TestString_Test_s, sizeof(TestString_Test_s));  
  //j2c: Initialize all class variables:
  {ObjectJc *newObj0_1=null; //J2C: temporary Objects for new operations
      
    //J2C: constructor for embedded fix-size-StringBuffer
      init_ObjectJc(&ythis->bufferEmbedded.sb.base.object, sizeof(StringBuilderJc) + 1000 - 4, 0);
      ctorO_I_StringBuilderJc(&ythis->bufferEmbedded.sb.base.object, 1000, _thCxt);
    //J2C: constructor for embedded fix-size-StringBuffer
      init_ObjectJc(&ythis->sbufferFix.sb.base.object, sizeof(StringBuilderJc) + 250 - 4, 0);
      ctorO_I_StringBuilderJc(&ythis->sbufferFix.sb.base.object, 250, _thCxt);
    /*J2C: newArray*/
      init_ObjectJc(&ythis->strArray.head.object, sizeof_ARRAYJc(StringJc, 10), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&ythis->strArray.head.object, 10, sizeof(StringJc), null, 0);//J2C: constructor for embedded array;
    ythis->charArray = (char_Y*)ctorO_ObjectArrayJc((newObj0_1 = alloc_ObjectJc( sizeof(ObjectArrayJc) + (10) * sizeof(char), mIsLargeSize_objectIdentSize_ObjectJc, _thCxt)), 10, sizeof(char),REFLECTION_char, 0);  //J2C: assign a new ObjectArrayJc. ;
    activateGarbageCollectorAccess_BlockHeapJc(newObj0_1, null);
  }
  { 
    ObjectJc *newObj1_1=null; //J2C: temporary Objects for new operations
    
    SETREFJc(ythis->buffer1, ctorO_I_StringBuilderJc(/*static*/(newObj1_1 = alloc_ObjectJc(sizeof_StringBuilderJc, 0, _thCxt)), 122, _thCxt), StringBuilderJc);
    ythis->bufferInit = bufferInit;
    activateGarbageCollectorAccess_BlockHeapJc(newObj1_1, null);
  }
  STACKTRC_LEAVE;
  return ythis;
}



/**Help method which processes a String. */
int32 processString_TestString_Test(/*static*/ StringJc str, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("processString_TestString_Test");
  
  { 
    
    { STACKTRC_LEAVE;
      return length_StringJc(str);
    }
  }
  STACKTRC_LEAVE;
}


/**Examples for String concatenations.*/
void testStringConcatenationInStack_TestString_Test_F(TestString_Test_s* ythis, int32 value, float fValue, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("testStringConcatenationInStack_TestString_Test_F");
  
  { 
    StringJc ssn = CONST_z_StringJc("test-Concatenation ");   /*Because it is set 'java2c=StringBuilderInStack=100'*/
    int32 pos; 
    
    struct _stringBuilder_t{ StringBuilderJc u; char _b[100-4]; }_stringBuilder = { CONST_addSizeStack_StringBuilderJc(&_stringBuilder.u, 100-4), {0}};
    
    ssn = 
      ( setLength_StringBuilderJc(&_stringBuilder.u, 0, _thCxt)
      , append_z_StringBuilderJc(&_stringBuilder.u, "test-Concatenation ", _thCxt)
      , append_I_StringBuilderJc(&_stringBuilder.u, value, _thCxt)
      , append_z_StringBuilderJc(&_stringBuilder.u, ", float ", _thCxt)
      , append_F_StringBuilderJc(&_stringBuilder.u, fValue, _thCxt)
      , toStringNonPersist_StringBuilderJc(&(&_stringBuilder.u)->base.object, _thCxt)
      )/*J2C:non-persistent*/;
    /**This String can be used as input for any method, which processed the String*/
    processString_TestString_Test(/*static*/ssn, _thCxt);
    /***/
    ssn = 
      ( setLength_StringBuilderJc(&_stringBuilder.u, 0, _thCxt)
      , append_z_StringBuilderJc(&_stringBuilder.u, "second ", _thCxt)
      , append_I_StringBuilderJc(&_stringBuilder.u, value, _thCxt)
      , toStringNonPersist_StringBuilderJc(&(&_stringBuilder.u)->base.object, _thCxt)
      )/*J2C:non-persistent*/;
    processString_TestString_Test(/*static*/ssn, _thCxt);
    /***/
    ssn = 
      ( append_z_StringBuilderJc(&_stringBuilder.u, ", third", _thCxt)
      , toStringNonPersist_StringBuilderJc(&(&_stringBuilder.u)->base.object, _thCxt)
      )/*J2C:non-persistent*/;//ssn = "forth, " + ssn;
    
    /**Use it: */
    processString_TestString_Test(/*static*/ssn, _thCxt);
    pos = indexOf_C_StringJc(ssn, '.');
    if(pos < 0) 
    { 
      
      pos = 0;
    }
    
    { 
      int32 pos2; 
      
      
      pos2 = indexOf_s_StringJc(ssn, s0_StringJc("third"));
      if(pos2 >= 0) 
      { 
        
        pos += pos2;
      }
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void testStringConcatenationInStack_TestString_Test(TestString_Test_s* ythis, int32 value, float fValue, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtbl = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  mtbl->testStringConcatenationInStack(ythis, value, fValue, _thCxt);
}


/**Examples for String concatenations.*/
void testStringConcatenationWithTemps_TestString_Test_F(TestString_Test_s* ythis, int32 value, float fValue, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("testStringConcatenationWithTemps_TestString_Test_F");
  
  { 
    StringJc ssn = CONST_z_StringJc("test "); 
    
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    StringBuilderJc* _tempString1_2=null; 
    StringBuilderJc* _tempString1_3=null; 
    StringBuilderJc* _tempString1_4=null; 
    
    ssn = 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "test ", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, value, _thCxt)
      , append_z_StringBuilderJc(_tempString1_1, " miles", _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      )/*J2C:non-persistent*/;
    processString_TestString_Test(/*static*/ssn, _thCxt);//System.out.println(ssn);
    
    ssn = 
      ( _tempString1_2 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_2)
      , append_z_StringBuilderJc(_tempString1_2, "second ", _thCxt)
      , append_I_StringBuilderJc(_tempString1_2, value, _thCxt)
      , toString_StringBuilderJc(&(_tempString1_2)->base.object, _thCxt)
      )/*J2C:non-persistent*/;
    ssn = 
      ( _tempString1_3 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_3)
      , append_s_StringBuilderJc(_tempString1_3, ssn, _thCxt)
      , append_z_StringBuilderJc(_tempString1_3, ", third", _thCxt)
      , toString_StringBuilderJc(&(_tempString1_3)->base.object, _thCxt)
      )/*J2C:non-persistent*/;
    ssn = 
      ( _tempString1_4 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_4)
      , append_z_StringBuilderJc(_tempString1_4, "forth, ", _thCxt)
      , append_s_StringBuilderJc(_tempString1_4, ssn, _thCxt)
      , toString_StringBuilderJc(&(_tempString1_4)->base.object, _thCxt)
      )/*J2C:non-persistent*/;//System.out.println(ssn);
    
    processString_TestString_Test(/*static*/ssn, _thCxt);//StringBuffer buffer = new StringBuffer(40);
    
    activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
    activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_2->base.object, null);
    activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_3->base.object, null);
    activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_4->base.object, null);
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void testStringConcatenationWithTemps_TestString_Test(TestString_Test_s* ythis, int32 value, float fValue, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtbl = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  mtbl->testStringConcatenationWithTemps(ythis, value, fValue, _thCxt);
}

void testStringConcatenationUsingBuilder_TestString_Test_F(TestString_Test_s* ythis, int32 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("testStringConcatenationUsingBuilder_TestString_Test_F");
  
  { 
    StringBuilderJc buffer = { 0 };   /*A buffer in stack: */
    StringJc ssn; 
    int32 pos;   /*Test substring, indexof. */
    
    StringJc _persistring1_1=NULL_StringJc; //J2C: temporary persistent Strings
    StringJc _temp1_1; //J2C: temporary references for concatenation
    
    
    //J2C: constructor for embedded element-ObjectJc
    init_ObjectJc(&(buffer.base.object), sizeof(buffer), 0); 
    ctorO_I_StringBuilderJc(/*static*/&(buffer.base.object), 40, _thCxt);
    append_z_StringBuilderJc(& (buffer), "buffer:", _thCxt);
    append_I_StringBuilderJc(& (buffer), 123, _thCxt);
    ssn = _persistring1_1 = toStringPersist_StringBuilderJc(& ((buffer).base.object), _thCxt)/*J2C:non-persistent*/;
    pos = 
      ( _temp1_1= substring_I_StringJc(ssn, 4, _thCxt)
      , indexOf_C_StringJc(_temp1_1, 'i')
      );
    activateGarbageCollectorAccess_BlockHeapJc(PTR_StringJc(_persistring1_1), null);
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void testStringConcatenationUsingBuilder_TestString_Test(TestString_Test_s* ythis, int32 value, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtbl = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  mtbl->testStringConcatenationUsingBuilder(ythis, value, _thCxt);
}

StringJc testStringParameter_SS_TestString_Test_F(TestString_Test_s* ythis, StringJc s1, StringJc s2, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("testStringParameter_SS_TestString_Test_F");
  
  { 
    StringJc ret;   /**/
    
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    ret = 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_s_StringBuilderJc(_stringBuilderThCxt, s1, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, " to ", _thCxt)
      , append_s_StringBuilderJc(_stringBuilderThCxt, s2, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      )/*J2C:non-persistent*/;
    { STACKTRC_LEAVE;
      return ret;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc testStringParameter_SS_TestString_Test(TestString_Test_s* ythis, StringJc s1, StringJc s2, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtbl = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  return mtbl->testStringParameter_SS(ythis, s1, s2, _thCxt);
}

void testStringParameter_TestString_Test_F(TestString_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtthis = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  
  STACKTRC_TENTRY("testStringParameter_TestString_Test_F");
  
  { 
    DateJc_s dateFrom = { 0 };   /**/
    DateJc_s dateTo = { 0 };   /**/
    SimpleDateFormatJc_s dateFormat = { 0 };   /**/
    StringJc sResult; 
    
    StringJc _persistring1_1=NULL_StringJc; //J2C: temporary persistent Strings
    
    
    //J2C: constructor for embedded element-ObjectJc
    init_ObjectJc(&(dateFrom.base.object), sizeof(dateFrom), 0); 
    ctorO_DateJc(/*static*/&(dateFrom.base.object), _thCxt);
    
    //J2C: constructor for embedded element-ObjectJc
    init_ObjectJc(&(dateTo.base.object), sizeof(dateTo), 0); 
    ctorO_I_DateJc(/*static*/&(dateTo.base.object), getTime_DateJc(& (dateFrom)) + 3600000, _thCxt);
    
    //J2C: constructor for embedded element-ObjectJc
    init_ObjectJc(&(dateFormat.base.object), sizeof(dateFormat), 0); 
    ctorO_s_SimpleDateFormatJc(/*static*/&(dateFormat.base.object), s0_StringJc("yy_MMM_dd_HHmmss_SS"), _thCxt);
    sResult = _persistring1_1 = persist_StringJc(mtthis->testStringParameter_SS(ythis, format_SimpleDateFormatJc(& (dateFormat), (& (dateFrom))->val, _thCxt), format_SimpleDateFormatJc(& (dateFormat), (& (dateTo))->val, _thCxt), _thCxt))/*J2C:non-persistent*/;
    println_s_PrintStreamJc(REFJc(out_SystemJc), sResult, _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(PTR_StringJc(_persistring1_1), null);
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void testStringParameter_TestString_Test(TestString_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtbl = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  mtbl->testStringParameter(ythis, _thCxt);
}


/*** */
StringJc testFormat_TestString_Test_F(TestString_Test_s* ythis, int32 value, float fValue, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("testFormat_TestString_Test_F");
  
  { 
    StringJc result;   /**/
    
    
    result = format_a_StringJc(/*static*/s0_StringJc("format intVal=%d floatVal=%3.4f test"), "IF", value, fValue, _thCxt)/*J2C:non-persistent*/;
    processString_TestString_Test(/*static*/result, _thCxt);
    { STACKTRC_LEAVE;
      return result;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc testFormat_TestString_Test(TestString_Test_s* ythis, int32 value, float fValue, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtbl = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  return mtbl->testFormat(ythis, value, fValue, _thCxt);
}

void testReplace_TestString_Test_F(TestString_Test_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("testReplace_TestString_Test_F");
  
  { 
    StringJc src = CONST_z_StringJc("C:\\directory/myFolder/myFile.x"); 
    StringJc dst; 
    
    
    src = z_StringJc("C:\\directory/myFolder/myFile.x")/*J2C:non-persistent*/;
    dst = replace_StringJc(src, '\\', '/', _thCxt)/*J2C:non-persistent*/;
    setLength_StringBuilderJc(REFJc(ythis->buffer1), 0, _thCxt);
    append_s_StringBuilderJc(REFJc(ythis->buffer1), replace_StringJc(src, '\\', '/', _thCxt), _thCxt);
    setLength_StringBuilderJc(REFJc(ythis->buffer1), 0, _thCxt);
    append_s_StringBuilderJc(REFJc(ythis->buffer1), src, _thCxt);
    /***/
    src = toStringNonPersist_StringBuilderJc(& ((*(REFJc(ythis->buffer1))).base.object)/*J2cT1*/, _thCxt)/*J2C:non-persistent*/;
    /**This expression copies the replaced text in the buffer1.*/
    replace_StringBuilderJc(REFJc(ythis->buffer1), 0, length_StringBuilderJc(REFJc(ythis->buffer1)), replace_StringJc(src, '\\', '/', _thCxt), _thCxt);
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void testReplace_TestString_Test(TestString_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtbl = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  mtbl->testReplace(ythis, _thCxt);
}

void testInsertCharArray_TestString_Test_F(TestString_Test_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("testInsertCharArray_TestString_Test_F");
  
  { 
    StringJc _temp1_1; //J2C: temporary references for concatenation
    
    setLength_StringBuilderJc(REFJc(ythis->buffer1), 0, _thCxt);
    append_z_StringBuilderJc(REFJc(ythis->buffer1), "1234", _thCxt);
    ythis->charArray->data[0] = 'A';
    ythis->charArray->data[1] = 'Q';
    ythis->charArray->data[2] = 'X';
    insert_CYII_StringBuilderJc(REFJc(ythis->buffer1), 2, ythis->charArray, 1, 2, _thCxt);
    /***/
    ASSERT(/*static*/
      ( _temp1_1= toStringNonPersist_StringBuilderJc(& ((*(REFJc(ythis->buffer1))).base.object)/*J2cT1*/, _thCxt)
      , equals_StringJc(_temp1_1, s0_StringJc("12QX34"))
      ));
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void testInsertCharArray_TestString_Test(TestString_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtbl = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  mtbl->testInsertCharArray(ythis, _thCxt);
}

StringJc toString_TestString_Test_F(ObjectJc* ithis, ThCxt* _thCxt)
{ TestString_Test_s* ythis = (TestString_Test_s*)ithis;
  
  STACKTRC_TENTRY("toString_TestString_Test_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return ythis->stringRef;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc toString_TestString_Test(ObjectJc* ithis, ThCxt* _thCxt)
{ Mtbl_ObjectJc const* mtbl = (Mtbl_ObjectJc const*)getMtbl_ObjectJc(ithis, sign_Mtbl_ObjectJc);
  return mtbl->toString(ithis, _thCxt);
}

void testGarbageString_TestString_Test_F(TestString_Test_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("testGarbageString_TestString_Test_F");
  
  { 
    
    set_StringJc(&(ythis->stringRef), z_StringJc("other String"));
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void testGarbageString_TestString_Test(TestString_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtbl = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  mtbl->testGarbageString(ythis, _thCxt);
}


/**Example for StringBuffer usage.*/
void testStringBuffer_TestString_Test_F(TestString_Test_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("testStringBuffer_TestString_Test_F");
  
  { 
    StringJc s1;   /**/
    struct StringBuilderJc_t* sb = null;   /*The StringBuffer is allocated in BlockHeapJc, containing the max possible buffer size,*/
    StringJc ss;   /**/
    
    ObjectJc *newObj1_1=null; //J2C: temporary Objects for new operations
    
    setLength_StringBuilderJc(& (ythis->bufferEmbedded.sb), 0, _thCxt);
    
      ( append_z_StringBuilderJc(& (ythis->bufferEmbedded.sb), "content:", _thCxt)
      , append_s_StringBuilderJc(& (ythis->bufferEmbedded.sb), ythis->stringRef, _thCxt)
      );
    println_O_PrintStreamJc(REFJc(out_SystemJc), & ((ythis->bufferEmbedded.sb).base.object), _thCxt);
    s1 = toStringNonPersist_StringBuilderJc(& ((ythis->bufferEmbedded.sb).base.object), _thCxt)/*J2C:non-persistent*/;
    println_s_PrintStreamJc(REFJc(out_SystemJc), s1, _thCxt);
    set_StringJc(&(ythis->stringRef), s1);
    
    sb = ctorO_StringBuilderJc(/*static*/(newObj1_1 = alloc_ObjectJc(sizeof_StringBuilderJc, 0, _thCxt)), _thCxt);
    setLength_StringBuilderJc(sb, 0, _thCxt);
    
      ( append_z_StringBuilderJc(sb, "test ", _thCxt)
      , append_I_StringBuilderJc(sb, 5, _thCxt)
      , append_z_StringBuilderJc(sb, " Stringbuffer", _thCxt)
      );
    println_O_PrintStreamJc(REFJc(out_SystemJc), & ((* (sb)).base.object), _thCxt);
    ss = toStringNonPersist_StringBuilderJc(& ((* (sb)).base.object), _thCxt)/*J2C:non-persistent*/;
    println_s_PrintStreamJc(REFJc(out_SystemJc), ss, _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(newObj1_1, null);
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void testStringBuffer_TestString_Test(TestString_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtbl = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  mtbl->testStringBuffer(ythis, _thCxt);
}


/*** <b>Persistence of Strings</b>*/
void testNonPersistenceOfStrings_TestString_Test_F(TestString_Test_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("testNonPersistenceOfStrings_TestString_Test_F");
  
  { 
    StringJc ss;   /**/
    
    
    setLength_StringBuilderJc(& (ythis->bufferEmbedded.sb), 0, _thCxt);
    ss = 
      ( append_z_StringBuilderJc(& (ythis->bufferEmbedded.sb), "content:", _thCxt)
      , append_I_StringBuilderJc(& (ythis->bufferEmbedded.sb), 234, _thCxt)
      , toStringNonPersist_StringBuilderJc(& ((ythis->bufferEmbedded.sb).base.object), _thCxt)
      )/*J2C:non-persistent*/;
    setLength_StringBuilderJc(& (ythis->bufferEmbedded.sb), 0, _thCxt);
    
      ( append_z_StringBuilderJc(& (ythis->bufferEmbedded.sb), " TEST ", _thCxt)
      , append_s_StringBuilderJc(& (ythis->bufferEmbedded.sb), ss, _thCxt)
      );
    /***/
    ss = toStringNonPersist_StringBuilderJc(& ((ythis->bufferEmbedded.sb).base.object), _thCxt)/*J2C:non-persistent*/;
    println_s_PrintStreamJc(REFJc(out_SystemJc), ss, _thCxt);
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void testNonPersistenceOfStrings_TestString_Test(TestString_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtbl = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  mtbl->testNonPersistenceOfStrings(ythis, _thCxt);
}


/**This routine has the same content like {@link #testNonPersistenceOfStrings()},*/
void testPersistenceOfStrings_TestString_Test_F(TestString_Test_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("testPersistenceOfStrings_TestString_Test_F");
  
  { 
    StringJc ss; 
    
    StringJc _persistring1_1=NULL_StringJc, _persistring1_2=NULL_StringJc; //J2C: temporary persistent Strings
    
    setLength_StringBuilderJc(& (ythis->bufferEmbedded.sb), 0, _thCxt);
    ss = 
      ( append_z_StringBuilderJc(& (ythis->bufferEmbedded.sb), "content:", _thCxt)
      , append_I_StringBuilderJc(& (ythis->bufferEmbedded.sb), 234, _thCxt)
      , _persistring1_1 = toStringPersist_StringBuilderJc(& ((ythis->bufferEmbedded.sb).base.object), _thCxt)
      )/*J2C:non-persistent*/;
    setLength_StringBuilderJc(& (ythis->bufferEmbedded.sb), 0, _thCxt);
    
      ( append_z_StringBuilderJc(& (ythis->bufferEmbedded.sb), " TEST ", _thCxt)
      , append_s_StringBuilderJc(& (ythis->bufferEmbedded.sb), ss, _thCxt)
      );
    ss = _persistring1_2 = toStringPersist_StringBuilderJc(& ((ythis->bufferEmbedded.sb).base.object), _thCxt)/*J2C:non-persistent*/;
    println_s_PrintStreamJc(REFJc(out_SystemJc), ss, _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(PTR_StringJc(_persistring1_1), null);
    activateGarbageCollectorAccess_BlockHeapJc(PTR_StringJc(_persistring1_2), null);
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void testPersistenceOfStrings_TestString_Test(TestString_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtbl = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  mtbl->testPersistenceOfStrings(ythis, _thCxt);
}


/**This routine uses the class java.lang.Date und SimpleFormatter*/
StringJc testDateString_TestString_Test_F(TestString_Test_s* ythis, StringJc sPath, int32 ident, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("testDateString_TestString_Test_F");
  
  { 
    DateJc_s date = { 0 };   /**/
    SimpleDateFormatJc_s dateFormat = { 0 };   /**/
    StringJc sDateString;   /**/
    StringJc sFileName;   /**/
    
    struct _stringBuilder_t{ StringBuilderJc u; char _b[150-4]; }_stringBuilder = { CONST_addSizeStack_StringBuilderJc(&_stringBuilder.u, 150-4), {0}};
    
    
    //J2C: constructor for embedded element-ObjectJc
    init_ObjectJc(&(date.base.object), sizeof(date), 0); 
    ctorO_DateJc(/*static*/&(date.base.object), _thCxt);
    
    //J2C: constructor for embedded element-ObjectJc
    init_ObjectJc(&(dateFormat.base.object), sizeof(dateFormat), 0); 
    ctorO_s_SimpleDateFormatJc(/*static*/&(dateFormat.base.object), s0_StringJc("yy_MMM_dd_HHmmss_SS"), _thCxt);
    sDateString = format_SimpleDateFormatJc(& (dateFormat), (& (date))->val, _thCxt)/*J2C:non-persistent*/;
    sFileName = 
      ( setLength_StringBuilderJc(&_stringBuilder.u, 0, _thCxt)
      , append_s_StringBuilderJc(&_stringBuilder.u, sPath, _thCxt)
      , append_z_StringBuilderJc(&_stringBuilder.u, "file_", _thCxt)
      , append_I_StringBuilderJc(&_stringBuilder.u, ident, _thCxt)
      , append_z_StringBuilderJc(&_stringBuilder.u, "_", _thCxt)
      , append_s_StringBuilderJc(&_stringBuilder.u, sDateString, _thCxt)
      , append_z_StringBuilderJc(&_stringBuilder.u, ".txt", _thCxt)
      , toString_StringBuilderJc(&(&_stringBuilder.u)->base.object, _thCxt)
      )/*J2C:non-persistent*/;
    /***/
    { STACKTRC_LEAVE;
      return copyToThreadCxt_StringJc(sFileName, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc testDateString_TestString_Test(TestString_Test_s* ythis, StringJc sPath, int32 ident, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtbl = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  return mtbl->testDateString(ythis, sPath, ident, _thCxt);
}


/**This routine uses the class java.lang.Date und SimpleFormatter*/
StringJc testDateStringDynamic_TestString_Test_F(TestString_Test_s* ythis, StringJc sPath, int32 ident, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("testDateStringDynamic_TestString_Test_F");
  
  { 
    struct DateJc_t* date = null; 
    struct SimpleDateFormatJc_t* dateFormat = null; 
    StringJc sDateString; 
    StringJc sFileName; 
    
    ObjectJc *newObj1_1=null, *newObj1_2=null; //J2C: temporary Objects for new operations
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    StringJc _persistring1_1=NULL_StringJc; //J2C: temporary persistent Strings
    
    
    date = ctorO_DateJc(/*static*/(newObj1_1 = alloc_ObjectJc(sizeof_DateJc_s, 0, _thCxt)), _thCxt);
    
    dateFormat = ctorO_s_SimpleDateFormatJc(/*static*/(newObj1_2 = alloc_ObjectJc(sizeof_SimpleDateFormatJc_s, 0, _thCxt)), s0_StringJc("yy_MMM_dd_HHmmss_SS"), _thCxt);
    sDateString = _persistring1_1 = persist_StringJc(format_SimpleDateFormatJc(dateFormat, (date)->val, _thCxt))/*J2C:non-persistent*/;
    sFileName = 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_s_StringBuilderJc(_tempString1_1, sPath, _thCxt)
      , append_z_StringBuilderJc(_tempString1_1, "file_", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, ident, _thCxt)
      , append_z_StringBuilderJc(_tempString1_1, "_", _thCxt)
      , append_s_StringBuilderJc(_tempString1_1, sDateString, _thCxt)
      , append_z_StringBuilderJc(_tempString1_1, ".txt", _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      )/*J2C:non-persistent*/;
    { STACKTRC_LEAVE;
      activateGarbageCollectorAccess_BlockHeapJc(newObj1_1, PTR_StringJc(sFileName));
      activateGarbageCollectorAccess_BlockHeapJc(newObj1_2, PTR_StringJc(sFileName));
      activateGarbageCollectorAccess_BlockHeapJc(PTR_StringJc(_persistring1_1), PTR_StringJc(sFileName));
      activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, PTR_StringJc(sFileName));
      return sFileName;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc testDateStringDynamic_TestString_Test(TestString_Test_s* ythis, StringJc sPath, int32 ident, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtbl = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  return mtbl->testDateStringDynamic(ythis, sPath, ident, _thCxt);
}

void testOutStream_TestString_Test_F(TestString_Test_s* ythis, StringJc sPath, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("testOutStream_TestString_Test_F");
  
  { 
    
    TRY
    { 
      struct _stringBuilder_t{ StringBuilderJc u; char _b[256-4]; }_stringBuilder = { CONST_addSizeStack_StringBuilderJc(&_stringBuilder.u, 256-4), {0}};
      
      /***/
      //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->oStream1.base.object), sizeof(ythis->oStream1), 0); 
      ctorO_s_FileOutputStreamJc(/*static*/&(ythis->oStream1.base.object), 
        ( setLength_StringBuilderJc(&_stringBuilder.u, 0, _thCxt)
        , append_s_StringBuilderJc(&_stringBuilder.u, sPath, _thCxt)
        , append_z_StringBuilderJc(&_stringBuilder.u, "file1.txt", _thCxt)
        , toStringNonPersist_StringBuilderJc(&(&_stringBuilder.u)->base.object, _thCxt)
        ), _thCxt);
      /***/
      //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->oStream2.base.object), sizeof(ythis->oStream2), 0); 
      ctorO_s_FileOutputStreamJc(/*static*/&(ythis->oStream2.base.object), 
        ( setLength_StringBuilderJc(&_stringBuilder.u, 0, _thCxt)
        , append_s_StringBuilderJc(&_stringBuilder.u, sPath, _thCxt)
        , append_z_StringBuilderJc(&_stringBuilder.u, "file2.txt", _thCxt)
        , toStringNonPersist_StringBuilderJc(&(&_stringBuilder.u)->base.object, _thCxt)
        ), _thCxt);
      close_FileOutputStreamJc_F(& (ythis->oStream1), _thCxt);
      close_FileOutputStreamJc_F(& (ythis->oStream2), _thCxt);
    }_TRY
    CATCH(FileNotFoundException, exc)
    
      { 
         //J2C: temporary Stringbuffer for String concatenation
        StringBuilderJc* _tempString1_1=null; 
        
        println_s_PrintStreamJc(REFJc(out_SystemJc), 
          ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
          , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
          , append_z_StringBuilderJc(_tempString1_1, "not found: ", _thCxt)
          , append_s_StringBuilderJc(_tempString1_1, sPath, _thCxt)
          , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
          ), _thCxt);
        activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
      }
    CATCH(IOException, e)
    
      { 
         //J2C: temporary Stringbuffer for String concatenation
        StringBuilderJc* _tempString1_1=null; 
        
        println_s_PrintStreamJc(REFJc(out_SystemJc), 
          ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
          , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
          , append_z_StringBuilderJc(_tempString1_1, "file error: ", _thCxt)
          , append_s_StringBuilderJc(_tempString1_1, sPath, _thCxt)
          , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
          ), _thCxt);
        activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
      }
    END_TRY
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void testOutStream_TestString_Test(TestString_Test_s* ythis, StringJc sPath, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtbl = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  mtbl->testOutStream(ythis, sPath, _thCxt);
}

int32 testSomeSimpleStringMethods_TestString_Test_F(TestString_Test_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("testSomeSimpleStringMethods_TestString_Test_F");
  
  { 
    int32 ret = 0; 
    int32 pos = 0; 
    bool bOk = 0; 
    StringJc s1 = CONST_z_StringJc("abcdecde"); 
    StringJc s2 = CONST_z_StringJc("abc"); 
    char cc; 
    
    
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    s1 = z_StringJc("abcdecde")/*J2C:non-persistent*/;
    s2 = z_StringJc("abc")/*J2C:non-persistent*/;
    cc = charAt_StringJc(s1, 3);
    bOk = (cc == 'd');
    bOk = bOk && !equals_StringJc(s1, s2);
    bOk = bOk && startsWith_StringJc(s1, s2);//bOk = bOk && s1.equals((Object)s1);  //error while compiling, fault type conversion.
    
    ret = pos = /*? assignment*/indexOf_C_StringJc(s1, 'c');
    ret += pos = /*? assignment*/indexOf_CI_StringJc(s1, 'c', 2);//pos = 2, same as above, but seach from position 2 only
    
    ret += pos = /*? assignment*/indexOf_CI_StringJc(s1, 'c', 3);//pos = -1 because not found.
    
    ret = pos = /*? assignment*/indexOf_s_StringJc(s1, s0_StringJc("de"));
    ret += pos = /*? assignment*/indexOf_sI_StringJc(s1, s0_StringJc("de"), 2);//pos = 3, same as above, but seach from position 2 only
    
    ret += pos = /*? assignment*/indexOf_sI_StringJc(s1, s0_StringJc("de"), 4);//pos = -1 because not found.
    
    ret += pos = /*? assignment*/indexOf_sI_StringJc(s1, s0_StringJc("de"), 99);//pos = -1 because not found. Not an exception
    
    ret += pos = /*? assignment*/indexOf_sI_StringJc(s1, s0_StringJc("de"), -1);//pos = 3 because search from 0. Not an exception.
    
    ret = pos = /*? assignment*/lastIndexOf_C_StringJc(s1, 'c');
    ret += pos = /*? assignment*/lastIndexOf_CI_StringJc(s1, 'c', 2);//pos = 2, same as above, but seach from position 2 only
    
    ret += pos = /*? assignment*/lastIndexOf_CI_StringJc(s1, 'c', 3);//pos = -1 because not found.
    
    ret = pos = /*? assignment*/lastIndexOf_s_StringJc(s1, s0_StringJc("de"));
    ret += pos = /*? assignment*/lastIndexOf_sI_StringJc(s1, s0_StringJc("de"), 2);//pos = -1, because not found.
    
    ret += pos = /*? assignment*/lastIndexOf_sI_StringJc(s1, s0_StringJc("de"), 3);//pos = 3 because the string starts at 3.
    
    ret += pos = /*? assignment*/lastIndexOf_sI_StringJc(s1, s0_StringJc("de"), 99);//pos = -1 because not found. Not an exception
    
    ret += pos = /*? assignment*/lastIndexOf_sI_StringJc(s1, s0_StringJc("de"), -1);//pos = 3 because search from 0. Not an exception.
    
    { STACKTRC_LEAVE;
      return ret;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 testSomeSimpleStringMethods_TestString_Test(TestString_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtbl = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  return mtbl->testSomeSimpleStringMethods(ythis, _thCxt);
}


/**A CharSequence is the super-class of java.lang.String and java.lang.StringBuilder.*/
void testCharSequence_TestString_Test_F(TestString_Test_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("testCharSequence_TestString_Test_F");
  
  { 
    StringJc csq1; 
    
    StringJc _temp1_1; //J2C: temporary references for concatenation
    
    setLength_StringBuilderJc(REFJc(ythis->buffer1), 0, _thCxt);
    append_z_StringBuilderJc(REFJc(ythis->buffer1), "csq1", _thCxt);
    csq1 = toString_StringBuilderJc(&(REFJc(ythis->buffer1))->base.object, _thCxt)/*J2C:non-persistent*/;
    setLength_StringBuilderJc(& (ythis->bufferEmbedded.sb), 0, _thCxt);
    
      ( append_z_StringBuilderJc(& (ythis->bufferEmbedded.sb), "be_", _thCxt)
      , append_s_StringBuilderJc(& (ythis->bufferEmbedded.sb), csq1, _thCxt)
      );
    /***/
    ASSERT(/*static*/
      ( _temp1_1= toStringNonPersist_StringBuilderJc(& ((ythis->bufferEmbedded.sb).base.object), _thCxt)
      , equals_StringJc(_temp1_1, s0_StringJc("be_csq1"))
      ));
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void testCharSequence_TestString_Test(TestString_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtbl = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  mtbl->testCharSequence(ythis, _thCxt);
}


/**Calls the test routines.*/
StringJc testStringProcessing_TestString_Test_F(TestString_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtthis = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  
  STACKTRC_TENTRY("testStringProcessing_TestString_Test_F");
  
  { 
    int64 timeStart = 0; 
    int64 timeEnd = 0; 
    int32 timeRun = 0; 
    float adjustTime = 0; 
    StringJc str = NULL_StringJc; 
    StringJc sPath = CONST_z_StringJc("."); 
    StringJc s9; 
    
    struct _stringBuilder_t{ StringBuilderJc u; char _b[100-4]; }_stringBuilder = { CONST_addSizeStack_StringBuilderJc(&_stringBuilder.u, 100-4), {0}};
    StringJc _persistring1_1=NULL_StringJc, _persistring1_2=NULL_StringJc, _persistring1_3=NULL_StringJc; //J2C: temporary persistent Strings
    StringJc _new1_1; //J2C: temporary references for concatenation
    
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    timeStart = nanoTime_SystemJc(/*static*/_thCxt);
    TRY
    { 
      
      sleep_ThreadJc(/*static*/10, _thCxt);
    }_TRY
    CATCH(InterruptedException, e)
    
      { 
        
        
      }
    END_TRY
    timeEnd = nanoTime_SystemJc(/*static*/_thCxt);
    timeRun = (int32)(timeEnd - timeStart);
    /**Runtime output */
    println_s_PrintStreamJc(REFJc(out_SystemJc), 
      ( setLength_StringBuilderJc(&_stringBuilder.u, 0, _thCxt)
      , append_z_StringBuilderJc(&_stringBuilder.u, "10 ms: ", _thCxt)
      , append_I_StringBuilderJc(&_stringBuilder.u, timeRun, _thCxt)
      , append_z_StringBuilderJc(&_stringBuilder.u, "ns", _thCxt)
      , toStringNonPersist_StringBuilderJc(&(&_stringBuilder.u)->base.object, _thCxt)
      ), _thCxt);
    timeStart = nanoTime_SystemJc(/*static*/_thCxt);
    TRY
    { 
      
      sleep_ThreadJc(/*static*/100, _thCxt);
    }_TRY
    CATCH(InterruptedException, e)
    
      { 
        
        
      }
    END_TRY
    timeEnd = nanoTime_SystemJc(/*static*/_thCxt);
    timeRun = (int32)(timeEnd - timeStart);
    adjustTime = 100000.0F / timeRun;
    /**Runtime output */
    println_s_PrintStreamJc(REFJc(out_SystemJc), 
      ( setLength_StringBuilderJc(&_stringBuilder.u, 0, _thCxt)
      , append_z_StringBuilderJc(&_stringBuilder.u, "100 ms: ", _thCxt)
      , append_F_StringBuilderJc(&_stringBuilder.u, (timeRun * adjustTime), _thCxt)
      , append_z_StringBuilderJc(&_stringBuilder.u, "us", _thCxt)
      , toStringNonPersist_StringBuilderJc(&(&_stringBuilder.u)->base.object, _thCxt)
      ), _thCxt);
    timeStart = nanoTime_SystemJc(/*static*/_thCxt);
    timeEnd = nanoTime_SystemJc(/*static*/_thCxt);
    timeRun = (int32)(timeEnd - timeStart);
    /**Runtime output */
    println_s_PrintStreamJc(REFJc(out_SystemJc), 
      ( setLength_StringBuilderJc(&_stringBuilder.u, 0, _thCxt)
      , append_z_StringBuilderJc(&_stringBuilder.u, "emtpy measurement: ", _thCxt)
      , append_F_StringBuilderJc(&_stringBuilder.u, (timeRun * adjustTime), _thCxt)
      , append_z_StringBuilderJc(&_stringBuilder.u, "us", _thCxt)
      , toStringNonPersist_StringBuilderJc(&(&_stringBuilder.u)->base.object, _thCxt)
      ), _thCxt);
    timeStart = nanoTime_SystemJc(/*static*/_thCxt);
    concatenate_TestString_classic_Test(/*static*/456, 3.14F, _thCxt);
    concatenate_TestString_classic_Test(/*static*/457, 3.14F, _thCxt);
    concatenate_TestString_classic_Test(/*static*/458, 3.14F, _thCxt);
    concatenate_TestString_classic_Test(/*static*/459, 3.14F, _thCxt);
    concatenate_TestString_classic_Test(/*static*/42, 3.14F, _thCxt);
    concatenate_TestString_classic_Test(/*static*/43, 3.14F, _thCxt);
    concatenate_TestString_classic_Test(/*static*/44, 3.14F, _thCxt);
    concatenate_TestString_classic_Test(/*static*/45, 3.14F, _thCxt);
    concatenate_TestString_classic_Test(/*static*/46, 3.14F, _thCxt);
    concatenate_TestString_classic_Test(/*static*/47, 3.14F, _thCxt);
    timeEnd = nanoTime_SystemJc(/*static*/_thCxt);
    timeRun = (int32)(timeEnd - timeStart);
    /**Runtime output */
    println_s_PrintStreamJc(REFJc(out_SystemJc), 
      ( setLength_StringBuilderJc(&_stringBuilder.u, 0, _thCxt)
      , append_z_StringBuilderJc(&_stringBuilder.u, "TestString_classic.concatenate: ", _thCxt)
      , append_F_StringBuilderJc(&_stringBuilder.u, (timeRun * adjustTime), _thCxt)
      , append_z_StringBuilderJc(&_stringBuilder.u, "us", _thCxt)
      , toStringNonPersist_StringBuilderJc(&(&_stringBuilder.u)->base.object, _thCxt)
      ), _thCxt);
    timeStart = nanoTime_SystemJc(/*static*/_thCxt);
    mtthis->testStringConcatenationInStack(ythis, 456, 3.14F, _thCxt);
    mtthis->testStringConcatenationInStack(ythis, 456, 3.14F, _thCxt);
    mtthis->testStringConcatenationInStack(ythis, 456, 3.14F, _thCxt);
    mtthis->testStringConcatenationInStack(ythis, 456, 3.14F, _thCxt);
    mtthis->testStringConcatenationInStack(ythis, 456, 3.14F, _thCxt);
    mtthis->testStringConcatenationInStack(ythis, 456, 3.14F, _thCxt);
    mtthis->testStringConcatenationInStack(ythis, 456, 3.14F, _thCxt);
    mtthis->testStringConcatenationInStack(ythis, 456, 3.14F, _thCxt);
    mtthis->testStringConcatenationInStack(ythis, 456, 3.14F, _thCxt);
    mtthis->testStringConcatenationInStack(ythis, 456, 3.14F, _thCxt);
    timeEnd = nanoTime_SystemJc(/*static*/_thCxt);
    timeRun = (int32)(timeEnd - timeStart);
    /**Runtime output */
    println_s_PrintStreamJc(REFJc(out_SystemJc), 
      ( setLength_StringBuilderJc(&_stringBuilder.u, 0, _thCxt)
      , append_z_StringBuilderJc(&_stringBuilder.u, "testStringConcatenationInStack: ", _thCxt)
      , append_F_StringBuilderJc(&_stringBuilder.u, (timeRun * adjustTime), _thCxt)
      , append_z_StringBuilderJc(&_stringBuilder.u, "us", _thCxt)
      , toStringNonPersist_StringBuilderJc(&(&_stringBuilder.u)->base.object, _thCxt)
      ), _thCxt);
    timeStart = nanoTime_SystemJc(/*static*/_thCxt);
    mtthis->testStringConcatenationWithTemps(ythis, 456, 3.14F, _thCxt);
    mtthis->testStringConcatenationWithTemps(ythis, 456, 3.14F, _thCxt);
    mtthis->testStringConcatenationWithTemps(ythis, 456, 3.14F, _thCxt);
    mtthis->testStringConcatenationWithTemps(ythis, 456, 3.14F, _thCxt);
    mtthis->testStringConcatenationWithTemps(ythis, 456, 3.14F, _thCxt);
    mtthis->testStringConcatenationWithTemps(ythis, 456, 3.14F, _thCxt);
    mtthis->testStringConcatenationWithTemps(ythis, 456, 3.14F, _thCxt);
    mtthis->testStringConcatenationWithTemps(ythis, 456, 3.14F, _thCxt);
    mtthis->testStringConcatenationWithTemps(ythis, 456, 3.14F, _thCxt);
    mtthis->testStringConcatenationWithTemps(ythis, 456, 3.14F, _thCxt);
    timeEnd = nanoTime_SystemJc(/*static*/_thCxt);
    timeRun = (int32)(timeEnd - timeStart);
    /**Runtime output */
    println_s_PrintStreamJc(REFJc(out_SystemJc), 
      ( setLength_StringBuilderJc(&_stringBuilder.u, 0, _thCxt)
      , append_z_StringBuilderJc(&_stringBuilder.u, "testStringConcatenationWithTemps: ", _thCxt)
      , append_F_StringBuilderJc(&_stringBuilder.u, (timeRun * adjustTime), _thCxt)
      , append_z_StringBuilderJc(&_stringBuilder.u, "us", _thCxt)
      , toStringNonPersist_StringBuilderJc(&(&_stringBuilder.u)->base.object, _thCxt)
      ), _thCxt);
    (_new1_1 = mtthis->testFormat(ythis, 234, 3.14F, _thCxt));
    mtthis->testStringConcatenationUsingBuilder(ythis, 456, _thCxt);
    mtthis->testStringParameter(ythis, _thCxt);
    mtthis->testStringBuffer(ythis, _thCxt);
    mtthis->testReplace(ythis, _thCxt);
    mtthis->testNonPersistenceOfStrings(ythis, _thCxt);
    mtthis->testPersistenceOfStrings(ythis, _thCxt);
    str = _persistring1_1 = persist_StringJc(mtthis->testDateString(ythis, s0_StringJc("./"), 123, _thCxt))/*J2C:non-persistent*/;
    str = _persistring1_2 = persist_StringJc(mtthis->testDateStringDynamic(ythis, s0_StringJc("./"), 123, _thCxt))/*J2C:non-persistent*/;
    mtthis->testInsertCharArray(ythis, _thCxt);
    sPath = z_StringJc(".")/*J2C:non-persistent*/;
    /***/
    mtthis->testOutStream(ythis, 
      ( setLength_StringBuilderJc(&_stringBuilder.u, 0, _thCxt)
      , append_s_StringBuilderJc(&_stringBuilder.u, sPath, _thCxt)
      , append_z_StringBuilderJc(&_stringBuilder.u, "/", _thCxt)
      , toStringNonPersist_StringBuilderJc(&(&_stringBuilder.u)->base.object, _thCxt)
      ), _thCxt);
    mtthis->testSomeSimpleStringMethods(ythis, _thCxt);
    mtthis->testCharSequence(ythis, _thCxt);
    s9 = _persistring1_3 = persist_StringJc(mtthis->ObjectJc.toString(& ((* (ythis)).base.object)/*J2cT1*/, _thCxt))/*J2C:non-persistent*/;
    { STACKTRC_LEAVE;
      activateGarbageCollectorAccess_BlockHeapJc(PTR_StringJc(_persistring1_1), PTR_StringJc(s9));
      activateGarbageCollectorAccess_BlockHeapJc(PTR_StringJc(_persistring1_2), PTR_StringJc(s9));
      activateGarbageCollectorAccess_BlockHeapJc(PTR_StringJc(_persistring1_3), PTR_StringJc(s9));
      activateGarbageCollectorAccess_BlockHeapJc(PTR_StringJc(_new1_1), PTR_StringJc(s9));
      return s9;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc testStringProcessing_TestString_Test(TestString_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestString_Test const* mtbl = (Mtbl_TestString_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestString_Test);
  return mtbl->testStringProcessing(ythis, _thCxt);
}


void finalize_TestString_Test_F(ObjectJc* othis, ThCxt* _thCxt)
{ TestString_Test_s* ythis = (TestString_Test_s*)othis;  //upcasting to the real class.
 STACKTRC_TENTRY("finalize_TestString_Test_F");
  CLEAR_REFJc(ythis->buffer1);
  finalize_ObjectJc_F(&ythis->bufferEmbedded.sb.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ObjectJc_F(&ythis->sbufferFix.sb.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ObjectJc_F(&ythis->oStream1.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ObjectJc_F(&ythis->oStream2.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ObjectJc_F(&ythis->base.object, _thCxt); //J2C: finalizing the superclass.
  STACKTRC_LEAVE;
}




/**J2C: Reflections and Method-table *************************************************/
const MtblDef_TestString_Test mtblTestString_Test = {
{ { sign_Mtbl_TestString_Test//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((18 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, testStringConcatenationInStack_TestString_Test_F //testStringConcatenationInStack
, testStringConcatenationWithTemps_TestString_Test_F //testStringConcatenationWithTemps
, testStringConcatenationUsingBuilder_TestString_Test_F //testStringConcatenationUsingBuilder
, testStringParameter_SS_TestString_Test_F //testStringParameter_SS
, testStringParameter_TestString_Test_F //testStringParameter
, testFormat_TestString_Test_F //testFormat
, testReplace_TestString_Test_F //testReplace
, testInsertCharArray_TestString_Test_F //testInsertCharArray
, testGarbageString_TestString_Test_F //testGarbageString
, testStringBuffer_TestString_Test_F //testStringBuffer
, testNonPersistenceOfStrings_TestString_Test_F //testNonPersistenceOfStrings
, testPersistenceOfStrings_TestString_Test_F //testPersistenceOfStrings
, testDateString_TestString_Test_F //testDateString
, testDateStringDynamic_TestString_Test_F //testDateStringDynamic
, testOutStream_TestString_Test_F //testOutStream
, testSomeSimpleStringMethods_TestString_Test_F //testSomeSimpleStringMethods
, testCharSequence_TestString_Test_F //testCharSequence
, testStringProcessing_TestString_Test_F //testStringProcessing
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_TestString_Test_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_TestString_Test_F //toString
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_TestString_Test_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_TestString_Test_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_TestString_Test, ObjectJc) }
   }
 };

extern struct ClassJc_t const reflection_TestString_Test_s;
extern struct ClassJc_t const reflection_FileOutputStreamJc_s;
extern struct ClassJc_t const reflection_StringBuilderJc;
extern struct ClassJc_t const reflection_StringJc;
const struct Reflection_Fields_TestString_Test_s_t
{ ObjectArrayJc head; FieldJc data[11];
} reflection_Fields_TestString_Test_s =
{ CONST_ObjectArrayJc(FieldJc, 11, OBJTYPE_FieldJc, null, &reflection_Fields_TestString_Test_s)
, {
     { "buffer1"
    , 0 //nrofArrayElements
    , &reflection_StringBuilderJc
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestString_Test_s*)(0x1000))->buffer1) - (int32)(TestString_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestString_Test_s
    }
   , { "bufferInit"
    , 0 //nrofArrayElements
    , &reflection_StringBuilderJc
    , kReference_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestString_Test_s*)(0x1000))->bufferInit) - (int32)(TestString_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestString_Test_s
    }
   , { "bufferEmbedded"
    , 0 //nrofArrayElements
    , &reflection_StringBuilderJc
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestString_Test_s*)(0x1000))->bufferEmbedded) - (int32)(TestString_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestString_Test_s
    }
   , { "stringRef"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((TestString_Test_s*)(0x1000))->stringRef) - (int32)(TestString_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestString_Test_s
    }
   , { "sbufferFix"
    , 0 //nrofArrayElements
    , &reflection_StringBuilderJc
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestString_Test_s*)(0x1000))->sbufferFix) - (int32)(TestString_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestString_Test_s
    }
   , { "strArray"
    , 10 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ |kStaticArray_Modifier_reflectJc |kEmbeddedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestString_Test_s*)(0x1000))->strArray) - (int32)(TestString_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestString_Test_s
    }
   , { "strArray2"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ |kObjectArrayJc_Modifier_reflectJc |kReferencedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestString_Test_s*)(0x1000))->strArray2) - (int32)(TestString_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestString_Test_s
    }
   , { "charArray"
    , 0 //nrofArrayElements
    , REFLECTION_char
    , 4 << kBitPrimitiv_Modifier_reflectJc |kObjectArrayJc_Modifier_reflectJc |kReferencedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestString_Test_s*)(0x1000))->charArray) - (int32)(TestString_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestString_Test_s
    }
   , { "oStream1"
    , 0 //nrofArrayElements
    , &reflection_FileOutputStreamJc_s
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestString_Test_s*)(0x1000))->oStream1) - (int32)(TestString_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestString_Test_s
    }
   , { "oStream2"
    , 0 //nrofArrayElements
    , &reflection_FileOutputStreamJc_s
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestString_Test_s*)(0x1000))->oStream2) - (int32)(TestString_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestString_Test_s
    }
   , { "empty"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&empty_TestString_Test) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&empty_TestString_Test)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_TestString_Test_s
    }
} };
const ClassJc reflection_TestString_Test_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "TestString_Test_s"
,  0 //position of ObjectJc
, sizeof(TestString_Test_s)
, (FieldJcArray const*)&reflection_Fields_TestString_Test_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_TestString_Test_s //superclass
, null //interfaces
, 0    //modifiers
, &mtblTestString_Test.mtbl.head
};
