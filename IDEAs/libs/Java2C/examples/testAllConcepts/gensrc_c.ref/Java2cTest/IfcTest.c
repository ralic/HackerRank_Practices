/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "Java2cTest/IfcTest.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "Jc/StringJc.h"  //embedded type in class data

/**This interface should demonstrate the translation of Java-Interfaces to C. Visit the translated
<code>Ifc_Test.c</code> and <code>Ifc_Test.h</code>.
<br>
The C-File contains code for:
<ul>
<li>An implementation of all interface methods, which searches the appropriate method table
of the interface inside the method table of the given instance, calling <code>getMtbl_ObjectJc(...)</code>
and than calls the method dynamically. The user can call this method static linked, this method
organized the dynmically call. ( Elsewhere the user can optimize and call via method table itself,
Java2C translates such calls.)
<li>Reflection for the interface, contains the reference to the method table.
<li>The definition of the <code>sign_Mtbl_...</code> of this interface.
<li>The definition of all final static variables which are not defined as <code>#define ...</code>
</ul>
The Headerfile contains declarations and definitions for:
<ul>
<li>The <code>typedef struct {...}</code> of the interface type. The struct contains only
<code>union { ObjectJc object; } base; </code>
<li>Typedef for the array type.
<li>extern declaration for reflection.
<li>extern declaration or <code>#define ...</code>for all static final values.
<li>Definition of <code>MT_</code> method type of the interface methods.
<li>Declaration of head of interface methods to implement the dynamic call.
<li>extern Declaration of the <code>sign_Mtbl_...</code> of teh interface.
<li>Definition of the struct of the method table.
</ul>
Compilation and linking the C-File:
The kept C-File of any translated Java-interfaces should be compiled and provided as object-file
maybe in a library outside of a usage of the interface in an implementation.
It means, it should not be a part of a implementation library of the interface,
but it should be a part of a library providing the interface stand-alone independent of its usage.
It is the same like a Java-package with interfaces only. It has its compiled byte code.
<br>

@author Hartmut Schorrig

*/


const char sign_Mtbl_IfcToTest[] = "IfcToTest"; //to mark method tables of all implementations

StringJc constString_IfcToTest = CONST_z_StringJc("IfcTest");
const int32 constValue2_IfcToTest = (constValue_IfcToTest + 1) / 2 + 1;

/**Example for a calculated constant using another calculated constant as input.*/
/*J2C: dynamic call variant of the override-able method: */
int32 processIfcMethod_IfcToTest(ObjectJc* ithis, int32 input, ThCxt* _thCxt)
{ Mtbl_IfcToTest const* mtbl = (Mtbl_IfcToTest const*)getMtbl_ObjectJc(ithis, sign_Mtbl_IfcToTest);
  return mtbl->processIfcMethod(ithis, input, _thCxt);
}


/**Example for a second interface method, not a recentness, but see next {@link #anotherIfcmethod(float)}.*/
/*J2C: dynamic call variant of the override-able method: */
int32 anotherIfcmethod_i_IfcToTest(ObjectJc* ithis, int32 input, ThCxt* _thCxt)
{ Mtbl_IfcToTest const* mtbl = (Mtbl_IfcToTest const*)getMtbl_ObjectJc(ithis, sign_Mtbl_IfcToTest);
  return mtbl->anotherIfcmethod_i(ithis, input, _thCxt);
}


/**Example for an interface method with same name as another in the same class, but other parameter set.*/
/*J2C: dynamic call variant of the override-able method: */
float anotherIfcmethod_f_IfcToTest(ObjectJc* ithis, float input, ThCxt* _thCxt)
{ Mtbl_IfcToTest const* mtbl = (Mtbl_IfcToTest const*)getMtbl_ObjectJc(ithis, sign_Mtbl_IfcToTest);
  return mtbl->anotherIfcmethod_f(ithis, input, _thCxt);
}

 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_IfcToTest_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_IfcToTest_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, 0 /*J2C: no Mtbl*/ }
   }
 };

extern struct ClassJc_t const reflection_IfcToTest_s;
extern struct ClassJc_t const reflection_StringJc;
const struct Reflection_Fields_IfcToTest_s_t
{ ObjectArrayJc head; FieldJc data[2];
} reflection_Fields_IfcToTest_s =
{ CONST_ObjectArrayJc(FieldJc, 2, OBJTYPE_FieldJc, null, &reflection_Fields_IfcToTest_s)
, {
     { "constString"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&constString_IfcToTest) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&constString_IfcToTest)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_IfcToTest_s
    }
   , { "constValue2"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&constValue2_IfcToTest) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&constValue2_IfcToTest)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_IfcToTest_s
    }
} };
const ClassJc reflection_IfcToTest_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "IfcToTest_s"
,  0 //position of ObjectJc
, sizeof(IfcToTest_s)
, (FieldJcArray const*)&reflection_Fields_IfcToTest_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_IfcToTest_s //superclass
, null //interfaces
, 0    //modifiers
};
