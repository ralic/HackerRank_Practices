/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "TestContainer_Test.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "Jc/MathJc.h"  //reference-association: MathJc_s

/**This class demonstrates and tests the usage of some container concepts.

*/


const char sign_Mtbl_TestContainer_Test[] = "TestContainer_Test"; //to mark method tables of all implementations

typedef struct MtblDef_TestContainer_Test_t { Mtbl_TestContainer_Test mtbl; MtblHeadJc end; } MtblDef_TestContainer_Test;
 extern MtblDef_TestContainer_Test const mtblTestContainer_Test;

/*Constructor *//**J2C: autogenerated as default constructor. */
struct TestContainer_Test_t* ctorO_TestContainer_Test(ObjectJc* othis, ThCxt* _thCxt)
{ TestContainer_Test_s* ythis = (TestContainer_Test_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_TestContainer_Test");
  checkConsistence_ObjectJc(othis, sizeof(TestContainer_Test_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_TestContainer_Test_s, sizeof(TestContainer_Test_s));  
  //j2c: Initialize all class variables:
  {
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->linkedList.base.object), sizeof(ythis->linkedList), 0); 
      ctorO_LinkedListJc(/*static*/&(ythis->linkedList.base.object));
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->anObject.base.object), sizeof(ythis->anObject), 0); 
      ctorO_SimpleClass_Test(/*static*/&(ythis->anObject.base.object), _thCxt);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->stressTest.base.object), sizeof(ythis->stressTest), 0); 
      ctorO_C_stressTest_TestContainer_Test(ythis, &(ythis->stressTest.base.object), "stressTestC", _thCxt);
  }/*J2C:No body for constructor*/

  STACKTRC_LEAVE;
  return ythis;
}


void addToList_TestContainer_Test_F(TestContainer_Test_s* ythis, struct ObjectJc_t* src, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addToList_TestContainer_Test_F");
  
  { 
    
    add_LinkedListJcF(& (ythis->linkedList), src, _thCxt);
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void addToList_TestContainer_Test(TestContainer_Test_s* ythis, struct ObjectJc_t* src, ThCxt* _thCxt)
{ Mtbl_TestContainer_Test const* mtbl = (Mtbl_TestContainer_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestContainer_Test);
  mtbl->addToList(ythis, src, _thCxt);
}

struct ObjectJc_t* removeFirstfromLinkedList_TestContainer_Test_F(TestContainer_Test_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("removeFirstfromLinkedList_TestContainer_Test_F");
  
  { 
    
    if(size_LinkedListJcF(& (ythis->linkedList)) > 0) 
    { 
      struct ObjectJc_t* data; 
      
      
      data = remove_LinkedListJcF(& (ythis->linkedList), _thCxt);
      { STACKTRC_LEAVE;
        return data;
      }
    }
    else 
    { 
      
      { STACKTRC_LEAVE;
        return null;
      }
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct ObjectJc_t* removeFirstfromLinkedList_TestContainer_Test(TestContainer_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestContainer_Test const* mtbl = (Mtbl_TestContainer_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestContainer_Test);
  return mtbl->removeFirstfromLinkedList(ythis, _thCxt);
}

void addSomeData_TestContainer_Test_F(TestContainer_Test_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addSomeData_TestContainer_Test_F");
  
  { 
    
    { int32 ix; 
      for(ix = 0; ix < 5; ix++)
        { 
          struct SimpleClass_Test_t* data = null; 
          
          ObjectJc *newObj3_1=null; //J2C: temporary Objects for new operations
          
          
          data = ctorO_SimpleClass_Test(/*static*/(newObj3_1 = alloc_ObjectJc(sizeof_SimpleClass_Test_s, 0, _thCxt)), _thCxt);
          add_LinkedListJcF(& (ythis->linkedList), & ((* (data)).base.object), _thCxt);
          activateGarbageCollectorAccess_BlockHeapJc(newObj3_1, null);
        }
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void addSomeData_TestContainer_Test(TestContainer_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestContainer_Test const* mtbl = (Mtbl_TestContainer_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestContainer_Test);
  mtbl->addSomeData(ythis, _thCxt);
}

void getAndRemoveAllData_TestContainer_Test_F(TestContainer_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestContainer_Test const* mtthis = (Mtbl_TestContainer_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestContainer_Test);
  
  STACKTRC_TENTRY("getAndRemoveAllData_TestContainer_Test_F");
  
  { 
    struct ObjectJc_t* data = null; 
    
    
    /*no initvalue*/
    do 
      { 
        
        data = mtthis->removeFirstfromLinkedList(ythis, _thCxt);
      }while(data != null);
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void getAndRemoveAllData_TestContainer_Test(TestContainer_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestContainer_Test const* mtbl = (Mtbl_TestContainer_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestContainer_Test);
  mtbl->getAndRemoveAllData(ythis, _thCxt);
}

void test_TestContainer_Test_F(TestContainer_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestContainer_Test const* mtthis = (Mtbl_TestContainer_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestContainer_Test);
  
  STACKTRC_TENTRY("test_TestContainer_Test_F");
  
  { 
    
    mtthis->addSomeData(ythis, _thCxt);
    mtthis->getAndRemoveAllData(ythis, _thCxt);
    start_ThreadJc(& ((ythis->stressTest).base.super), -1, _thCxt);//runs the thread, but the method finished.
    
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void test_TestContainer_Test(TestContainer_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestContainer_Test const* mtbl = (Mtbl_TestContainer_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestContainer_Test);
  mtbl->test(ythis, _thCxt);
}



/**J2C: Reflections and Method-table *************************************************/
const MtblDef_TestContainer_Test mtblTestContainer_Test = {
{ { sign_Mtbl_TestContainer_Test//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, addToList_TestContainer_Test_F //addToList
, removeFirstfromLinkedList_TestContainer_Test_F //removeFirstfromLinkedList
, addSomeData_TestContainer_Test_F //addSomeData
, getAndRemoveAllData_TestContainer_Test_F //getAndRemoveAllData
, test_TestContainer_Test_F //test
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_TestContainer_Test_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_TestContainer_Test_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_TestContainer_Test, ObjectJc) }
   }
 };

extern struct ClassJc_t const reflection_TestContainer_Test_s;
extern struct ClassJc_t const reflection_C_stressTest_TestContainer_Test_s;
extern struct ClassJc_t const reflection_LinkedListJc;
extern struct ClassJc_t const reflection_SimpleClass_Test_s;
const struct Reflection_Fields_TestContainer_Test_s_t
{ ObjectArrayJc head; FieldJc data[3];
} reflection_Fields_TestContainer_Test_s =
{ CONST_ObjectArrayJc(FieldJc, 3, OBJTYPE_FieldJc, null, &reflection_Fields_TestContainer_Test_s)
, {
     { "linkedList"
    , 0 //nrofArrayElements
    , &reflection_LinkedListJc
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestContainer_Test_s*)(0x1000))->linkedList) - (int32)(TestContainer_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestContainer_Test_s
    }
   , { "anObject"
    , 0 //nrofArrayElements
    , &reflection_SimpleClass_Test_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestContainer_Test_s*)(0x1000))->anObject) - (int32)(TestContainer_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestContainer_Test_s
    }
   , { "stressTest"
    , 0 //nrofArrayElements
    , &reflection_C_stressTest_TestContainer_Test_s
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestContainer_Test_s*)(0x1000))->stressTest) - (int32)(TestContainer_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestContainer_Test_s
    }
} };
const ClassJc reflection_TestContainer_Test_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "TestContainer_Test_s"
,  0 //position of ObjectJc
, sizeof(TestContainer_Test_s)
, (FieldJcArray const*)&reflection_Fields_TestContainer_Test_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_TestContainer_Test_s //superclass
, null //interfaces
, 0    //modifiers
, &mtblTestContainer_Test.mtbl.head
};


const char sign_Mtbl_C_stressTest_TestContainer_Test[] = "C_stressTest_TestContainer_Test"; //to mark method tables of all implementations

typedef struct MtblDef_C_stressTest_TestContainer_Test_t { Mtbl_C_stressTest_TestContainer_Test mtbl; MtblHeadJc end; } MtblDef_C_stressTest_TestContainer_Test;
 extern MtblDef_C_stressTest_TestContainer_Test const mtblC_stressTest_TestContainer_Test;
void run_C_stressTest_TestContainer_Test_F(ObjectJc* ithis, ThCxt* _thCxt)
{ C_stressTest_TestContainer_Test_s* ythis = (C_stressTest_TestContainer_Test_s*)ithis;
  
  STACKTRC_TENTRY("run_C_stressTest_TestContainer_Test_F");
  
  { 
    bool bRun = true; 
    
    
    bRun = true;
    do 
      { 
        double whatodo; 
        
        
        whatodo = random_MathJc();
        if(whatodo < 0.25) 
        { //:add
          //:SimpleClass data = new SimpleClass();  //alloc in heap
          
          
          add_LinkedListJcF(& (ythis->outer->linkedList), & ((ythis->outer->anObject).base.object), _thCxt);//now only alloc node.
          
        }
        else if(whatodo < 0.5) 
        { //:remove
          
          
          if(size_LinkedListJcF(& (ythis->outer->linkedList)) > 0) 
          { 
            
            remove_LinkedListJcF(& (ythis->outer->linkedList), _thCxt);
          }
        }
        else if(whatodo < 0.625) 
        { //:wait thread
          
          
          TRY
          { 
            
            wait_ObjectJc(& ((* (ythis)).base.super.base.RunnableJc.base.object), 10, _thCxt);
          }_TRY
          CATCH(InterruptedException, exc)
          
            { 
              
              bRun = false;
            }
          END_TRY
        }
        else 
        { }
      }while(bRun);
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void run_C_stressTest_TestContainer_Test(ObjectJc* ithis, ThCxt* _thCxt)
{ Mtbl_RunnableJc const* mtbl = (Mtbl_RunnableJc const*)getMtbl_ObjectJc(ithis, sign_Mtbl_RunnableJc);
  mtbl->run(ithis, _thCxt);
}


/*Constructor *//**J2C: autogenerated as default constructor. */
struct C_stressTest_TestContainer_Test_t* ctorO_C_stressTest_TestContainer_Test(struct TestContainer_Test_t* outer, ObjectJc* othis, char const* name, ThCxt* _thCxt)
{ C_stressTest_TestContainer_Test_s* ythis = (C_stressTest_TestContainer_Test_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_C_stressTest_TestContainer_Test");
  checkConsistence_ObjectJc(othis, sizeof(C_stressTest_TestContainer_Test_s), null, _thCxt);  
  //J2C:super Constructor
  ctorO_z_ThreadJc(&ythis->base.object, name, _thCxt);
  setReflection_ObjectJc(othis, &reflection_C_stressTest_TestContainer_Test_s, sizeof(C_stressTest_TestContainer_Test_s));  
  ythis->outer = outer;
  //j2c: Initialize all class variables:
  {
  }/*J2C:No body for constructor*/

  STACKTRC_LEAVE;
  return ythis;
}




/**J2C: Reflections and Method-table *************************************************/
const MtblDef_C_stressTest_TestContainer_Test mtblC_stressTest_TestContainer_Test = {
{ { sign_Mtbl_C_stressTest_TestContainer_Test//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, { { sign_Mtbl_ThreadJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_ObjectJc_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_ObjectJc_F //toString
    }
    /**J2C: Mtbl-interfaces of C_stressTest_TestContainer_Test: */
  , { { sign_Mtbl_RunnableJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((1 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    , run_C_stressTest_TestContainer_Test_F //run
    , { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
        , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
        }
      , clone_ObjectJc_F //clone
      , equals_ObjectJc_F //equals
      , finalize_ObjectJc_F //finalize
      , hashCode_ObjectJc_F //hashCode
      , toString_ObjectJc_F //toString
      }
    }
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ThreadJc_s;
 static struct superClasses_C_stressTest_TestContainer_Test_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_C_stressTest_TestContainer_Test_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ThreadJc_s, OFFSET_Mtbl(Mtbl_C_stressTest_TestContainer_Test, ThreadJc) }
   }
 };

const ClassJc reflection_C_stressTest_TestContainer_Test_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "C_stressTest_TestC_er_Test_s"
,  0 //position of ObjectJc
, sizeof(C_stressTest_TestContainer_Test_s)
, null //attributes and associations
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_C_stressTest_TestContainer_Test_s //superclass
, null //interfaces
, 0    //modifiers
, &mtblC_stressTest_TestContainer_Test.mtbl.head
};
