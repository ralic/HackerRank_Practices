/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "TestAllConcepts_Test.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "AnyClass_Test.h"  //new object
#include "BlockHeap/BlockHeapJc.h"  //reference-association: BlockHeapJc
#include "J1c/LogMessageFile_MSG.h"  //new object
#include "Java2cTest/IfcTest.h"  //reference-association: ifc3
#include "Jc/FileIoJc.h"  //reference-association: out
#include "Jc/StringJc.h"  //embedded type in class data
#include "Jc/SystemJc.h"  //reference-association: SystemJc
#include "Jc/ThreadJc.h"  //reference-association: ThreadJc_s
#include "TestContainer_Test.h"  //new object
#include "TestgarbageCollector_Test.h"  //new object


/* J2C: Method-table-references *********************************************************/
#ifndef AnyClass_TestMTBDEF
  #define AnyClass_TestMTBDEF
  typedef struct AnyClass_TestMTB_t { struct Mtbl_AnyClass_Test_t const* mtbl; struct AnyClass_Test_t* ref; } AnyClass_TestMTB;
#endif


/**This class contains some examples to demonstrate and test all features of Java2C.
The elements all explained respecting the Java2C-features which are tested there.
<br>
<br>
Most of the methods demonstrates a programming style, which is opportune also in C.
<br>
The class is represent in C wit a struct type definition:
<pre>
typedef struct TestAllConcepts_Test_t
{
union { ObjectJc object; ImplIfc_Test_s super;} base;
int32 simpleInt;
...etc.
}
</pre>
The first element of struct is a union, which pools the super class, all interfaces and the ObjectJc-base.
The most inner super class has ObjectJc as its first Element, the access to that base of all super classes
can accessed immediately in this unit.
*/


const char sign_Mtbl_TestAllConcepts_Test[] = "TestAllConcepts_Test"; //to mark method tables of all implementations

typedef struct MtblDef_TestAllConcepts_Test_t { Mtbl_TestAllConcepts_Test mtbl; MtblHeadJc end; } MtblDef_TestAllConcepts_Test;
 extern MtblDef_TestAllConcepts_Test const mtblTestAllConcepts_Test;
const char kCharConst_TestAllConcepts_Test = (char)(3);
int32 nrofInstances_TestAllConcepts_Test = 5;
const int32 intArrayStaticConst_TestAllConcepts_Test[3] = { 10, 11, 12};

/*Constructor */
struct TestAllConcepts_Test_t* ctorO_TestAllConcepts_Test(ObjectJc* othis, ThCxt* _thCxt)
{ TestAllConcepts_Test_s* ythis = (TestAllConcepts_Test_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_TestAllConcepts_Test");
  checkConsistence_ObjectJc(othis, sizeof(TestAllConcepts_Test_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_TestAllConcepts_Test_s, sizeof(TestAllConcepts_Test_s));  
  //j2c: Initialize all class variables:
  {ObjectJc *newObj0_1=null, *newObj0_2=null, *newObj0_3=null; //J2C: temporary Objects for new operations
      
    ythis->simpleInt = 25;
    //J2C: constructor for embedded element-MemC
      ctorM_SimpleDataStruct_Test(/*static*/build_MemC(&ythis->embeddedData, sizeof(ythis->embeddedData)), _thCxt);
    //J2C: constructor for embedded element-MemC
      ctorM_SimpleDataStruct_Test(/*static*/build_MemC(&ythis->embeddedDataNotEnpand, sizeof(ythis->embeddedDataNotEnpand)), _thCxt);
    //J2C: constructor for embedded element-MemC
      ctorM_ExpandedDataStruct_Test(/*static*/build_MemC(&ythis->embeddedDataExpand, sizeof(ythis->embeddedDataExpand)), _thCxt);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->testWaitNotifyData.base.object), sizeof(ythis->testWaitNotifyData), 0); 
      ctorO_WaitNotifyData_TestWaitNotify_Test(/*static*/&(ythis->testWaitNotifyData.base.object), _thCxt);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->testThread.base.object), sizeof(ythis->testThread), 0); 
      ctorO_TestThread_Test(/*static*/&(ythis->testThread.base.object), & (ythis->testWaitNotifyData), _thCxt);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->testWaitNotify.base.object), sizeof(ythis->testWaitNotify), 0); 
      ctorO_TestWaitNotify_Test(/*static*/&(ythis->testWaitNotify.base.object), & (ythis->testWaitNotifyData), _thCxt);
    //J2C: constructor for embedded fix-size-StringBuffer
      init_ObjectJc(&ythis->stringBufferMain.sb.base.object, sizeof(StringBuilderJc) + 20000 - 4, 0);
      ctorO_I_StringBuilderJc(&ythis->stringBufferMain.sb.base.object, 20000, _thCxt);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->testString.base.object), sizeof(ythis->testString), 0); 
      ctorO_TestString_Test(/*static*/&(ythis->testString.base.object), & (ythis->stringBufferMain.sb), _thCxt);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->testStringFormatter.base.object), sizeof(ythis->testStringFormatter), 0); 
      ctorO_TestStringFormatter_Test(/*static*/&(ythis->testStringFormatter.base.object), _thCxt);
    /*J2C: newArray*/
      init_ObjectJc(&ythis->intArray.head.object, sizeof_ARRAYJc(int32, 1000), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&ythis->intArray.head.object, 1000, sizeof(int32), null, 0);//J2C: constructor for embedded array;
    ythis->intArrayRef = (int32_Y*)ctorO_ObjectArrayJc((newObj0_1 = alloc_ObjectJc( sizeof(ObjectArrayJc) + (234) * sizeof(int32), mIsLargeSize_objectIdentSize_ObjectJc, _thCxt)), 234, sizeof(int32),REFLECTION_int32, 0);  //J2C: assign a new ObjectArrayJc. ;
    init0_MemC(build_MemC(&ythis->intArraySimple, 1000 * sizeof(int32))); //J2C: init the embedded simple array;
    ythis->intArrayRefSimple = (int32_Y*)ctorO_ObjectArrayJc((newObj0_2 = alloc_ObjectJc( sizeof(ObjectArrayJc) + (234) * sizeof(int32), mIsLargeSize_objectIdentSize_ObjectJc, _thCxt)), 234, sizeof(int32),REFLECTION_int32, 0);  //J2C: assign a new ObjectArrayJc. ;
    /*J2C: newArray*/
      init_ObjectJc(&ythis->dataArrayEmbedded.head.object, sizeof_ARRAYJc(SimpleDataStruct_Test_s, 12), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&ythis->dataArrayEmbedded.head.object, 12, sizeof(SimpleDataStruct_Test_s), null, 0);//J2C: constructor for embedded array;
    init0_MemC(build_MemC(&ythis->dataArraySimpleEmbedded, 12 * sizeof(SimpleDataStruct_Test_s))); //J2C: init the embedded simple array;
    /*J2C: newArray*/
      init_ObjectJc(&ythis->dataRefArrayEmbedded.head.object, sizeof_ARRAYJc(SimpleDataStruct_Test_s, 12), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&ythis->dataRefArrayEmbedded.head.object, 12, sizeof(SimpleDataStruct_Test_s), null, 0);//J2C: constructor for embedded array;
    /*J2C: newArray*/
      init_ObjectJc(&ythis->dataRefArray.head.object, sizeof_ARRAYJc(SimpleDataStruct_Test_s, 12), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&ythis->dataRefArray.head.object, 12, sizeof(SimpleDataStruct_Test_s), null, 0);//J2C: constructor for embedded array;
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->implifc.base.object), sizeof(ythis->implifc), 0); 
      ctorO_ImplIfcTest(/*static*/&(ythis->implifc.base.object), 100, _thCxt);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->ifc3.base.object), sizeof(ythis->ifc3), 0); 
      ctorO_ImplIfcTest(/*static*/&(ythis->ifc3.base.object), 123, _thCxt);
    SETREFJc(ythis->ifc, & ((ythis->implifc).base.IfcToTest), IfcToTest_s);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->extendsImpl.base.object), sizeof(ythis->extendsImpl), 0); 
      ctorO_ExtendsImpl_Test(/*static*/&(ythis->extendsImpl.base.object), _thCxt);
    SETREFJc(ythis->ifc4, ctorO_ImplIfcTest(/*static*/(newObj0_3 = alloc_ObjectJc(sizeof_ImplIfcTest_s, 0, _thCxt)), 555, _thCxt), ImplIfcTest_s);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->testAnonymous.base.object), sizeof(ythis->testAnonymous), 0); 
      ctorO_TestAnonymous_Test(/*static*/&(ythis->testAnonymous.base.object), _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(newObj0_1, null);
    activateGarbageCollectorAccess_BlockHeapJc(newObj0_2, null);
    activateGarbageCollectorAccess_BlockHeapJc(newObj0_3, null);
  }
  { 
    ObjectJc *newObj1_1=null, *newObj1_2=null; //J2C: temporary Objects for new operations
    
    SETREFJc(ythis->implifc2, ctorO_ImplIfcTest(/*static*/(newObj1_1 = alloc_ObjectJc(sizeof_ImplIfcTest_s, 0, _thCxt)), 200, _thCxt), ImplIfcTest_s);
    SETREFJc(ythis->ifcNonVirtual, & ((* (REFJc(ythis->implifc2))).base.IfcToTest), IfcToTest_s);//use the interface reference.
    
    SETREFJc(ythis->anyRef, ctorO_AnyClass_Test(/*static*/(newObj1_2 = alloc_ObjectJc(sizeof_AnyClass_Test_s, 0, _thCxt)), & ((ythis->extendsImpl).base.super), _thCxt), AnyClass_Test_s);
    activateGarbageCollectorAccess_BlockHeapJc(newObj1_1, null);
    activateGarbageCollectorAccess_BlockHeapJc(newObj1_2, null);
  }
  STACKTRC_LEAVE;
  return ythis;
}


int32 access_i_TestAllConcepts_Test_F(TestAllConcepts_Test_s* ythis, int32 x, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("access_i_TestAllConcepts_Test_F");
  
  { 
    
    ythis->intArray.data[3] = ythis->simpleInt;
    ythis->intArrayRef->data[2] = kMsgBlockHeap_TestAllConcepts_Test;
    ythis->embeddedData.db = 3.14F;
    ythis->embeddedDataExpand.base.super.xb = (int16)x;
    ythis->embeddedDataNotEnpand.db = 2.7;
    ythis->simpleInt = intArrayStaticConst_TestAllConcepts_Test[1];
    ythis->intArrayRef2 = (struct int32_Y_t*)(&( ythis->intArray));//cast from a special embedded array type to int_Y
    
    ythis->intArrayRef2 = ythis->intArrayRef;//TODO intArray[2] = intArrayStatic[4];
    
    
    { 
      int32 maxQueue = 5;   /*Test get new array with embedded array elements. */
      SimpleDataStruct_Test_Y* entries;   /**/
      
      ObjectJc *newObj2_1=null; //J2C: temporary Objects for new operations
      
      maxQueue = 5;
      
      entries = (SimpleDataStruct_Test_Y*)ctorO_ObjectArrayJc((newObj2_1 = alloc_ObjectJc( sizeof(ObjectArrayJc) + (maxQueue) * sizeof(SimpleDataStruct_Test_s), mIsLargeSize_objectIdentSize_ObjectJc, _thCxt)), maxQueue, sizeof(SimpleDataStruct_Test_s),&reflection_SimpleDataStruct_Test_s, 0);
      { int32 idxEntry; 
        for(idxEntry = 0; idxEntry < entries->head.length; idxEntry++)
          { 
            
            //J2C: constructor for embedded element-MemC
            ctorM_SimpleDataStruct_Test(/*static*/build_MemC(&entries->data[idxEntry], sizeof(entries->data[idxEntry])), _thCxt);
          }
      }
      ythis->dataArrayRef = entries;
      activateGarbageCollectorAccess_BlockHeapJc(newObj2_1, null);
    }
    { STACKTRC_LEAVE;
      return ythis->simpleInt;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 access_i_TestAllConcepts_Test(TestAllConcepts_Test_s* ythis, int32 x, ThCxt* _thCxt)
{ Mtbl_TestAllConcepts_Test const* mtbl = (Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestAllConcepts_Test);
  return mtbl->access_i(ythis, x, _thCxt);
}


/**This method shows some calls of interface methods, see {@link org.vishia.java2C.Docu.SuperClassesAndInterfaces#callingOverrideableMethods()}.*/
int32 checkSomeDynamicCalls_TestAllConcepts_Test_F(TestAllConcepts_Test_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("checkSomeDynamicCalls_TestAllConcepts_Test_F");
  
  { 
    int32 a = 0; 
    struct IfcToTest_t* ifc3; 
    ImplIfcTest_s stackInstance = { 0 };   /*A stack instance, data in stack. */
    
    
    /*no initvalue*/
    ifc3 = & ((ythis->implifc).base.IfcToTest);
    ((Mtbl_IfcToTest const*)getMtbl_ObjectJc(&(ifc3)->base.object, sign_Mtbl_IfcToTest) )->processIfcMethod(&((ifc3)->base.object), 5, _thCxt);
    /**Because the instance implifc is embedded and their type is known hence,*/
    a = processIfcMethod_i_ImplIfcTest_F(&((& ((ythis->implifc).base.IfcToTest))->base.object), 456, _thCxt);
    
    //J2C: constructor for embedded element-ObjectJc
    init_ObjectJc(&(stackInstance.base.object), sizeof(stackInstance), 0); 
    ctorO_ImplIfcTest(/*static*/&(stackInstance.base.object), 45, _thCxt);
    /**Because the stackInstance is embedded and their type is known hence,*/
    a += processIfcMethod_i_ImplIfcTest_F(&((& ((stackInstance).base.IfcToTest))->base.object), 678, _thCxt);//TODO, fails yet: processIfcMethod(4);
    
    /**call of a method with a class reference: */
    ((Mtbl_IfcToTest const*)getMtbl_ObjectJc(&(REFJc(ythis->ifc))->base.object, sign_Mtbl_IfcToTest) )->processIfcMethod(&((REFJc(ythis->ifc))->base.object), 56, _thCxt);
    { STACKTRC_LEAVE;
      return a;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 checkSomeDynamicCalls_TestAllConcepts_Test(TestAllConcepts_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestAllConcepts_Test const* mtbl = (Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestAllConcepts_Test);
  return mtbl->checkSomeDynamicCalls(ythis, _thCxt);
}


/**Example to show concatenated calls in a simple variant*/
int32 checkConcatenationSimple_TestAllConcepts_Test(TestAllConcepts_Test_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("checkConcatenationSimple_TestAllConcepts_Test");
  
  { 
    int32 a = 234; 
    
    struct AnyClass_Test_t* _temp1_1; struct ImplIfcTest_t* _temp1_2; struct AnyClass_Test_t* _temp1_3; //J2C: temporary references for concatenation
    
    a = 234 + 
      ( _temp1_1= returnAnyInstance_ImplIfcTest(& (ythis->implifc), _thCxt)
      , _temp1_2= returnRef_AnyClass_Test(_temp1_1, _thCxt)
      , _temp1_3= returnAnyInstance_ImplIfcTest(_temp1_2, _thCxt)
      , addValue_AnyClass_Test(_temp1_3, 24, _thCxt)
      ) + 27;
    
    { 
      struct AnyClass_Test_t* _temp2_1; struct ImplIfcTest_t* _temp2_2; //J2C: temporary references for concatenation
      
      /**This line is a test whether a mix of return this and return association works. See Java- and C-code.*/
      a += 
        ( _temp2_1= returnAnyInstance_ImplIfcTest(& (ythis->implifc), _thCxt)
        , returnThis_AnyClass_Test(_temp2_1, 56, _thCxt)
        , _temp2_2= returnRef_AnyClass_Test(_temp2_1, _thCxt)
        , testImplIfc_ImplIfcTest(_temp2_2, _thCxt)
        );
    }
    { STACKTRC_LEAVE;
      return a;
    }
  }
  STACKTRC_LEAVE;
}


/**Example to show concatenated calls of override-able methods*/
int32 checkConcatenationDynamicCall_TestAllConcepts_Test_F(TestAllConcepts_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestAllConcepts_Test const* mtthis = (Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestAllConcepts_Test);
  
  STACKTRC_TENTRY("checkConcatenationDynamicCall_TestAllConcepts_Test_F");
  
  { 
    int32 a = 0;   /*Checks how return-this-methods of the own class can concatenated: */
    AnyClass_TestMTB anyRef2;   /*This reference is build in stack because it contains the method-table-reference too: */
    
    struct AnyClass_Test_t* _temp1_1; struct ImplIfcTest_t* _temp1_2; struct AnyClass_Test_t* _temp1_3; //J2C: temporary references for concatenation
    
    /*no initvalue*/
    a = 234 + 
      ( _temp1_1= ((Mtbl_ImplIfcTest const*)getMtbl_ObjectJc(&(REFJc(ythis->implifc2))->base.object, sign_Mtbl_ImplIfcTest) )->returnAnyInstanceOverrideable(REFJc(ythis->implifc2), _thCxt)
      , _temp1_2= ((Mtbl_AnyClass_Test const*)getMtbl_ObjectJc(&(_temp1_1)->base.object, sign_Mtbl_AnyClass_Test) )->returnRefOverrideable(_temp1_1, _thCxt)
      , _temp1_3= ((Mtbl_ImplIfcTest const*)getMtbl_ObjectJc(&(_temp1_2)->base.object, sign_Mtbl_ImplIfcTest) )->returnAnyInstanceOverrideable(_temp1_2, _thCxt)
      , ((Mtbl_AnyClass_Test const*)getMtbl_ObjectJc(&(_temp1_3)->base.object, sign_Mtbl_AnyClass_Test) )->addValueOverrideable(_temp1_3, 24, _thCxt)
      ) + 27;
    a += 
      ( mtthis->returnThisOverrideable_Test(ythis, 34)
      , mtthis->returnThisOverrideable_Test(ythis, 45)
      , mtthis->access_i(ythis, 56, _thCxt)
      );
    SETMTBJc(anyRef2, REFJc(ythis->anyRef), AnyClass_Test);
    a += 
      ( anyRef2.mtbl->returnThisOverrideable( (anyRef2.ref), 45, _thCxt)
      , anyRef2.mtbl->returnThisOverrideable( (anyRef2.ref), 234, _thCxt)
      , anyRef2.mtbl->addValueOverrideable( (anyRef2.ref), 67, _thCxt)
      );
    /**Oposite: don't use the stacl-local reference, but the class variable, it isn't optimized in C, but able to run: */
    a += 
      ( ((Mtbl_AnyClass_Test const*)getMtbl_ObjectJc(&(REFJc(ythis->anyRef))->base.object, sign_Mtbl_AnyClass_Test) )->returnThisOverrideable(REFJc(ythis->anyRef), 345, _thCxt)
      , ((Mtbl_AnyClass_Test const*)getMtbl_ObjectJc(&(REFJc(ythis->anyRef))->base.object, sign_Mtbl_AnyClass_Test) )->returnThisOverrideable(REFJc(ythis->anyRef), 3234, _thCxt)
      , ((Mtbl_AnyClass_Test const*)getMtbl_ObjectJc(&(REFJc(ythis->anyRef))->base.object, sign_Mtbl_AnyClass_Test) )->addValueOverrideable(REFJc(ythis->anyRef), 367, _thCxt)
      );
    { STACKTRC_LEAVE;
      return a;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 checkConcatenationDynamicCall_TestAllConcepts_Test(TestAllConcepts_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestAllConcepts_Test const* mtbl = (Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestAllConcepts_Test);
  return mtbl->checkConcatenationDynamicCall(ythis, _thCxt);
}


/**Example to test dynamic and static calls to methods, which are methods of the base class.*/
int32 checkConcatenationDynamicCallToBaseMethods_TestAllConcepts_Test_F(TestAllConcepts_Test_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("checkConcatenationDynamicCallToBaseMethods_TestAllConcepts_Test_F");
  
  { 
    int32 a = 5; 
    
    
    a = 5;
    a = 
      ( returnThisOverrideable_ImplIfcTest_F(& (ythis->implifc), 34, _thCxt)
      , returnThisOverrideable_ImplIfcTest_F(& (ythis->implifc), 56, _thCxt)
      , processIfcMethod_i_ImplIfcTest_F(&((& ((ythis->implifc).base.IfcToTest))->base.object), 44, _thCxt)
      );
    { STACKTRC_LEAVE;
      return a;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 checkConcatenationDynamicCallToBaseMethods_TestAllConcepts_Test(TestAllConcepts_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestAllConcepts_Test const* mtbl = (Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestAllConcepts_Test);
  return mtbl->checkConcatenationDynamicCallToBaseMethods(ythis, _thCxt);
}


/**Example to show concatenated calls with the special kind: The methods returns this itself.*/
int32 checkConcatCallReturnThisTypefixNonVirtual_TestAllConcepts_Test_F(TestAllConcepts_Test_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("checkConcatCallReturnThisTypefixNonVirtual_TestAllConcepts_Test_F");
  
  { 
    int32 a = 0; 
    
    
    /*no initvalue*/
    a = 
      ( returnThisOverrideable_ImplIfcTest_F(& (ythis->implifc), 34, _thCxt)
      , returnThisOverrideable_ImplIfcTest_F(& (ythis->implifc), 56, _thCxt)
      , processIfcMethod_i_ImplIfcTest_F(&((& ((ythis->implifc).base.IfcToTest))->base.object), 44, _thCxt)
      );
    { STACKTRC_LEAVE;
      return a;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 checkConcatCallReturnThisTypefixNonVirtual_TestAllConcepts_Test(TestAllConcepts_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestAllConcepts_Test const* mtbl = (Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestAllConcepts_Test);
  return mtbl->checkConcatCallReturnThisTypefixNonVirtual(ythis, _thCxt);
}

int32 checkConcatCallReturnAnything_TestAllConcepts_Test_F(TestAllConcepts_Test_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("checkConcatCallReturnAnything_TestAllConcepts_Test_F");
  
  { 
    int32 a = 0; 
    
    
    a = 0;
    { STACKTRC_LEAVE;
      return a;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 checkConcatCallReturnAnything_TestAllConcepts_Test(TestAllConcepts_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestAllConcepts_Test const* mtbl = (Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestAllConcepts_Test);
  return mtbl->checkConcatCallReturnAnything(ythis, _thCxt);
}


/**This method helps to test concatenations with return-this, but override-able.*/
struct TestAllConcepts_Test_t* returnThisOverrideable_Test_TestAllConcepts_Test_F(TestAllConcepts_Test_s* ythis, int32 value)
{ 
  
  { 
    
    ythis->simpleInt += value;
    
      return ythis;
  }
}

/*J2C: dynamic call variant of the override-able method: */
struct TestAllConcepts_Test_t* returnThisOverrideable_Test_TestAllConcepts_Test(TestAllConcepts_Test_s* ythis, int32 value)
{ Mtbl_TestAllConcepts_Test const* mtbl = (Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestAllConcepts_Test);
  return mtbl->returnThisOverrideable_Test(ythis, value);
}


/**Example for a non-dynamic call of an interface referenced method.*/
void checkNonVirtual_TestAllConcepts_Test_F(TestAllConcepts_Test_s* ythis)
{ 
  STACKTRC_ENTRY("checkNonVirtual_TestAllConcepts_Test_F");
  
  { 
    
    /**This method should not use a dynamic call in C, because the reference is marked with the instanceType. */
    processIfcMethod_i_ImplIfcTest_F(&((REFJc(ythis->ifcNonVirtual))->base.object), 23, _thCxt);
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void checkNonVirtual_TestAllConcepts_Test(TestAllConcepts_Test_s* ythis)
{ Mtbl_TestAllConcepts_Test const* mtbl = (Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestAllConcepts_Test);
  mtbl->checkNonVirtual(ythis);
}


/**Check whether Object.equals() will be overridden.*/
bool equals_O_TestAllConcepts_Test_F(ObjectJc* ithis, struct ObjectJc_t* cmp, ThCxt* _thCxt)
{ TestAllConcepts_Test_s* ythis = (TestAllConcepts_Test_s*)ithis;
  
  STACKTRC_TENTRY("equals_O_TestAllConcepts_Test_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool equals_O_TestAllConcepts_Test(ObjectJc* ithis, struct ObjectJc_t* cmp, ThCxt* _thCxt)
{ Mtbl_ObjectJc const* mtbl = (Mtbl_ObjectJc const*)getMtbl_ObjectJc(ithis, sign_Mtbl_ObjectJc);
  return mtbl->equals(ithis, cmp, _thCxt);
}


/**This method doesn't override Object.equals. */
bool equals_S_TestAllConcepts_Test_F(TestAllConcepts_Test_s* ythis, StringJc cmp, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("equals_S_TestAllConcepts_Test_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool equals_S_TestAllConcepts_Test(TestAllConcepts_Test_s* ythis, StringJc cmp, ThCxt* _thCxt)
{ Mtbl_TestAllConcepts_Test const* mtbl = (Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestAllConcepts_Test);
  return mtbl->equals_S(ythis, cmp, _thCxt);
}


/**A method with same name but other parameter types.*/
void access_f_TestAllConcepts_Test_F(TestAllConcepts_Test_s* ythis, float x, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("access_f_TestAllConcepts_Test_F");
  
  { 
    
    
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void access_f_TestAllConcepts_Test(TestAllConcepts_Test_s* ythis, float x, ThCxt* _thCxt)
{ Mtbl_TestAllConcepts_Test const* mtbl = (Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestAllConcepts_Test);
  mtbl->access_f(ythis, x, _thCxt);
}

int32 testAccessIfc_TestAllConcepts_Test_F(TestAllConcepts_Test_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("testAccessIfc_TestAllConcepts_Test_F");
  
  { 
    int32 val = 0; 
    struct IfcToTest_t* ifc22; 
    
    
    val = 0;
    ifc22 = & ((ythis->implifc).base.IfcToTest);
    if(ifc22 != null) 
    { //:test usage ifc22.ref
      
      
      { int32 ii; 
        for(ii = 0; ii < 1000; ii++)
          { 
            
            val += ((Mtbl_IfcToTest const*)getMtbl_ObjectJc(&(ifc22)->base.object, sign_Mtbl_IfcToTest) )->processIfcMethod(&((ifc22)->base.object), 5, _thCxt);//use it for dynamic call, in C too.
            
          }
      }
    }
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 testAccessIfc_TestAllConcepts_Test(TestAllConcepts_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestAllConcepts_Test const* mtbl = (Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestAllConcepts_Test);
  return mtbl->testAccessIfc(ythis, _thCxt);
}

int32 testAccessIfcMtbl_TestAllConcepts_Test_F(TestAllConcepts_Test_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("testAccessIfcMtbl_TestAllConcepts_Test_F");
  
  { 
    int32 val; 
    
    
    val = ((Mtbl_IfcToTest const*)getMtbl_ObjectJc(&(REFJc(ythis->ifc))->base.object, sign_Mtbl_IfcToTest) )->processIfcMethod(&((REFJc(ythis->ifc))->base.object), 5, _thCxt);
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 testAccessIfcMtbl_TestAllConcepts_Test(TestAllConcepts_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestAllConcepts_Test const* mtbl = (Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestAllConcepts_Test);
  return mtbl->testAccessIfcMtbl(ythis, _thCxt);
}

int32 testAccessIfcMtbl2_TestAllConcepts_Test_F(TestAllConcepts_Test_s* ythis, bool bTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("testAccessIfcMtbl2_TestAllConcepts_Test_F");
  
  { 
    int32 val = 0; 
    struct IfcToTest_t* ifcCall; 
    
    
    /*no initvalue*/
    if(bTest) 
    { 
      
      SETREFJc(ythis->ifc2, & ((* (REFJc(ythis->implifc2))).base.IfcToTest), IfcToTest_s);
    }
    else 
    { 
      
      SETREFJc(ythis->ifc2, & ((ythis->implifc).base.IfcToTest), IfcToTest_s);
    }
    ifcCall = REFJc(ythis->ifc2);
    val = ((Mtbl_IfcToTest const*)getMtbl_ObjectJc(&(ifcCall)->base.object, sign_Mtbl_IfcToTest) )->processIfcMethod(&((ifcCall)->base.object), 6, _thCxt);
    val += ((Mtbl_IfcToTest const*)getMtbl_ObjectJc(&(REFJc(ythis->ifc2))->base.object, sign_Mtbl_IfcToTest) )->processIfcMethod(&((REFJc(ythis->ifc2))->base.object), 5, _thCxt);
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 testAccessIfcMtbl2_TestAllConcepts_Test(TestAllConcepts_Test_s* ythis, bool bTest, ThCxt* _thCxt)
{ Mtbl_TestAllConcepts_Test const* mtbl = (Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestAllConcepts_Test);
  return mtbl->testAccessIfcMtbl2(ythis, bTest, _thCxt);
}


/**Example to check how an dynamic call of own methods is implemented in C.*/
void testInternalDynCall_TestAllConcepts_Test(TestAllConcepts_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestAllConcepts_Test const* mtthis = (Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestAllConcepts_Test);
  
  STACKTRC_TENTRY("testInternalDynCall_TestAllConcepts_Test");
  
  { 
    bool cond = true; 
    
    
    cond = true;
    mtthis->testAccessIfcMtbl(ythis, _thCxt);
    if(cond) 
    { 
      
      mtthis->testAccessIfcMtbl(ythis, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/****/
void main_TestAllConcepts_Test_F(TestAllConcepts_Test_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("main_TestAllConcepts_Test_F");
  
  { 
    int32 ret = 0; 
    struct TestAllConcepts_Test_t* main; 
    struct TestgarbageCollector_Test_t* testGc = null; 
    struct TestContainer_Test_t* testContainer = null; 
    
    ObjectJc *newObj1_1=null, *newObj1_2=null; //J2C: temporary Objects for new operations
    
    ret = 0;
    main = ythis;
    
    testGc = ctorO_TestgarbageCollector_Test(/*static*/(newObj1_1 = alloc_ObjectJc(sizeof_TestgarbageCollector_Test_s, 0, _thCxt)), _thCxt);
    test_TestAnonymous_Test_F(& (ythis->testAnonymous), _thCxt);
    test_TestgarbageCollector_Test_F(testGc, _thCxt);
    testInternalDynCall_TestAllConcepts_Test(main, _thCxt);
    checkConcatenationSimple_TestAllConcepts_Test(main, _thCxt);
    ((Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&(main)->base.object, sign_Mtbl_TestAllConcepts_Test) )->checkConcatenationDynamicCall(main, _thCxt);//main.checkConcatCallReturnThisTypefixNonVirtual();
    
    ((Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&(main)->base.object, sign_Mtbl_TestAllConcepts_Test) )->access_i(main, 234, _thCxt);
    testStringProcessing_TestString_Test_F(& (main->testString), _thCxt);
    test_TestStringFormatter_Test_F(& (main->testStringFormatter), _thCxt);
    /**Method from a super class which is only defined there. but called final. */
    testImplIfc_ImplIfcTest(& ((ythis->extendsImpl).base.super), _thCxt);//TODO dynCall of baseclass method faulty. processIfcMethod(234);
    
    ret += ((Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&(main)->base.object, sign_Mtbl_TestAllConcepts_Test) )->checkSomeDynamicCalls(main, _thCxt);
    ret += ((Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&(main)->base.object, sign_Mtbl_TestAllConcepts_Test) )->testAccessIfc(main, _thCxt);
    ret += ((Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&(main)->base.object, sign_Mtbl_TestAllConcepts_Test) )->testAccessIfcMtbl(main, _thCxt);
    ret += ((Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&(main)->base.object, sign_Mtbl_TestAllConcepts_Test) )->testAccessIfcMtbl2(main, true, _thCxt);
    
    testContainer = ctorO_TestContainer_Test(/*static*/(newObj1_2 = alloc_ObjectJc(sizeof_TestContainer_Test_s, 0, _thCxt)), _thCxt);
    test_TestContainer_Test_F(testContainer, _thCxt);
    /**Start a two threads: */
    start_TestWaitNotify_Test_F(& (ythis->testWaitNotify), _thCxt);
    start_TestThread_Test_F(& (ythis->testThread), _thCxt);
    otherThreadRoutine_TestThread_Test_F(& (ythis->testThread), _thCxt);
    ythis->testWaitNotify.shouldRun = false;
    TRY
    { 
      
      sleep_ThreadJc(/*static*/2000, _thCxt);
    }_TRY
    CATCH(InterruptedException, e)
    
      { 
        
        
      }
    END_TRY
    println_z_PrintStreamJc(REFJc(out_SystemJc), "main finished.", _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(newObj1_1, null);
    activateGarbageCollectorAccess_BlockHeapJc(newObj1_2, null);
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void main_TestAllConcepts_Test(TestAllConcepts_Test_s* ythis, ThCxt* _thCxt)
{ Mtbl_TestAllConcepts_Test const* mtbl = (Mtbl_TestAllConcepts_Test const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_TestAllConcepts_Test);
  mtbl->main(ythis, _thCxt);
}

void main_SY_TestAllConcepts_Test(/*static*/ StringJc_Y* args, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("main_SY_TestAllConcepts_Test");
  
  { //:MsgDispatcher msgDispatcher = new MsgDispatcher(10,100,100,8);
    
    struct LogMessageFile_MSG_t* msgOutputFile = null; 
    struct TestAllConcepts_Test_t* main1 = null; 
    
    ObjectJc *newObj1_1=null, *newObj1_2=null; //J2C: temporary Objects for new operations
    
    
    msgOutputFile = ctorO_LogMessageFile_MSG(/*static*/(newObj1_1 = alloc_ObjectJc(sizeof_LogMessageFile_MSG_s, 0, _thCxt)), s0_StringJc("log/gc$MMMdd-hhmmssS$.log"), 0, 0, null, null, null, _thCxt);
    
    main1 = ctorO_TestAllConcepts_Test(/*static*/(newObj1_2 = alloc_ObjectJc(sizeof_TestAllConcepts_Test_s, 0, _thCxt)), _thCxt);
    setRunModeAll_BlockHeapJc(/*static*/_thCxt);
    setLogMessageOutput_BlockHeapJc(/*static*/& ((* (msgOutputFile)).base.LogMessageFW), kMsgBlockHeap_TestAllConcepts_Test, _thCxt);//main1.processIfcMethod(234);
    
    main_TestAllConcepts_Test_F(main1, _thCxt);
    gc_SystemJc(/*static*/_thCxt);
    finalize_TestAllConcepts_Test_F(& ((* (main1)).base.object), _thCxt);//it isn't need anymore, but the gc hasn't freed it because it is in use still.
    
    main1 = null;
    gc_SystemJc(/*static*/_thCxt);
    close_LogMessageFile_MSG_F(& ((* (msgOutputFile)).base.LogMessageFW), _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(newObj1_1, null);
    activateGarbageCollectorAccess_BlockHeapJc(newObj1_2, null);
  }
  STACKTRC_LEAVE;
}


void finalize_TestAllConcepts_Test_F(ObjectJc* othis, ThCxt* _thCxt)
{ TestAllConcepts_Test_s* ythis = (TestAllConcepts_Test_s*)othis;  //upcasting to the real class.
 STACKTRC_TENTRY("finalize_TestAllConcepts_Test_F");

  { 
    
    println_z_PrintStreamJc(REFJc(out_SystemJc), "finalize", _thCxt);
  }  finalize_ObjectJc_F(&ythis->testWaitNotifyData.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_TestThread_Test_F(&ythis->testThread.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_TestWaitNotify_Test_F(&ythis->testWaitNotify.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ObjectJc_F(&ythis->stringBufferMain.sb.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_TestString_Test_F(&ythis->testString.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ObjectJc_F(&ythis->testStringFormatter.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ImplIfcTest_F(&ythis->implifc.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ImplIfcTest_F(&ythis->ifc3.base.object, _thCxt); //J2C: finalizing the embedded instance.
  CLEAR_REFJc(ythis->implifc2);
  CLEAR_REFJc(ythis->ifc);
  CLEAR_REFJc(ythis->ifcNonVirtual);
  CLEAR_REFJc(ythis->ifc2);
  finalize_ImplIfcTest_F(&ythis->extendsImpl.base.object, _thCxt); //J2C: finalizing the embedded instance.
  CLEAR_REFJc(ythis->ifc4);
  CLEAR_REFJc(ythis->anyRef);
  finalize_TestAnonymous_Test_F(&ythis->testAnonymous.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ObjectJc_F(&ythis->base.object, _thCxt); //J2C: finalizing the superclass.
  STACKTRC_LEAVE;
}




/**J2C: Reflections and Method-table *************************************************/
const MtblDef_TestAllConcepts_Test mtblTestAllConcepts_Test = {
{ { sign_Mtbl_TestAllConcepts_Test//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((14 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, access_i_TestAllConcepts_Test_F //access_i
, checkSomeDynamicCalls_TestAllConcepts_Test_F //checkSomeDynamicCalls
, checkConcatenationDynamicCall_TestAllConcepts_Test_F //checkConcatenationDynamicCall
, checkConcatenationDynamicCallToBaseMethods_TestAllConcepts_Test_F //checkConcatenationDynamicCallToBaseMethods
, checkConcatCallReturnThisTypefixNonVirtual_TestAllConcepts_Test_F //checkConcatCallReturnThisTypefixNonVirtual
, checkConcatCallReturnAnything_TestAllConcepts_Test_F //checkConcatCallReturnAnything
, returnThisOverrideable_Test_TestAllConcepts_Test_F //returnThisOverrideable_Test
, checkNonVirtual_TestAllConcepts_Test_F //checkNonVirtual
, equals_S_TestAllConcepts_Test_F //equals_S
, access_f_TestAllConcepts_Test_F //access_f
, testAccessIfc_TestAllConcepts_Test_F //testAccessIfc
, testAccessIfcMtbl_TestAllConcepts_Test_F //testAccessIfcMtbl
, testAccessIfcMtbl2_TestAllConcepts_Test_F //testAccessIfcMtbl2
, main_TestAllConcepts_Test_F //main
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_O_TestAllConcepts_Test_F //equals
  , finalize_TestAllConcepts_Test_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_TestAllConcepts_Test_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_TestAllConcepts_Test_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_TestAllConcepts_Test, ObjectJc) }
   }
 };

extern struct ClassJc_t const reflection_TestAllConcepts_Test_s;
extern struct ClassJc_t const reflection_AnyClass_Test_s;
extern struct ClassJc_t const reflection_ExpandedDataStruct_Test_s;
extern struct ClassJc_t const reflection_ExtendsImpl_Test_s;
extern struct ClassJc_t const reflection_IfcToTest_s;
extern struct ClassJc_t const reflection_ImplIfcTest_s;
extern struct ClassJc_t const reflection_SimpleDataStruct_Test_s;
extern struct ClassJc_t const reflection_StringBuilderJc;
extern struct ClassJc_t const reflection_TestAnonymous_Test_s;
extern struct ClassJc_t const reflection_TestStringFormatter_Test_s;
extern struct ClassJc_t const reflection_TestString_Test_s;
extern struct ClassJc_t const reflection_TestThread_Test_s;
extern struct ClassJc_t const reflection_TestWaitNotify_Test_s;
extern struct ClassJc_t const reflection_WaitNotifyData_TestWaitNotify_Test_s;
const struct Reflection_Fields_TestAllConcepts_Test_s_t
{ ObjectArrayJc head; FieldJc data[35];
} reflection_Fields_TestAllConcepts_Test_s =
{ CONST_ObjectArrayJc(FieldJc, 35, OBJTYPE_FieldJc, null, &reflection_Fields_TestAllConcepts_Test_s)
, {
     { "simpleInt"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->simpleInt) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "embeddedData"
    , 0 //nrofArrayElements
    , &reflection_SimpleDataStruct_Test_s
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->embeddedData) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "embeddedDataNotEnpand"
    , 0 //nrofArrayElements
    , &reflection_SimpleDataStruct_Test_s
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->embeddedDataNotEnpand) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "embeddedDataExpand"
    , 0 //nrofArrayElements
    , &reflection_ExpandedDataStruct_Test_s
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->embeddedDataExpand) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "testWaitNotifyData"
    , 0 //nrofArrayElements
    , &reflection_WaitNotifyData_TestWaitNotify_Test_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->testWaitNotifyData) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "testThread"
    , 0 //nrofArrayElements
    , &reflection_TestThread_Test_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->testThread) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "testWaitNotify"
    , 0 //nrofArrayElements
    , &reflection_TestWaitNotify_Test_s
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->testWaitNotify) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "stringBufferMain"
    , 0 //nrofArrayElements
    , &reflection_StringBuilderJc
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->stringBufferMain) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "testString"
    , 0 //nrofArrayElements
    , &reflection_TestString_Test_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->testString) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "testStringFormatter"
    , 0 //nrofArrayElements
    , &reflection_TestStringFormatter_Test_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->testStringFormatter) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "intArray"
    , 1000 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc |kStaticArray_Modifier_reflectJc |kEmbeddedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->intArray) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "intArrayRef"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc |kObjectArrayJc_Modifier_reflectJc |kReferencedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->intArrayRef) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "intArrayRef2"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc |kObjectArrayJc_Modifier_reflectJc |kReferencedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->intArrayRef2) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "intArraySimple"
    , 1000 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc |kStaticArray_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->intArraySimple) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "intArrayRefSimple"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc |kObjectArrayJc_Modifier_reflectJc |kReferencedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->intArrayRefSimple) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "dataArrayRef"
    , 0 //nrofArrayElements
    , &reflection_SimpleDataStruct_Test_s
    , kEmbedded_Modifier_reflectJc |kObjectArrayJc_Modifier_reflectJc |kReferencedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->dataArrayRef) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "dataArrayEmbedded"
    , 12 //nrofArrayElements
    , &reflection_SimpleDataStruct_Test_s
    , kEmbedded_Modifier_reflectJc |kStaticArray_Modifier_reflectJc |kEmbeddedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->dataArrayEmbedded) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "dataArraySimpleEmbedded"
    , 12 //nrofArrayElements
    , &reflection_SimpleDataStruct_Test_s
    , kEmbedded_Modifier_reflectJc |kStaticArray_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->dataArraySimpleEmbedded) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "dataRefArrayEmbedded"
    , 12 //nrofArrayElements
    , &reflection_SimpleDataStruct_Test_s
    , kEmbedded_Modifier_reflectJc |kStaticArray_Modifier_reflectJc |kEmbeddedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->dataRefArrayEmbedded) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "dataRefArray"
    , 12 //nrofArrayElements
    , &reflection_SimpleDataStruct_Test_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ |kStaticArray_Modifier_reflectJc |kEmbeddedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->dataRefArray) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "dataAssociatedEmbeddedArray"
    , 0 //nrofArrayElements
    , &reflection_SimpleDataStruct_Test_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ |kObjectArrayJc_Modifier_reflectJc |kReferencedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->dataAssociatedEmbeddedArray) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "dataAssociatedRefArray"
    , 0 //nrofArrayElements
    , &reflection_SimpleDataStruct_Test_s
    , kEmbedded_Modifier_reflectJc |kObjectArrayJc_Modifier_reflectJc |kReferencedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->dataAssociatedRefArray) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "implifc"
    , 0 //nrofArrayElements
    , &reflection_ImplIfcTest_s
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->implifc) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "ifc3"
    , 0 //nrofArrayElements
    , &reflection_ImplIfcTest_s
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->ifc3) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "implifc2"
    , 0 //nrofArrayElements
    , &reflection_ImplIfcTest_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->implifc2) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "ifc"
    , 0 //nrofArrayElements
    , &reflection_IfcToTest_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->ifc) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "ifcNonVirtual"
    , 0 //nrofArrayElements
    , &reflection_IfcToTest_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->ifcNonVirtual) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "ifc2"
    , 0 //nrofArrayElements
    , &reflection_IfcToTest_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->ifc2) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "extendsImpl"
    , 0 //nrofArrayElements
    , &reflection_ExtendsImpl_Test_s
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->extendsImpl) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "ifc4"
    , 0 //nrofArrayElements
    , &reflection_ImplIfcTest_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->ifc4) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "anyRef"
    , 0 //nrofArrayElements
    , &reflection_AnyClass_Test_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->anyRef) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "testAnonymous"
    , 0 //nrofArrayElements
    , &reflection_TestAnonymous_Test_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestAllConcepts_Test_s*)(0x1000))->testAnonymous) - (int32)(TestAllConcepts_Test_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestAllConcepts_Test_s
    }
   , { "kCharConst"
    , 0 //nrofArrayElements
    , REFLECTION_char
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&kCharConst_TestAllConcepts_Test) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&kCharConst_TestAllConcepts_Test)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_TestAllConcepts_Test_s
    }
   , { "nrofInstances"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&nrofInstances_TestAllConcepts_Test) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&nrofInstances_TestAllConcepts_Test)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_TestAllConcepts_Test_s
    }
   , { "intArrayStaticConst"
    , 3 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc |kStaticArray_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&intArrayStaticConst_TestAllConcepts_Test) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&intArrayStaticConst_TestAllConcepts_Test)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_TestAllConcepts_Test_s
    }
} };
const ClassJc reflection_TestAllConcepts_Test_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "TestAllConcepts_Test_s"
,  0 //position of ObjectJc
, sizeof(TestAllConcepts_Test_s)
, (FieldJcArray const*)&reflection_Fields_TestAllConcepts_Test_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_TestAllConcepts_Test_s //superclass
, null //interfaces
, 0    //modifiers
, &mtblTestAllConcepts_Test.mtbl.head
};
