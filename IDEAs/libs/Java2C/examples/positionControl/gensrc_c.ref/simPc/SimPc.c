/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "simPc/SimPc.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "BlockHeap/BlockHeapJc.h"  //reference-association: BlockHeapJc
#include "Jc/FileIoJc.h"  //reference-association: out
#include "Jc/MathJc.h"  //reference-association: MathJc_s
#include "Jc/SystemJc.h"  //reference-association: SystemJc
#include "Jc/ThreadJc.h"  //reference-association: ThreadJc_s
#include "PosCtrl/MainController.h"  //new object


/* J2C: Method-table-references *********************************************************/
#ifndef WayActuatorMTBDEF
  #define WayActuatorMTBDEF
  typedef struct WayActuatorMTB_t { struct Mtbl_WayActuator_t const* mtbl; struct WayActuator_t* ref; } WayActuatorMTB;
#endif

#ifndef WaySensorMTBDEF
  #define WaySensorMTBDEF
  typedef struct WaySensorMTB_t { struct Mtbl_WaySensor_t const* mtbl; struct WaySensor_t* ref; } WaySensorMTB;
#endif


/*** @author Hartmut
*
*/


const char sign_Mtbl_SimPc[] = "SimPc"; //to mark method tables of all implementations

typedef struct MtblDef_SimPc_t { Mtbl_SimPc mtbl; MtblHeadJc end; } MtblDef_SimPc;
 extern MtblDef_SimPc const mtblSimPc;

/*Constructor */
struct SimPc_t* ctorO_SimPc(ObjectJc* othis, ThCxt* _thCxt)
{ SimPc_s* ythis = (SimPc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_SimPc");
  checkConsistence_ObjectJc(othis, sizeof(SimPc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_SimPc_s, sizeof(SimPc_s));  
  //j2c: Initialize all class variables:
  {ObjectJc *newObj0_1=null; //J2C: temporary Objects for new operations
      
    ythis->bRun = true;
    ythis->disturbance1 = 1.0;
    ythis->time = 0;
    ythis->samplingInverval = 100;
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->oamWriter.base.object), sizeof(ythis->oamWriter), 0); 
      ctorO_SendActValues(/*static*/&(ythis->oamWriter.base.object), _thCxt);
    SETREFJc(ythis->waitThreadOrganizer, ctorO_WaitThread_SimPc(ythis, (newObj0_1 = alloc_ObjectJc(sizeof_WaitThread_SimPc_s, 0, _thCxt)), _thCxt), WaitThread_SimPc_s);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->waySensor1.base.object), sizeof(ythis->waySensor1), 0); 
      ctorO_C_waySensor1_SimPc(ythis, &(ythis->waySensor1.base.object), _thCxt);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->waySensor2.base.object), sizeof(ythis->waySensor2), 0); 
      ctorO_C_waySensor2_SimPc(ythis, &(ythis->waySensor2.base.object), _thCxt);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->wayActuator1.base.object), sizeof(ythis->wayActuator1), 0); 
      ctorO_C_wayActuator1_SimPc(ythis, &(ythis->wayActuator1.base.object), _thCxt);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->wayActuator2.base.object), sizeof(ythis->wayActuator2), 0); 
      ctorO_C_wayActuator2_SimPc(ythis, &(ythis->wayActuator2.base.object), _thCxt);
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->broker2.base.object), sizeof(ythis->broker2), 0); 
      ctorO_C_broker2_SimPc(ythis, &(ythis->broker2.base.object), _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(newObj0_1, null);
  }
  { 
    ObjectJc *newObj1_1=null; //J2C: temporary Objects for new operations
    
    /**instantiation: */
    ythis->mainController = ctorO_MainController(/*static*/(newObj1_1 = alloc_ObjectJc(sizeof_MainController_s, 0, _thCxt)), & ((ythis->broker2).base.iRequireMainController), null, & ((* (REFJc(ythis->waitThreadOrganizer))).base.WaitThreadOrganizer), _thCxt);
    singleton_MainController = ythis->mainController;
    activateGarbageCollectorAccess_BlockHeapJc(newObj1_1, null);
  }
  STACKTRC_LEAVE;
  return ythis;
}



/**This is the run method of the execution. */
void execute_SimPc(SimPc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("execute_SimPc");
  
  { 
    int32 idxTarget = 0; 
    int16 targets[9] = {15000,17000,11000,15000,17000,11000,15000,17000,12000 };   /*Simple example: Some values are given fixed. */
    int32 ii = 0; 
    
    
    ythis->way1 = 1000000;//start at 1 m
    
    ythis->way2 = 1000000;
    idxTarget = 0;
    /*no initvalue*/
    start_SendActValues_F(& (ythis->oamWriter), _thCxt);//opens the socket.
    
    /**Prepare the building of the controller. */
    prepare_MainController(singleton_MainController, _thCxt);
    /**Starts the controller thread. */
    start_MainController(singleton_MainController, _thCxt);
    ii = 0;
    /**This thread is an example for a superior thread over the controller,*/
    do 
      { 
        
        ii++;
        TRY
        { 
          
          sleep_ThreadJc(/*static*/200, _thCxt);
        }_TRY
        CATCH(InterruptedException, exc)
        
          { 
            
            
          }
        END_TRY//it may be also in another thread: set target values:
        
        if(idxTarget < ARRAYLEN(targets)) 
        { 
          
          /**try to set a new target position*/
          if(setTarget_MainController(singleton_MainController, targets[idxTarget], _thCxt)) 
          { 
            
            /**increment it, only if it was successful. */
            idxTarget += 1;
            if(idxTarget >= ARRAYLEN(targets)) 
            { 
              
              idxTarget = 0;
            }
          }
        }
        /**Call of the garbage collector in the loop of this thread,*/
        
        { 
          int32 catastropicalCount = 10000; 
          int32 success = 0; 
          
          
          catastropicalCount = 10000;
          /*no initvalue*/
          do 
            { 
              
              /**One call handles only 1 block with its cluster. */
              success = ((/*J2C:cast% from void*/int32)(garbageCollection_BlockHeapJc(/*static*/false, _thCxt)));
            }while(success != checkGcFinished_BlockHeapJc && --catastropicalCount >= 0);
        }
      }while(ythis->bRun);
    println_z_PrintStreamJc(REFJc(out_SystemJc), "finish", _thCxt);
  }
  STACKTRC_LEAVE;
}


/**The step routine to build the simulation environment values.*/
void step_SimPc(SimPc_s* ythis, ThCxt* _thCxt)
{ Mtbl_SimPc const* mtthis = (Mtbl_SimPc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_SimPc);
  
  STACKTRC_TENTRY("step_SimPc");
  
  { 
    
    ythis->time += 1;
    if(ythis->time == 551) mtthis->stop(ythis, _thCxt);
    /*the amplification of the actuator-motor is disturbed, it is between 0.4 and 1.4*/
    ythis->disturbance1 = 0.9 + 0.5 * sin_MathJc(/*static*/((double)(ythis->time % 1000)) / 1000 * 2 * 3.1456);//todo Math.PI);
    
    ythis->way1 += 100.0 * ((double)(ythis->voltage1)) / ythis->samplingInverval * ythis->disturbance1;
    write_SendActValues_F(& (ythis->oamWriter), & (ythis->mainController->oamVariables), _thCxt);//, mainController.d);
    
  }
  STACKTRC_LEAVE;
}

void stop_SimPc_F(SimPc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("stop_SimPc_F");
  
  { //:debug
    
    
    
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void stop_SimPc(SimPc_s* ythis, ThCxt* _thCxt)
{ Mtbl_SimPc const* mtbl = (Mtbl_SimPc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_SimPc);
  mtbl->stop(ythis, _thCxt);
}


void finalize_SimPc_F(ObjectJc* othis, ThCxt* _thCxt)
{ SimPc_s* ythis = (SimPc_s*)othis;  //upcasting to the real class.
 STACKTRC_TENTRY("finalize_SimPc_F");
  finalize_SendActValues_F(&ythis->oamWriter.base.object, _thCxt); //J2C: finalizing the embedded instance.
  CLEAR_REFJc(ythis->waitThreadOrganizer);
  finalize_ObjectJc_F(&ythis->waySensor1.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ObjectJc_F(&ythis->waySensor2.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ObjectJc_F(&ythis->wayActuator1.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ObjectJc_F(&ythis->wayActuator2.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ObjectJc_F(&ythis->broker2.base.object, _thCxt); //J2C: finalizing the embedded instance.
  finalize_ObjectJc_F(&ythis->base.object, _thCxt); //J2C: finalizing the superclass.
  STACKTRC_LEAVE;
}




/**J2C: Reflections and Method-table *************************************************/
const MtblDef_SimPc mtblSimPc = {
{ { sign_Mtbl_SimPc//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((1 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, stop_SimPc_F //stop
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_SimPc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_SimPc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_SimPc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_SimPc, ObjectJc) }
   }
 };

extern struct ClassJc_t const reflection_SimPc_s;
extern struct ClassJc_t const reflection_C_broker2_SimPc_s;
extern struct ClassJc_t const reflection_C_wayActuator1_SimPc_s;
extern struct ClassJc_t const reflection_C_wayActuator2_SimPc_s;
extern struct ClassJc_t const reflection_C_waySensor1_SimPc_s;
extern struct ClassJc_t const reflection_C_waySensor2_SimPc_s;
extern struct ClassJc_t const reflection_MainController_s;
extern struct ClassJc_t const reflection_SendActValues_s;
extern struct ClassJc_t const reflection_WaitThread_SimPc_s;
const struct Reflection_Fields_SimPc_s_t
{ ObjectArrayJc head; FieldJc data[16];
} reflection_Fields_SimPc_s =
{ CONST_ObjectArrayJc(FieldJc, 16, OBJTYPE_FieldJc, null, &reflection_Fields_SimPc_s)
, {
     { "mainController"
    , 0 //nrofArrayElements
    , &reflection_MainController_s
    , kReference_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((SimPc_s*)(0x1000))->mainController) - (int32)(SimPc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_SimPc_s
    }
   , { "bRun"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((SimPc_s*)(0x1000))->bRun) - (int32)(SimPc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_SimPc_s
    }
   , { "way1"
    , 0 //nrofArrayElements
    , REFLECTION_double
    , 8 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((SimPc_s*)(0x1000))->way1) - (int32)(SimPc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_SimPc_s
    }
   , { "way2"
    , 0 //nrofArrayElements
    , REFLECTION_double
    , 8 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((SimPc_s*)(0x1000))->way2) - (int32)(SimPc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_SimPc_s
    }
   , { "disturbance1"
    , 0 //nrofArrayElements
    , REFLECTION_double
    , 8 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((SimPc_s*)(0x1000))->disturbance1) - (int32)(SimPc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_SimPc_s
    }
   , { "voltage1"
    , 0 //nrofArrayElements
    , REFLECTION_int16
    , 2 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((SimPc_s*)(0x1000))->voltage1) - (int32)(SimPc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_SimPc_s
    }
   , { "voltage2"
    , 0 //nrofArrayElements
    , REFLECTION_int16
    , 2 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((SimPc_s*)(0x1000))->voltage2) - (int32)(SimPc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_SimPc_s
    }
   , { "time"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((SimPc_s*)(0x1000))->time) - (int32)(SimPc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_SimPc_s
    }
   , { "samplingInverval"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((SimPc_s*)(0x1000))->samplingInverval) - (int32)(SimPc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_SimPc_s
    }
   , { "oamWriter"
    , 0 //nrofArrayElements
    , &reflection_SendActValues_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((SimPc_s*)(0x1000))->oamWriter) - (int32)(SimPc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_SimPc_s
    }
   , { "waitThreadOrganizer"
    , 0 //nrofArrayElements
    , &reflection_WaitThread_SimPc_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((SimPc_s*)(0x1000))->waitThreadOrganizer) - (int32)(SimPc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_SimPc_s
    }
   , { "waySensor1"
    , 0 //nrofArrayElements
    , &reflection_C_waySensor1_SimPc_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((SimPc_s*)(0x1000))->waySensor1) - (int32)(SimPc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_SimPc_s
    }
   , { "waySensor2"
    , 0 //nrofArrayElements
    , &reflection_C_waySensor2_SimPc_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((SimPc_s*)(0x1000))->waySensor2) - (int32)(SimPc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_SimPc_s
    }
   , { "wayActuator1"
    , 0 //nrofArrayElements
    , &reflection_C_wayActuator1_SimPc_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((SimPc_s*)(0x1000))->wayActuator1) - (int32)(SimPc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_SimPc_s
    }
   , { "wayActuator2"
    , 0 //nrofArrayElements
    , &reflection_C_wayActuator2_SimPc_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((SimPc_s*)(0x1000))->wayActuator2) - (int32)(SimPc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_SimPc_s
    }
   , { "broker2"
    , 0 //nrofArrayElements
    , &reflection_C_broker2_SimPc_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((SimPc_s*)(0x1000))->broker2) - (int32)(SimPc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_SimPc_s
    }
} };
const ClassJc reflection_SimPc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "SimPc_s"
,  0 //position of ObjectJc
, sizeof(SimPc_s)
, (FieldJcArray const*)&reflection_Fields_SimPc_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_SimPc_s //superclass
, null //interfaces
, 0    //modifiers
, &mtblSimPc.mtbl.head
};

/**Internal agent class to implement the waitCycle()-functionality.
*/


const char sign_Mtbl_WaitThread_SimPc[] = "WaitThread_SimPc"; //to mark method tables of all implementations

typedef struct MtblDef_WaitThread_SimPc_t { Mtbl_WaitThread_SimPc mtbl; MtblHeadJc end; } MtblDef_WaitThread_SimPc;
 extern MtblDef_WaitThread_SimPc const mtblWaitThread_SimPc;

/*Constructor *//**J2C: autogenerated as default constructor. */
struct WaitThread_SimPc_t* ctorO_WaitThread_SimPc(struct SimPc_t* outer, ObjectJc* othis, ThCxt* _thCxt)
{ WaitThread_SimPc_s* ythis = (WaitThread_SimPc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_WaitThread_SimPc");
  checkConsistence_ObjectJc(othis, sizeof(WaitThread_SimPc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_WaitThread_SimPc_s, sizeof(WaitThread_SimPc_s));  
  ythis->outer = outer;
  //j2c: Initialize all class variables:
  {
  }/*J2C:No body for constructor*/

  STACKTRC_LEAVE;
  return ythis;
}


void waitCycle_WaitThread_SimPc_F(ObjectJc* ithis, ThCxt* _thCxt)
{ WaitThread_SimPc_s* ythis = (WaitThread_SimPc_s*)ithis;
  
  STACKTRC_TENTRY("waitCycle_WaitThread_SimPc_F");
  
  { 
    
    step_SimPc((ythis)->outer, _thCxt);//the emulation of environment in main control thread.
    
    /**Wait until cycle, it is a wait/notify from interrupt*/
    TRY
    { 
      
      sleep_ThreadJc(/*static*/20, _thCxt);
    }_TRY
    CATCH(InterruptedException, exc)
    
      { 
        
        
      }
    END_TRY
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void waitCycle_WaitThread_SimPc(ObjectJc* ithis, ThCxt* _thCxt)
{ Mtbl_WaitThreadOrganizer const* mtbl = (Mtbl_WaitThreadOrganizer const*)getMtbl_ObjectJc(ithis, sign_Mtbl_WaitThreadOrganizer);
  mtbl->waitCycle(ithis, _thCxt);
}



/**J2C: Reflections and Method-table *************************************************/
const MtblDef_WaitThread_SimPc mtblWaitThread_SimPc = {
{ { sign_Mtbl_WaitThread_SimPc//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
  /**J2C: Mtbl-interfaces of WaitThread_SimPc: */
, { { sign_Mtbl_WaitThreadOrganizer//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((1 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , waitCycle_WaitThread_SimPc_F //waitCycle
  , { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_ObjectJc_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_ObjectJc_F //toString
    }
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_WaitThread_SimPc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_WaitThread_SimPc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_WaitThread_SimPc, ObjectJc) }
   }
 };

 extern struct ClassJc_t const reflection_WaitThreadOrganizer_s;
 static struct ifcClasses_WaitThread_SimPc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }interfaces_WaitThread_SimPc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
, { {&reflection_WaitThreadOrganizer_s, OFFSET_Mtbl(Mtbl_WaitThread_SimPc, WaitThreadOrganizer) }
  }
};

const ClassJc reflection_WaitThread_SimPc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "WaitThread_SimPc_s"
, (int16)((int32)(&((WaitThread_SimPc_s*)(0x1000))->base.object) - (int32)(WaitThread_SimPc_s*)0x1000)
, sizeof(WaitThread_SimPc_s)
, null //attributes and associations
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_WaitThread_SimPc_s //superclass
, (ClassOffset_idxMtblJcARRAY*)&interfaces_WaitThread_SimPc_s //interfaces
, mObjectJc_Modifier_reflectJc
, &mtblWaitThread_SimPc.mtbl.head
};


const char sign_Mtbl_C_waySensor1_SimPc[] = "C_waySensor1_SimPc"; //to mark method tables of all implementations

typedef struct MtblDef_C_waySensor1_SimPc_t { Mtbl_C_waySensor1_SimPc mtbl; MtblHeadJc end; } MtblDef_C_waySensor1_SimPc;
 extern MtblDef_C_waySensor1_SimPc const mtblC_waySensor1_SimPc;
int32 getWay_C_waySensor1_SimPc_F(ObjectJc* ithis, ThCxt* _thCxt)
{ C_waySensor1_SimPc_s* ythis = (C_waySensor1_SimPc_s*)ithis;
  
  STACKTRC_TENTRY("getWay_C_waySensor1_SimPc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return (int32)(ythis->outer->way1);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 getWay_C_waySensor1_SimPc(ObjectJc* ithis, ThCxt* _thCxt)
{ Mtbl_WaySensor const* mtbl = (Mtbl_WaySensor const*)getMtbl_ObjectJc(ithis, sign_Mtbl_WaySensor);
  return mtbl->getWay(ithis, _thCxt);
}


/*Constructor *//**J2C: autogenerated as default constructor. */
struct C_waySensor1_SimPc_t* ctorO_C_waySensor1_SimPc(struct SimPc_t* outer, ObjectJc* othis, ThCxt* _thCxt)
{ C_waySensor1_SimPc_s* ythis = (C_waySensor1_SimPc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_C_waySensor1_SimPc");
  checkConsistence_ObjectJc(othis, sizeof(C_waySensor1_SimPc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_C_waySensor1_SimPc_s, sizeof(C_waySensor1_SimPc_s));  
  ythis->outer = outer;
  //j2c: Initialize all class variables:
  {
  }/*J2C:No body for constructor*/

  STACKTRC_LEAVE;
  return ythis;
}




/**J2C: Reflections and Method-table *************************************************/
const MtblDef_C_waySensor1_SimPc mtblC_waySensor1_SimPc = {
{ { sign_Mtbl_C_waySensor1_SimPc//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
  /**J2C: Mtbl-interfaces of C_waySensor1_SimPc: */
, { { sign_Mtbl_WaySensor//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((1 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , getWay_C_waySensor1_SimPc_F //getWay
  , { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_ObjectJc_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_ObjectJc_F //toString
    }
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_C_waySensor1_SimPc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_C_waySensor1_SimPc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_C_waySensor1_SimPc, ObjectJc) }
   }
 };

 extern struct ClassJc_t const reflection_WaySensor_s;
 static struct ifcClasses_C_waySensor1_SimPc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }interfaces_C_waySensor1_SimPc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
, { {&reflection_WaySensor_s, OFFSET_Mtbl(Mtbl_C_waySensor1_SimPc, WaySensor) }
  }
};

const ClassJc reflection_C_waySensor1_SimPc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "C_waySensor1_SimPc_s"
, (int16)((int32)(&((C_waySensor1_SimPc_s*)(0x1000))->base.object) - (int32)(C_waySensor1_SimPc_s*)0x1000)
, sizeof(C_waySensor1_SimPc_s)
, null //attributes and associations
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_C_waySensor1_SimPc_s //superclass
, (ClassOffset_idxMtblJcARRAY*)&interfaces_C_waySensor1_SimPc_s //interfaces
, mObjectJc_Modifier_reflectJc
, &mtblC_waySensor1_SimPc.mtbl.head
};


const char sign_Mtbl_C_waySensor2_SimPc[] = "C_waySensor2_SimPc"; //to mark method tables of all implementations

typedef struct MtblDef_C_waySensor2_SimPc_t { Mtbl_C_waySensor2_SimPc mtbl; MtblHeadJc end; } MtblDef_C_waySensor2_SimPc;
 extern MtblDef_C_waySensor2_SimPc const mtblC_waySensor2_SimPc;
int32 getWay_C_waySensor2_SimPc_F(ObjectJc* ithis, ThCxt* _thCxt)
{ C_waySensor2_SimPc_s* ythis = (C_waySensor2_SimPc_s*)ithis;
  
  STACKTRC_TENTRY("getWay_C_waySensor2_SimPc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return (int32)(ythis->outer->way2);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 getWay_C_waySensor2_SimPc(ObjectJc* ithis, ThCxt* _thCxt)
{ Mtbl_WaySensor const* mtbl = (Mtbl_WaySensor const*)getMtbl_ObjectJc(ithis, sign_Mtbl_WaySensor);
  return mtbl->getWay(ithis, _thCxt);
}


/*Constructor *//**J2C: autogenerated as default constructor. */
struct C_waySensor2_SimPc_t* ctorO_C_waySensor2_SimPc(struct SimPc_t* outer, ObjectJc* othis, ThCxt* _thCxt)
{ C_waySensor2_SimPc_s* ythis = (C_waySensor2_SimPc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_C_waySensor2_SimPc");
  checkConsistence_ObjectJc(othis, sizeof(C_waySensor2_SimPc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_C_waySensor2_SimPc_s, sizeof(C_waySensor2_SimPc_s));  
  ythis->outer = outer;
  //j2c: Initialize all class variables:
  {
  }/*J2C:No body for constructor*/

  STACKTRC_LEAVE;
  return ythis;
}




/**J2C: Reflections and Method-table *************************************************/
const MtblDef_C_waySensor2_SimPc mtblC_waySensor2_SimPc = {
{ { sign_Mtbl_C_waySensor2_SimPc//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
  /**J2C: Mtbl-interfaces of C_waySensor2_SimPc: */
, { { sign_Mtbl_WaySensor//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((1 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , getWay_C_waySensor2_SimPc_F //getWay
  , { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_ObjectJc_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_ObjectJc_F //toString
    }
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_C_waySensor2_SimPc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_C_waySensor2_SimPc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_C_waySensor2_SimPc, ObjectJc) }
   }
 };

 extern struct ClassJc_t const reflection_WaySensor_s;
 static struct ifcClasses_C_waySensor2_SimPc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }interfaces_C_waySensor2_SimPc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
, { {&reflection_WaySensor_s, OFFSET_Mtbl(Mtbl_C_waySensor2_SimPc, WaySensor) }
  }
};

const ClassJc reflection_C_waySensor2_SimPc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "C_waySensor2_SimPc_s"
, (int16)((int32)(&((C_waySensor2_SimPc_s*)(0x1000))->base.object) - (int32)(C_waySensor2_SimPc_s*)0x1000)
, sizeof(C_waySensor2_SimPc_s)
, null //attributes and associations
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_C_waySensor2_SimPc_s //superclass
, (ClassOffset_idxMtblJcARRAY*)&interfaces_C_waySensor2_SimPc_s //interfaces
, mObjectJc_Modifier_reflectJc
, &mtblC_waySensor2_SimPc.mtbl.head
};


const char sign_Mtbl_C_wayActuator1_SimPc[] = "C_wayActuator1_SimPc"; //to mark method tables of all implementations

typedef struct MtblDef_C_wayActuator1_SimPc_t { Mtbl_C_wayActuator1_SimPc mtbl; MtblHeadJc end; } MtblDef_C_wayActuator1_SimPc;
 extern MtblDef_C_wayActuator1_SimPc const mtblC_wayActuator1_SimPc;
void setMotorVoltage_i_C_wayActuator1_SimPc_F(ObjectJc* ithis, int16 voltage, ThCxt* _thCxt)
{ C_wayActuator1_SimPc_s* ythis = (C_wayActuator1_SimPc_s*)ithis;
  
  STACKTRC_TENTRY("setMotorVoltage_i_C_wayActuator1_SimPc_F");
  
  { 
    
    ythis->outer->voltage1 = voltage;
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void setMotorVoltage_i_C_wayActuator1_SimPc(ObjectJc* ithis, int16 voltage, ThCxt* _thCxt)
{ Mtbl_WayActuator const* mtbl = (Mtbl_WayActuator const*)getMtbl_ObjectJc(ithis, sign_Mtbl_WayActuator);
  mtbl->setMotorVoltage(ithis, voltage, _thCxt);
}


/*Constructor *//**J2C: autogenerated as default constructor. */
struct C_wayActuator1_SimPc_t* ctorO_C_wayActuator1_SimPc(struct SimPc_t* outer, ObjectJc* othis, ThCxt* _thCxt)
{ C_wayActuator1_SimPc_s* ythis = (C_wayActuator1_SimPc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_C_wayActuator1_SimPc");
  checkConsistence_ObjectJc(othis, sizeof(C_wayActuator1_SimPc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_C_wayActuator1_SimPc_s, sizeof(C_wayActuator1_SimPc_s));  
  ythis->outer = outer;
  //j2c: Initialize all class variables:
  {
  }/*J2C:No body for constructor*/

  STACKTRC_LEAVE;
  return ythis;
}




/**J2C: Reflections and Method-table *************************************************/
const MtblDef_C_wayActuator1_SimPc mtblC_wayActuator1_SimPc = {
{ { sign_Mtbl_C_wayActuator1_SimPc//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
  /**J2C: Mtbl-interfaces of C_wayActuator1_SimPc: */
, { { sign_Mtbl_WayActuator//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((1 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , setMotorVoltage_i_C_wayActuator1_SimPc_F //setMotorVoltage
  , { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_ObjectJc_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_ObjectJc_F //toString
    }
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_C_wayActuator1_SimPc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_C_wayActuator1_SimPc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_C_wayActuator1_SimPc, ObjectJc) }
   }
 };

 extern struct ClassJc_t const reflection_WayActuator_s;
 static struct ifcClasses_C_wayActuator1_SimPc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }interfaces_C_wayActuator1_SimPc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
, { {&reflection_WayActuator_s, OFFSET_Mtbl(Mtbl_C_wayActuator1_SimPc, WayActuator) }
  }
};

const ClassJc reflection_C_wayActuator1_SimPc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "C_wayActuator1_SimPc_s"
, (int16)((int32)(&((C_wayActuator1_SimPc_s*)(0x1000))->base.object) - (int32)(C_wayActuator1_SimPc_s*)0x1000)
, sizeof(C_wayActuator1_SimPc_s)
, null //attributes and associations
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_C_wayActuator1_SimPc_s //superclass
, (ClassOffset_idxMtblJcARRAY*)&interfaces_C_wayActuator1_SimPc_s //interfaces
, mObjectJc_Modifier_reflectJc
, &mtblC_wayActuator1_SimPc.mtbl.head
};


const char sign_Mtbl_C_wayActuator2_SimPc[] = "C_wayActuator2_SimPc"; //to mark method tables of all implementations

typedef struct MtblDef_C_wayActuator2_SimPc_t { Mtbl_C_wayActuator2_SimPc mtbl; MtblHeadJc end; } MtblDef_C_wayActuator2_SimPc;
 extern MtblDef_C_wayActuator2_SimPc const mtblC_wayActuator2_SimPc;
void setMotorVoltage_i_C_wayActuator2_SimPc_F(ObjectJc* ithis, int16 voltage, ThCxt* _thCxt)
{ C_wayActuator2_SimPc_s* ythis = (C_wayActuator2_SimPc_s*)ithis;
  
  STACKTRC_TENTRY("setMotorVoltage_i_C_wayActuator2_SimPc_F");
  
  { 
    
    ythis->outer->voltage2 = voltage;
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void setMotorVoltage_i_C_wayActuator2_SimPc(ObjectJc* ithis, int16 voltage, ThCxt* _thCxt)
{ Mtbl_WayActuator const* mtbl = (Mtbl_WayActuator const*)getMtbl_ObjectJc(ithis, sign_Mtbl_WayActuator);
  mtbl->setMotorVoltage(ithis, voltage, _thCxt);
}


/*Constructor *//**J2C: autogenerated as default constructor. */
struct C_wayActuator2_SimPc_t* ctorO_C_wayActuator2_SimPc(struct SimPc_t* outer, ObjectJc* othis, ThCxt* _thCxt)
{ C_wayActuator2_SimPc_s* ythis = (C_wayActuator2_SimPc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_C_wayActuator2_SimPc");
  checkConsistence_ObjectJc(othis, sizeof(C_wayActuator2_SimPc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_C_wayActuator2_SimPc_s, sizeof(C_wayActuator2_SimPc_s));  
  ythis->outer = outer;
  //j2c: Initialize all class variables:
  {
  }/*J2C:No body for constructor*/

  STACKTRC_LEAVE;
  return ythis;
}




/**J2C: Reflections and Method-table *************************************************/
const MtblDef_C_wayActuator2_SimPc mtblC_wayActuator2_SimPc = {
{ { sign_Mtbl_C_wayActuator2_SimPc//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
  /**J2C: Mtbl-interfaces of C_wayActuator2_SimPc: */
, { { sign_Mtbl_WayActuator//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((1 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , setMotorVoltage_i_C_wayActuator2_SimPc_F //setMotorVoltage
  , { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_ObjectJc_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_ObjectJc_F //toString
    }
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_C_wayActuator2_SimPc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_C_wayActuator2_SimPc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_C_wayActuator2_SimPc, ObjectJc) }
   }
 };

 extern struct ClassJc_t const reflection_WayActuator_s;
 static struct ifcClasses_C_wayActuator2_SimPc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }interfaces_C_wayActuator2_SimPc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
, { {&reflection_WayActuator_s, OFFSET_Mtbl(Mtbl_C_wayActuator2_SimPc, WayActuator) }
  }
};

const ClassJc reflection_C_wayActuator2_SimPc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "C_wayActuator2_SimPc_s"
, (int16)((int32)(&((C_wayActuator2_SimPc_s*)(0x1000))->base.object) - (int32)(C_wayActuator2_SimPc_s*)0x1000)
, sizeof(C_wayActuator2_SimPc_s)
, null //attributes and associations
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_C_wayActuator2_SimPc_s //superclass
, (ClassOffset_idxMtblJcARRAY*)&interfaces_C_wayActuator2_SimPc_s //interfaces
, mObjectJc_Modifier_reflectJc
, &mtblC_wayActuator2_SimPc.mtbl.head
};


const char sign_Mtbl_C_broker2_SimPc[] = "C_broker2_SimPc"; //to mark method tables of all implementations

typedef struct MtblDef_C_broker2_SimPc_t { Mtbl_C_broker2_SimPc mtbl; MtblHeadJc end; } MtblDef_C_broker2_SimPc;
 extern MtblDef_C_broker2_SimPc const mtblC_broker2_SimPc;
struct WayActuator_t* requireWay1Actuator_C_broker2_SimPc_F(ObjectJc* ithis, ThCxt* _thCxt)
{ C_broker2_SimPc_s* ythis = (C_broker2_SimPc_s*)ithis;
  
  STACKTRC_TENTRY("requireWay1Actuator_C_broker2_SimPc_F");
  
  { 
    WayActuatorMTB ret;   /**/
    
    
    SETMTBJc(ret, & ((ythis->outer->wayActuator1).base.WayActuator), WayActuator);
    { STACKTRC_LEAVE;
      return  (ret.ref);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct WayActuator_t* requireWay1Actuator_C_broker2_SimPc(ObjectJc* ithis, ThCxt* _thCxt)
{ Mtbl_iRequireMainController const* mtbl = (Mtbl_iRequireMainController const*)getMtbl_ObjectJc(ithis, sign_Mtbl_iRequireMainController);
  return mtbl->requireWay1Actuator(ithis, _thCxt);
}

struct WaySensor_t* requireWay1Sensor_C_broker2_SimPc_F(ObjectJc* ithis, ThCxt* _thCxt)
{ C_broker2_SimPc_s* ythis = (C_broker2_SimPc_s*)ithis;
  
  STACKTRC_TENTRY("requireWay1Sensor_C_broker2_SimPc_F");
  
  { 
    WaySensorMTB ret;   /**/
    
    
    SETMTBJc(ret, & ((ythis->outer->waySensor1).base.WaySensor), WaySensor);
    { STACKTRC_LEAVE;
      return  (ret.ref);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct WaySensor_t* requireWay1Sensor_C_broker2_SimPc(ObjectJc* ithis, ThCxt* _thCxt)
{ Mtbl_iRequireMainController const* mtbl = (Mtbl_iRequireMainController const*)getMtbl_ObjectJc(ithis, sign_Mtbl_iRequireMainController);
  return mtbl->requireWay1Sensor(ithis, _thCxt);
}

struct WayActuator_t* requireWay2Actuator_C_broker2_SimPc_F(ObjectJc* ithis, ThCxt* _thCxt)
{ C_broker2_SimPc_s* ythis = (C_broker2_SimPc_s*)ithis;
  
  STACKTRC_TENTRY("requireWay2Actuator_C_broker2_SimPc_F");
  
  { 
    WayActuatorMTB ret;   /**/
    
    
    SETMTBJc(ret, & ((ythis->outer->wayActuator2).base.WayActuator), WayActuator);
    { STACKTRC_LEAVE;
      return  (ret.ref);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct WayActuator_t* requireWay2Actuator_C_broker2_SimPc(ObjectJc* ithis, ThCxt* _thCxt)
{ Mtbl_iRequireMainController const* mtbl = (Mtbl_iRequireMainController const*)getMtbl_ObjectJc(ithis, sign_Mtbl_iRequireMainController);
  return mtbl->requireWay2Actuator(ithis, _thCxt);
}

struct WaySensor_t* requireWay2Sensor_C_broker2_SimPc_F(ObjectJc* ithis, ThCxt* _thCxt)
{ C_broker2_SimPc_s* ythis = (C_broker2_SimPc_s*)ithis;
  
  STACKTRC_TENTRY("requireWay2Sensor_C_broker2_SimPc_F");
  
  { 
    WaySensorMTB ret;   /**/
    
    
    SETMTBJc(ret, & ((ythis->outer->waySensor2).base.WaySensor), WaySensor);
    { STACKTRC_LEAVE;
      return  (ret.ref);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct WaySensor_t* requireWay2Sensor_C_broker2_SimPc(ObjectJc* ithis, ThCxt* _thCxt)
{ Mtbl_iRequireMainController const* mtbl = (Mtbl_iRequireMainController const*)getMtbl_ObjectJc(ithis, sign_Mtbl_iRequireMainController);
  return mtbl->requireWay2Sensor(ithis, _thCxt);
}


/*Constructor *//**J2C: autogenerated as default constructor. */
struct C_broker2_SimPc_t* ctorO_C_broker2_SimPc(struct SimPc_t* outer, ObjectJc* othis, ThCxt* _thCxt)
{ C_broker2_SimPc_s* ythis = (C_broker2_SimPc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_C_broker2_SimPc");
  checkConsistence_ObjectJc(othis, sizeof(C_broker2_SimPc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_C_broker2_SimPc_s, sizeof(C_broker2_SimPc_s));  
  ythis->outer = outer;
  //j2c: Initialize all class variables:
  {
  }/*J2C:No body for constructor*/

  STACKTRC_LEAVE;
  return ythis;
}




/**J2C: Reflections and Method-table *************************************************/
const MtblDef_C_broker2_SimPc mtblC_broker2_SimPc = {
{ { sign_Mtbl_C_broker2_SimPc//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
  /**J2C: Mtbl-interfaces of C_broker2_SimPc: */
, { { sign_Mtbl_iRequireMainController//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((4 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , requireWay1Sensor_C_broker2_SimPc_F //requireWay1Sensor
  , requireWay2Sensor_C_broker2_SimPc_F //requireWay2Sensor
  , requireWay1Actuator_C_broker2_SimPc_F //requireWay1Actuator
  , requireWay2Actuator_C_broker2_SimPc_F //requireWay2Actuator
  , { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_ObjectJc_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_ObjectJc_F //toString
    }
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_C_broker2_SimPc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_C_broker2_SimPc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_C_broker2_SimPc, ObjectJc) }
   }
 };

 extern struct ClassJc_t const reflection_iRequireMainController_s;
 static struct ifcClasses_C_broker2_SimPc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }interfaces_C_broker2_SimPc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
, { {&reflection_iRequireMainController_s, OFFSET_Mtbl(Mtbl_C_broker2_SimPc, iRequireMainController) }
  }
};

const ClassJc reflection_C_broker2_SimPc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "C_broker2_SimPc_s"
, (int16)((int32)(&((C_broker2_SimPc_s*)(0x1000))->base.object) - (int32)(C_broker2_SimPc_s*)0x1000)
, sizeof(C_broker2_SimPc_s)
, null //attributes and associations
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_C_broker2_SimPc_s //superclass
, (ClassOffset_idxMtblJcARRAY*)&interfaces_C_broker2_SimPc_s //interfaces
, mObjectJc_Modifier_reflectJc
, &mtblC_broker2_SimPc.mtbl.head
};
