/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "PosCtrl/ReadTargetFromText.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept


const char sign_Mtbl_ReadTargetFromText[] = "ReadTargetFromText"; //to mark method tables of all implementations

typedef struct MtblDef_ReadTargetFromText_t { Mtbl_ReadTargetFromText mtbl; MtblHeadJc end; } MtblDef_ReadTargetFromText;
 extern MtblDef_ReadTargetFromText const mtblReadTargetFromText;

/*Constructor */
struct ReadTargetFromText_t* ctorO_ReadTargetFromText(ObjectJc* othis, ThCxt* _thCxt)
{ ReadTargetFromText_s* ythis = (ReadTargetFromText_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_ReadTargetFromText");
  checkConsistence_ObjectJc(othis, sizeof(ReadTargetFromText_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_ReadTargetFromText_s, sizeof(ReadTargetFromText_s));  
  //j2c: Initialize all class variables:
  {
    set_StringJc(&(ythis->textTarget), z_StringJc("1000, 2000, 1500"));
    /*J2C: newArray*/
      init_ObjectJc(&ythis->targets.head.object, sizeof_ARRAYJc(Target_ReadTargetFromText_s, 100), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&ythis->targets.head.object, 100, sizeof(Target_ReadTargetFromText_s), null, 0);//J2C: constructor for embedded array;
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->spTextTarget.base.object), sizeof(ythis->spTextTarget), 0); 
      ctorO_StringPartJc(/*static*/&(ythis->spTextTarget.base.object), _thCxt);
  }
  { 
    
    
  }
  STACKTRC_LEAVE;
  return ythis;
}


void test_ReadTargetFromText_F(ReadTargetFromText_s* ythis, ThCxt* _thCxt)
{ Mtbl_ReadTargetFromText const* mtthis = (Mtbl_ReadTargetFromText const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ReadTargetFromText);
  
  STACKTRC_TENTRY("test_ReadTargetFromText_F");
  
  { 
    
    TRY
    { 
      
      mtthis->readTargetsFromText(ythis, ythis->textTarget, _thCxt);
    }_TRY
    CATCH(ParseException, e)
    
      { //: TODO Auto-generated catch block
        //:e.printStackTrace();
        
        
        
      }
    END_TRY
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void test_ReadTargetFromText(ReadTargetFromText_s* ythis, ThCxt* _thCxt)
{ Mtbl_ReadTargetFromText const* mtbl = (Mtbl_ReadTargetFromText const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ReadTargetFromText);
  mtbl->test(ythis, _thCxt);
}

int32 readTargetsFromText_ReadTargetFromText_F(ReadTargetFromText_s* ythis, StringJc input, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("readTargetsFromText_ReadTargetFromText_F");
  
  { 
    int16 target = 0; 
    int16 velocity = 0; 
    int32 idxTargets = 0; 
    bool bNext = 0; 
    
    
    assign_S_StringPartJc_F(& (ythis->spTextTarget), input, _thCxt);
    setIgnoreWhitespaces_StringPartJc_F(& (ythis->spTextTarget), true, _thCxt);
    /*no initvalue*/
    /*no initvalue*/
    idxTargets = 0;
    for(idxTargets = 0; idxTargets < ythis->targets.head.length; idxTargets++)
      { 
        
        //J2C: constructor for embedded element-ObjectJc
        init_ObjectJc(&(ythis->targets.data[idxTargets].base.object), sizeof(ythis->targets.data[idxTargets]), 0); 
        ctorO_Target_ReadTargetFromText(/*static*/&(ythis->targets.data[idxTargets].base.object), _thCxt);
      }
    idxTargets = 0;
    /*no initvalue*/
    do 
      { 
        
        if(
        ( scanInteger_StringPartJc_F(& (ythis->spTextTarget), _thCxt)
        , scanOk_StringPartJc_F(& (ythis->spTextTarget), _thCxt)
        )) 
        { 
          
          target = (int16)getLastScannedIntegerNumber_StringPartJc_F(& (ythis->spTextTarget), _thCxt);
          if(
          ( scan_StringPartJc_F(& (ythis->spTextTarget), s0_StringJc(":"), _thCxt)
          , scanInteger_StringPartJc_F(& (ythis->spTextTarget), _thCxt)
          , scanOk_StringPartJc_F(& (ythis->spTextTarget), _thCxt)
          )) 
          { 
            
            velocity = (int16)getLastScannedIntegerNumber_StringPartJc_F(& (ythis->spTextTarget), _thCxt);
          }
          else 
          { //:no velocity given:
            
            
            velocity = 100;
          }
        }
        else 
        { 
          
          { throw_s0Jc(ident_ParseExceptionJc, "integer value expected", getLineCt_StringPartJc_F(& (ythis->spTextTarget), _thCxt), &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
        }
        ythis->targets.data[idxTargets].position = target;
        ythis->targets.data[idxTargets].velocity = velocity;
        idxTargets += 1;
        bNext = 
        ( scan_StringPartJc_F(& (ythis->spTextTarget), s0_StringJc(","), _thCxt)
        , scanOk_StringPartJc_F(& (ythis->spTextTarget), _thCxt)
        );
      }while(bNext);// && idxTargets < targets.length);
    
    { STACKTRC_LEAVE;
      return idxTargets;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 readTargetsFromText_ReadTargetFromText(ReadTargetFromText_s* ythis, StringJc input, ThCxt* _thCxt)
{ Mtbl_ReadTargetFromText const* mtbl = (Mtbl_ReadTargetFromText const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ReadTargetFromText);
  return mtbl->readTargetsFromText(ythis, input, _thCxt);
}



/**J2C: Reflections and Method-table *************************************************/
const MtblDef_ReadTargetFromText mtblReadTargetFromText = {
{ { sign_Mtbl_ReadTargetFromText//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((2 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, test_ReadTargetFromText_F //test
, readTargetsFromText_ReadTargetFromText_F //readTargetsFromText
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_ReadTargetFromText_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_ReadTargetFromText_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_ReadTargetFromText, ObjectJc) }
   }
 };

extern struct ClassJc_t const reflection_ReadTargetFromText_s;
extern struct ClassJc_t const reflection_StringJc;
extern struct ClassJc_t const reflection_StringPartJc_s;
extern struct ClassJc_t const reflection_Target_ReadTargetFromText_s;
const struct Reflection_Fields_ReadTargetFromText_s_t
{ ObjectArrayJc head; FieldJc data[3];
} reflection_Fields_ReadTargetFromText_s =
{ CONST_ObjectArrayJc(FieldJc, 3, OBJTYPE_FieldJc, null, &reflection_Fields_ReadTargetFromText_s)
, {
     { "textTarget"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((ReadTargetFromText_s*)(0x1000))->textTarget) - (int32)(ReadTargetFromText_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ReadTargetFromText_s
    }
   , { "targets"
    , 100 //nrofArrayElements
    , &reflection_Target_ReadTargetFromText_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc |kStaticArray_Modifier_reflectJc |kEmbeddedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ReadTargetFromText_s*)(0x1000))->targets) - (int32)(ReadTargetFromText_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ReadTargetFromText_s
    }
   , { "spTextTarget"
    , 0 //nrofArrayElements
    , &reflection_StringPartJc_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ReadTargetFromText_s*)(0x1000))->spTextTarget) - (int32)(ReadTargetFromText_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ReadTargetFromText_s
    }
} };
const ClassJc reflection_ReadTargetFromText_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "ReadTargetFromText_s"
,  0 //position of ObjectJc
, sizeof(ReadTargetFromText_s)
, (FieldJcArray const*)&reflection_Fields_ReadTargetFromText_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_ReadTargetFromText_s //superclass
, null //interfaces
, 0    //modifiers
, &mtblReadTargetFromText.mtbl.head
};

/**Class to hold the values for one target.

@xxxjava2c=noObject. It should be never used as Object.

*/


const char sign_Mtbl_Target_ReadTargetFromText[] = "Target_ReadTargetFromText"; //to mark method tables of all implementations

typedef struct MtblDef_Target_ReadTargetFromText_t { Mtbl_Target_ReadTargetFromText mtbl; MtblHeadJc end; } MtblDef_Target_ReadTargetFromText;
 extern MtblDef_Target_ReadTargetFromText const mtblTarget_ReadTargetFromText;

/*Constructor *//**J2C: autogenerated as default constructor. */
struct Target_ReadTargetFromText_t* ctorO_Target_ReadTargetFromText(ObjectJc* othis, ThCxt* _thCxt)
{ Target_ReadTargetFromText_s* ythis = (Target_ReadTargetFromText_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_Target_ReadTargetFromText");
  checkConsistence_ObjectJc(othis, sizeof(Target_ReadTargetFromText_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_Target_ReadTargetFromText_s, sizeof(Target_ReadTargetFromText_s));  
  //j2c: Initialize all class variables:
  {
  }/*J2C:No body for constructor*/

  STACKTRC_LEAVE;
  return ythis;
}




/**J2C: Reflections and Method-table *************************************************/
const MtblDef_Target_ReadTargetFromText mtblTarget_ReadTargetFromText = {
{ { sign_Mtbl_Target_ReadTargetFromText//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_Target_ReadTargetFromText_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_Target_ReadTargetFromText_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_Target_ReadTargetFromText, ObjectJc) }
   }
 };

extern struct ClassJc_t const reflection_Target_ReadTargetFromText_s;
const struct Reflection_Fields_Target_ReadTargetFromText_s_t
{ ObjectArrayJc head; FieldJc data[2];
} reflection_Fields_Target_ReadTargetFromText_s =
{ CONST_ObjectArrayJc(FieldJc, 2, OBJTYPE_FieldJc, null, &reflection_Fields_Target_ReadTargetFromText_s)
, {
     { "position"
    , 0 //nrofArrayElements
    , REFLECTION_int16
    , 2 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Target_ReadTargetFromText_s*)(0x1000))->position) - (int32)(Target_ReadTargetFromText_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_Target_ReadTargetFromText_s
    }
   , { "velocity"
    , 0 //nrofArrayElements
    , REFLECTION_int16
    , 2 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Target_ReadTargetFromText_s*)(0x1000))->velocity) - (int32)(Target_ReadTargetFromText_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_Target_ReadTargetFromText_s
    }
} };
const ClassJc reflection_Target_ReadTargetFromText_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "Target_ReadTargetFromText_s"
,  0 //position of ObjectJc
, sizeof(Target_ReadTargetFromText_s)
, (FieldJcArray const*)&reflection_Fields_Target_ReadTargetFromText_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_Target_ReadTargetFromText_s //superclass
, null //interfaces
, 0    //modifiers
, &mtblTarget_ReadTargetFromText.mtbl.head
};
