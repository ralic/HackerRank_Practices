/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "PosCtrl/PID_controller.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept

/**This class provides a simple PID-Controller generateable to C with 16-bit arithmetic
and a 32-bit-integral value.
A fix point 16-bit arithmetic should be used, because in the embedded world
with low-cost-C-controllers without floating point arithmetic unit
but fast real-time requirements it is a appropriate decision.
This example of 16-bit-PID-controller should show,
that such relationships are also programmable and testable in the Java world.

@author JcHartmut

*/


const char sign_Mtbl_PID_controller[] = "PID_controller"; //to mark method tables of all implementations

typedef struct MtblDef_PID_controller_t { Mtbl_PID_controller mtbl; MtblHeadJc end; } MtblDef_PID_controller;
 extern MtblDef_PID_controller const mtblPID_controller;

/*Constructor *//**J2C: autogenerated as default constructor. */
struct PID_controller_t* ctorO_PID_controller(ObjectJc* othis, ThCxt* _thCxt)
{ PID_controller_s* ythis = (PID_controller_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_PID_controller");
  checkConsistence_ObjectJc(othis, sizeof(PID_controller_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_PID_controller_s, sizeof(PID_controller_s));  
  //j2c: Initialize all class variables:
  {
    ythis->intgVal = 0;
    ythis->kI = ((/*J2C:cast% from int32*/int16)(0x1000));
    ythis->kP = ((/*J2C:cast% from int32*/int16)(0x80));
    ythis->kD = 0;
  }/*J2C:No body for constructor*/

  STACKTRC_LEAVE;
  return ythis;
}



/**the step-method, called one-time per cycle-time to calculate the next value.*/
int16 calculate_PID_controller_F(PID_controller_s* ythis, int16 input, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("calculate_PID_controller_F");
  
  { 
    int32 intgValNew; 
    int32 out; 
    
    
    intgValNew = ythis->intgVal + (input * ythis->kI);
    out = (intgValNew >> 16) + ((ythis->kP * input) >> 6);
    /*The out may be overdriven, but it can be limited because it is caluclated in 32 bit.*/
    if(out > 0x7fff) 
    { 
      
      out = 0x7fff;
    }
    else if(out < -0x8000) 
    { 
      
      out = -0x8000;
    }
    /*Test if the integral value is overdriven. */
    if(((ythis->intgVal > 0 && input > 0) || (ythis->intgVal < 0 && input < 0)) && ((intgValNew ^ ythis->intgVal) & 0x80000000) == 0x80000000) 
    { 
      
      /*The sign of new value is changed, but the absolute integral value is increased,*/
      { throw_s0Jc(ident_RuntimeExceptionJc, "integral value overdriven", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    }
    else 
    { 
      
      ythis->intgVal = intgValNew;//the integral value is valid.
      
    }
    { STACKTRC_LEAVE;
      return (int16)(out);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int16 calculate_PID_controller(PID_controller_s* ythis, int16 input, ThCxt* _thCxt)
{ Mtbl_PID_controller const* mtbl = (Mtbl_PID_controller const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_PID_controller);
  return mtbl->calculate(ythis, input, _thCxt);
}


/**Sets the integral value to a predefined value.*/
void setIntg_PID_controller_F(PID_controller_s* ythis, int16 setValue, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIntg_PID_controller_F");
  
  { 
    
    ythis->intgVal = ((int32)(setValue)) << 16;
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void setIntg_PID_controller(PID_controller_s* ythis, int16 setValue, ThCxt* _thCxt)
{ Mtbl_PID_controller const* mtbl = (Mtbl_PID_controller const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_PID_controller);
  mtbl->setIntg(ythis, setValue, _thCxt);
}


/**Gets the value of the internal integrator for displayment*/
float getIntg_PID_controller_F(PID_controller_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getIntg_PID_controller_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return ythis->intgVal / 65536.0F;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
float getIntg_PID_controller(PID_controller_s* ythis, ThCxt* _thCxt)
{ Mtbl_PID_controller const* mtbl = (Mtbl_PID_controller const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_PID_controller);
  return mtbl->getIntg(ythis, _thCxt);
}


/**Connect the Input of PID controller to a short variable.*/
void connectInput_PID_controller_F(PID_controller_s* ythis, int16_Y* ref, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("connectInput_PID_controller_F");
  
  { 
    
    ythis->xPID = ref;
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void connectInput_PID_controller(PID_controller_s* ythis, int16_Y* ref, ThCxt* _thCxt)
{ Mtbl_PID_controller const* mtbl = (Mtbl_PID_controller const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_PID_controller);
  mtbl->connectInput(ythis, ref, _thCxt);
}


/**provides the reference to the output for wiring to any connection.*/
int16_Y* provideOutput_PID_controller_F(PID_controller_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("provideOutput_PID_controller_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return ythis->yPID;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int16_Y* provideOutput_PID_controller(PID_controller_s* ythis, ThCxt* _thCxt)
{ Mtbl_PID_controller const* mtbl = (Mtbl_PID_controller const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_PID_controller);
  return mtbl->provideOutput(ythis, _thCxt);
}

void init_PID_controller_F(ObjectJc* ithis, ThCxt* _thCxt)
{ PID_controller_s* ythis = (PID_controller_s*)ithis;
  
  STACKTRC_TENTRY("init_PID_controller_F");
  
  { //: TODO Auto-generated method stub
    
    
    
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void init_PID_controller(ObjectJc* ithis, ThCxt* _thCxt)
{ Mtbl_CtrlBase const* mtbl = (Mtbl_CtrlBase const*)getMtbl_ObjectJc(ithis, sign_Mtbl_CtrlBase);
  mtbl->init(ithis, _thCxt);
}

void parametrize_PID_controller_F(ObjectJc* ithis, ThCxt* _thCxt)
{ PID_controller_s* ythis = (PID_controller_s*)ithis;
  
  STACKTRC_TENTRY("parametrize_PID_controller_F");
  
  { //: TODO Auto-generated method stub
    
    
    
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void parametrize_PID_controller(ObjectJc* ithis, ThCxt* _thCxt)
{ Mtbl_CtrlBase const* mtbl = (Mtbl_CtrlBase const*)getMtbl_ObjectJc(ithis, sign_Mtbl_CtrlBase);
  mtbl->parametrize(ithis, _thCxt);
}

void reset_PID_controller_F(ObjectJc* ithis, ThCxt* _thCxt)
{ PID_controller_s* ythis = (PID_controller_s*)ithis;
  
  STACKTRC_TENTRY("reset_PID_controller_F");
  
  { //: TODO Auto-generated method stub
    
    
    
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void reset_PID_controller(ObjectJc* ithis, ThCxt* _thCxt)
{ Mtbl_CtrlBase const* mtbl = (Mtbl_CtrlBase const*)getMtbl_ObjectJc(ithis, sign_Mtbl_CtrlBase);
  mtbl->reset(ithis, _thCxt);
}

void step_i_PID_controller_F(ObjectJc* ithis, int32 time, ThCxt* _thCxt)
{ PID_controller_s* ythis = (PID_controller_s*)ithis;
  Mtbl_PID_controller const* mtthis = (Mtbl_PID_controller const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_PID_controller);
  
  STACKTRC_TENTRY("step_i_PID_controller_F");
  
  { 
    
    ythis->yPID->data[0] = mtthis->calculate(ythis, ythis->xPID->data[0], _thCxt);
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void step_i_PID_controller(ObjectJc* ithis, int32 time, ThCxt* _thCxt)
{ Mtbl_CtrlBase const* mtbl = (Mtbl_CtrlBase const*)getMtbl_ObjectJc(ithis, sign_Mtbl_CtrlBase);
  mtbl->step(ithis, time, _thCxt);
}



/**J2C: Reflections and Method-table *************************************************/
const MtblDef_PID_controller mtblPID_controller = {
{ { sign_Mtbl_PID_controller//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, calculate_PID_controller_F //calculate
, setIntg_PID_controller_F //setIntg
, getIntg_PID_controller_F //getIntg
, connectInput_PID_controller_F //connectInput
, provideOutput_PID_controller_F //provideOutput
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
  /**J2C: Mtbl-interfaces of PID_controller: */
, { { sign_Mtbl_CtrlBase//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((4 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , init_PID_controller_F //init
  , reset_PID_controller_F //reset
  , step_i_PID_controller_F //step
  , parametrize_PID_controller_F //parametrize
  , { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_ObjectJc_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_ObjectJc_F //toString
    }
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_PID_controller_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_PID_controller_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_PID_controller, ObjectJc) }
   }
 };

 extern struct ClassJc_t const reflection_CtrlBase_s;
 static struct ifcClasses_PID_controller_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }interfaces_PID_controller_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
, { {&reflection_CtrlBase_s, OFFSET_Mtbl(Mtbl_PID_controller, CtrlBase) }
  }
};

extern struct ClassJc_t const reflection_PID_controller_s;
const struct Reflection_Fields_PID_controller_s_t
{ ObjectArrayJc head; FieldJc data[7];
} reflection_Fields_PID_controller_s =
{ CONST_ObjectArrayJc(FieldJc, 7, OBJTYPE_FieldJc, null, &reflection_Fields_PID_controller_s)
, {
     { "intgVal"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((PID_controller_s*)(0x1000))->intgVal) - (int32)(PID_controller_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_PID_controller_s
    }
   , { "lastForDiff"
    , 0 //nrofArrayElements
    , REFLECTION_int16
    , 2 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((PID_controller_s*)(0x1000))->lastForDiff) - (int32)(PID_controller_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_PID_controller_s
    }
   , { "kI"
    , 0 //nrofArrayElements
    , REFLECTION_int16
    , 2 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((PID_controller_s*)(0x1000))->kI) - (int32)(PID_controller_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_PID_controller_s
    }
   , { "kP"
    , 0 //nrofArrayElements
    , REFLECTION_int16
    , 2 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((PID_controller_s*)(0x1000))->kP) - (int32)(PID_controller_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_PID_controller_s
    }
   , { "kD"
    , 0 //nrofArrayElements
    , REFLECTION_int16
    , 2 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((PID_controller_s*)(0x1000))->kD) - (int32)(PID_controller_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_PID_controller_s
    }
   , { "xPID"
    , 0 //nrofArrayElements
    , REFLECTION_int16
    , 2 << kBitPrimitiv_Modifier_reflectJc |kObjectArrayJc_Modifier_reflectJc |kReferencedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((PID_controller_s*)(0x1000))->xPID) - (int32)(PID_controller_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_PID_controller_s
    }
   , { "yPID"
    , 0 //nrofArrayElements
    , REFLECTION_int16
    , 2 << kBitPrimitiv_Modifier_reflectJc |kObjectArrayJc_Modifier_reflectJc |kReferencedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((PID_controller_s*)(0x1000))->yPID) - (int32)(PID_controller_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_PID_controller_s
    }
} };
const ClassJc reflection_PID_controller_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "PID_controller_s"
, (int16)((int32)(&((PID_controller_s*)(0x1000))->base.object) - (int32)(PID_controller_s*)0x1000)
, sizeof(PID_controller_s)
, (FieldJcArray const*)&reflection_Fields_PID_controller_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_PID_controller_s //superclass
, (ClassOffset_idxMtblJcARRAY*)&interfaces_PID_controller_s //interfaces
, mObjectJc_Modifier_reflectJc
, &mtblPID_controller.mtbl.head
};
