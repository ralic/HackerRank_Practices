//this file is generated by Java2C
#include "TestGarbageCollector.h"
#include "string.h"  //because using memset()
#include "ReflectionJc.h"  
#include "ThreadContextJc.h"  //stacktrace concept
#include "TestClass.h"
#include "TestGarbageCollector.h"

 struct MtblTestGarbageCollector
{ Mtbl_ObjectJc mtblObjectJc;  //methods from ObjectJc;
} const mtblTestGarbageCollector =
{ { clone_Object_F
  , equals_Object_F
  , finalize_TestGarbageCollector
  , hashCode_Object_F
  , toString_Object_F
  }
};
 const ClassJc classTestGarbageCollector = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, null) 
, "TestGarbageCollector"
, 0 //position of ObjectJc
, sizeof(TestGarbageCollector)
, null //attributes and associations
, null //method
, null //superclass
, null //interfaces
, 0    //modifiers
, &mtblTestGarbageCollector.mtblObjectJc
};
 const ClassJc* clazzTestGarbageCollector = &classTestGarbageCollector;
TestGarbageCollectorREF theInstance_TestGarbageCollector = { 0, null };

TestGarbageCollector* ctorO_TestGarbageCollector(ObjectJc* newObj, struct ThreadContextJc_t* _threadContext)
{ TestGarbageCollector* ythis = (TestGarbageCollector*)newObj;  //upcasting to the real class.
  int sizeObj = getSizeInfo_ObjectJc(newObj);
  StacktraceJc stacktrace = {_threadContext->stacktrace, { "ctorO_TestGarbageCollector", __FILE__, __LINE__} , null}; 
  _threadContext->stacktrace = &stacktrace;
    checkConsistence_ObjectJc(newObj, sizeof(TestGarbageCollector), clazzTestGarbageCollector, _threadContext);  
 _threadContext->stacktrace = stacktrace.previous;
  return ythis;
}



void main_TestGarbageCollector(TestGarbageCollector* ythis, StringJc args, struct ThreadContextJc_t* _threadContext)
{  StacktraceJc stacktrace = {_threadContext->stacktrace, { "main_TestGarbageCollector", __FILE__, __LINE__} , null}; 
  _threadContext->stacktrace = &stacktrace;
  { 
    struct TestGarbageCollector_t* i1;
    ObjectJc *newObj1;
    i1 = ctorO_TestGarbageCollector/*no methods*/((newObj1 = allocObject_s_sBlockHeapJc(sizeof(TestGarbageCollector), 0, "main_TestGarbageCollector", _threadContext)), _threadContext);if(theInstance_TestGarbageCollector.ref != null) clearBackRefJc(&(theInstance_TestGarbageCollector.refbase));
    theInstance_TestGarbageCollector.ref = i1;
    setBackRefJc(&(theInstance_TestGarbageCollector.refbase)/*addr of ref*/, theInstance_TestGarbageCollector.ref /*The refed Object as void* */);
    
    run_TestGarbageCollector/*no methods*/(theInstance_TestGarbageCollector.ref, _threadContext);
    activateGarbageCollectorAccess_BlockHeapJc(newObj1);
  }
  _threadContext->stacktrace = stacktrace.previous;
}



void run_TestGarbageCollector(TestGarbageCollector* ythis, struct ThreadContextJc_t* _threadContext)
{  StacktraceJc stacktrace = {_threadContext->stacktrace, { "run_TestGarbageCollector", __FILE__, __LINE__} , null}; 
  _threadContext->stacktrace = &stacktrace;
  { 
    ObjectJc *newObj1, *newObj2;if(ythis->refA.ref != null) clearBackRefJc(&(ythis->refA.refbase));
    ythis->refA.ref = ctorO_TestClass/*no methods*/((newObj1 = allocObject_s_sBlockHeapJc(sizeof(TestClass), 0, "run_TestGarbageCollector", _threadContext)), 1, _threadContext);
    setBackRefJc(&(ythis->refA.refbase)/*addr of ref*/, ythis->refA.ref /*The refed Object as void* */);
    
    if(ythis->refA.ref->test1.ref != null) clearBackRefJc(&(ythis->refA.ref->test1.refbase));
    ythis->refA.ref->test1.ref = ctorO_TestClass/*no methods*/((newObj2 = allocObject_s_sBlockHeapJc(sizeof(TestClass), 0, "run_TestGarbageCollector", _threadContext)), 2, _threadContext);
    setBackRefJc(&(ythis->refA.ref->test1.refbase)/*addr of ref*/, ythis->refA.ref->test1.ref /*The refed Object as void* */);
    
    if(ythis->refA.ref->test1.ref->test2.ref != null) clearBackRefJc(&(ythis->refA.ref->test1.ref->test2.refbase));
    ythis->refA.ref->test1.ref->test2.ref = ythis->refA.ref;
    setBackRefJc(&(ythis->refA.ref->test1.ref->test2.refbase)/*addr of ref*/, ythis->refA.ref->test1.ref->test2.ref /*The refed Object as void* */);
    
    activateGarbageCollectorAccess_BlockHeapJc(newObj1);
    activateGarbageCollectorAccess_BlockHeapJc(newObj2);
  }
  _threadContext->stacktrace = stacktrace.previous;
}



void run1_TestGarbageCollector(TestGarbageCollector* ythis, struct ThreadContextJc_t* _threadContext)
{  StacktraceJc stacktrace = {_threadContext->stacktrace, { "run1_TestGarbageCollector", __FILE__, __LINE__} , null}; 
  _threadContext->stacktrace = &stacktrace;
  { /** To test:*/
    if(ythis->refB.ref != null) clearBackRefJc(&(ythis->refB.refbase));
    ythis->refB.ref = ythis->refA.ref->test1.ref;
    setBackRefJc(&(ythis->refB.refbase)/*addr of ref*/, ythis->refB.ref /*The refed Object as void* */);
    
    if(ythis->refA.ref != null) clearBackRefJc(&(ythis->refA.refbase));
    ythis->refA.ref = null;
    
  }
  _threadContext->stacktrace = stacktrace.previous;
}



void finalize_TestGarbageCollector(ObjectJc* yObj, struct ThreadContextJc_t* _threadContext)
{ TestGarbageCollector* ythis = (TestGarbageCollector*)yObj;  //upcasting to the real class.
   StacktraceJc stacktrace = {_threadContext->stacktrace, { "finalize_TestGarbageCollector", __FILE__, __LINE__} , null}; 
  _threadContext->stacktrace = &stacktrace;
  if(ythis->refA.ref != null) clearBackRefJc(&(ythis->refA.refbase));
  if(ythis->refB.ref != null) clearBackRefJc(&(ythis->refB.refbase));
  _threadContext->stacktrace = stacktrace.previous;
}

