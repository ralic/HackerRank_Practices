<html xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:pre="http://www.vishia.de/2006/XhtmlPre" xmlns:xhtml="http://www.w3.org/1999/xhtml" test_rootname="root">
   <test_inputXmlRoot name="local-name(.)"></test_inputXmlRoot>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
      <title>Java2C - Requirements and features</title>
      <link rel="stylesheet" type="text/css" href="htmlstd.css">
   </head>
   <body>
      <h1>Java2C - Requirements and features</h1>
      <p class="standard"><font size="+1"><u>Inhalt</u></font></p>
      <ul>
         <li><a href="#chapter_1">1 Features</a></li>
         <li><a href="#chapter_2">2 Changes from..to revision</a></li>
         <ul>
            <li><a href="#chapter_2.1">2.1 Changes from 0.91 to 0.93</a></li>
            <ul>
               <li><a href="#chapter_2.1.1">2.1.1 Java2C - core</a></li>
               <li><a href="#chapter_2.1.2">2.1.2 Documentation</a></li>
               <li><a href="#chapter_2.1.3">2.1.3 CRuntimeJavalike</a></li>
               <li><a href="#chapter_2.1.4">2.1.4 Examples</a></li>
            </ul>
            <li><a href="#chapter_2.2">2.2 Detect bugs and requirements</a></li>
            <ul>
               <li><a href="#chapter_2.2.1">2.2.1 Detect bugs and requirements of the translation process</a></li>
               <li><a href="#chapter_2.2.2">2.2.2 Detect bugs and requirements in the appearance of generated C-Code</a></li>
               <li><a href="#chapter_2.2.3">2.2.3 Detect bugs and requirements of CRuntimeJavalike</a></li>
               <li><a href="#chapter_2.2.4">2.2.4 Detect bugs and requirements of the whole presentation</a></li>
               <li><a href="#chapter_2.2.5">2.2.5 View to the near future</a></li>
            </ul>
         </ul>
         <li><a href="#chapter_3">3 JcLib or CRuntimeJavalike</a></li>
         <li><a href="#chapter_4">4 Examples</a></li>
         <li><a href="#chapter_5">5 Documentation</a></li>
         <li><a href="#chapter_6">6 Concepts</a></li>
         <ul>
            <li><a href="#chapter_6.1">6.1 Programming concepts</a></li>
            <li><a href="#chapter_6.2">6.2 Differences from C, C++, Java, Solution in Java2C</a></li>
            <li><a href="#chapter_6.3">6.3 The block heap concept and garbage collection</a></li>
            <ul>
               <li><a href="#chapter_6.3.1">6.3.1 Blocks of equal sizes</a></li>
               <li><a href="#chapter_6.3.2">6.3.2 The garbage collector</a></li>
               <ul>
                  <li><a href="#chapter_6.3.2.1">6.3.2.1 Concept of back references</a></li>
                  <li><a href="#chapter_6.3.2.2">6.3.2.2 Using the back reference info for garbage collection</a></li>
                  <li><a href="#chapter_6.3.2.3">6.3.2.3 Optimizations of back-ref-using</a></li>
                  <li><a href="#chapter_6.3.2.4">6.3.2.4 Advantage of auto generation</a></li>
               </ul>
            </ul>
         </ul>
      </ul>
      <hr><a id="w0aaaa" name="chapter_1"></a><a id="w0aaaa" name="1"></a><h2>1 Features</h2><a id="w0aaaab3" name="Topic.Java2C.Features."></a><div class="" id="Topic.Java2C.Features.">
         <p class="debug">Topic:.Java2C.Features.</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <p class="std">You find a german documentation and discussion above this topic at <a href="http://www.vishia.org/Java2C">http://www.vishia.org/Java2C</a>. If you have questions or notes, please mail to hartmut.schorrig@vishia.de.
         </p>
         
         <p class="std">
            <b>Why C and not C++?</b></p>
         
         <ul class="std">
            <li>
               <p class="std">C is nearer to machine code as C++ and therefore better appropriate, if the execution code should be known. It is frequently
                  in embedded control.
               </p>
            </li>
            <li>
               <p class="std">C is supported for all embedded controller, C++ not in any case.</p>
            </li>
            <li>
               <p class="std">In C the functionality of inheritance and dynamic calls (interface concept) is implementable. Because the translator produces
                  the necessary code, it should not be manually written, the necessary extensive complex statements don't be a problem.
               </p>
            </li>
            <li>
               <p class="std">In C++ a dynamical call (virtual method call) is unsafe, if any bug had destroyed user data. Because: The reference to the
                  virtual table is a part of user data. In C this problem is better able to control: The informations about a derivated instance
                  type is only able to store in user data. But some additional tests are possible if safety software is required. This tests
                  need some, but not to much calculation time (some nanoseconds on fast processors). Dynamical calls are used often only in
                  slower threads (milliseconds). Therefore C++ will be a inappropriate choice for safety software, C is appropriate.
               </p>
            </li>
         </ul>
         
         <p class="std">In the table below the features of the Java2C translator and the CRuntimeJavalike are visualized.</p>
         
         <table class="stdTable">
            <tr class="stdTable">
               <td class="stdTable_td">
                  
                  <p class="std_td">Java-feature</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">Implementation in C</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">Remarks</p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  <pre> class MyClass
 { int a;
   MyOther other;
   final int myMethod(...)
   {
   }
</pre></td>
               <td class="stdTable_td">
                  <pre> typedef struct MyClass_t
 { ObjectJc object;
   int a;
   struct MyOther_t* other;
   ...
 }MyClass;
 int myMethod_MyClass(...)
</pre></td>
               <td class="stdTable_td">
                  
                  <p class="std_td">
                     <b>ready</b>, basic feature!
                  </p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  <pre> class MyClass extends BaseClass
 { ...
</pre></td>
               <td class="stdTable_td">
                  <pre> typedef struct MyClass_t
 { BaseClass super;
   ...
</pre></td>
               <td class="stdTable_td">
                  
                  <p class="std_td">
                     <b>ready</b>, inheritance concept is interestedly but not essentially for embedded control. But it is no large expenditure of implementation.
                  </p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  <pre> class MyClass
   implements MyInterface
 { ...
</pre></td>
               <td class="stdTable_td">
                  <pre> struct Mtbl_MyClass_t
 { Mtbl_ObjectJc mtblObjectJc;
   { MT_method_MyInterface*
       implMethod;
     ...
 }mtblMyClass
   ...
</pre></td>
               <td class="stdTable_td">
                  
                  <p class="std_td">
                     <b>ready</b>, The inheritance concept is interestedly but not essentially for embedded control. It is solved as a matter of principle.
                     An interface is represented by a ObjectJc* reference and a Mtbl-struct (method address table) as part of reflection informations.
                     Searching the appropriate table regards the inheritance tree (base class and interfaces). The reflection of the instance type
                     and the Type of interface/baseclass are used as inputs. No reference to jmp addresses is stored in a data area. It is a concept
                     of safety: A data area may be attacked by a software bug of another module. In such cases no influence to program flow should
                     be exert. To optimize accesses inside a method, the reference to the mtbl is stored in the stack.
                  </p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  <pre> obj.getClass();
</pre></td>
               <td class="stdTable_td">
                  <pre> getClass_ObjectJc(obj)
</pre></td>
               <td class="stdTable_td">
                  
                  <p class="std_td">Prio2, The reflection concept is interestedly but not essentially for embedded control. The reflection tables are used to
                     search method tables for the interface concept.
                  </p>
                  
                  <p class="std_td">The reflection concept helps <b>inspecting an embedded control system</b>: Using reflections an access to all internal fields and invoking of internal methods can be done from outside without any
                     additional special programming. At example the access can be done via a network interface (UDP).
                  </p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  <pre> class MyClass
 { void myNotFinalMethod(...)
</pre></td>
               <td class="stdTable_td">
                  <pre> struct Mtbl_MyClass_t
 { ...
</pre></td>
               <td class="stdTable_td">
                  
                  <p class="std_td">
                     <b>ready</b>, It's the same like interface concept, but more simple because a enhanced reference is not need.
                  </p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  <pre> class MyClass
 { ...
   MyClass(...)
   { ref = new OtherClass(args);
</pre></td>
               <td class="stdTable_td">
                  <pre> ref = ctor_MyClass
 ( alloc_MemC(sizeof(MyClass))
 , args
 );
</pre></td>
               <td class="stdTable_td">
                  
                  <p class="std_td">
                     <b>ready</b>. The using of dynamic memory is supported both in the construction phase in embedded real-time software and really dynamically
                     at run time. A garbage collector is implemented.
                  </p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  <pre> class MyClass
 { final OtherClass ref
   = new OtherClass(args);
</pre></td>
               <td class="stdTable_td">
                  <pre> struct MyStruct
 { ...
   OtherClass ref;
 }
 ...
 ctor_MyClass()
 { ctor_OtherClass
   (&amp;ythis-&gt;ref, args
   );
</pre></td>
               <td class="stdTable_td">
                  
                  <p class="std_td">
                     <b>ready</b>. If the reference at class level is final and assigned at class level with the same Class, it is a fix instance. Therefore
                     a embedded struct is realized in C. It is a important basic feature because in C embedded struct are an opportune implementation
                     for nested data.
                  </p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  <pre> class X{ class Inner{...}
</pre></td>
               <td class="stdTable_td">
                  <pre> struct Inner_X_t
 { ... X* outer;
 
</pre></td>
               <td class="stdTable_td">
                  
                  <p class="std_td">
                     <b>ready</b>. Inner classes may be static or not. Non-static classes got a pointer <code>outer</code> which is initialized in ctor. The direct access to elements of the outer class use <code>ythis-&gt;outer-&gt;...</code>.
                  </p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  <pre> final Ifc ref = new Ifc(){...}
</pre></td>
               <td class="stdTable_td">
                  <pre> struct ref_Ifc_t
 { ...}
 ref = ctor_ref_Ifc(...)
 
</pre></td>
               <td class="stdTable_td">
                  
                  <p class="std_td">
                     <b>ready</b>. Anonymous classes are translated to a <code>struct</code> with the name of the reference or with a generated name for the  typical case of the shown <code>final</code> initialization. A more seldom construct is the usage of ... (new Type(param){...}).method()... inside any expression. Than
                     a generated name is assigned to the struct. Any anonymous class is mapped to a named <code>struct</code> in C.
                  </p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  <pre> ref = new MyClass(args);
</pre></td>
               <td class="stdTable_td">
                  <pre> ref = ctor_MyClass
 ( alloc_MemC(sizeof(MyClass))
 , args
 );
</pre></td>
               <td class="stdTable_td">
                  
                  <p class="std_td">
                     <b>ready</b>. In the runtime phase in embedded real-time software no extensively using of dynamic memory should be done. But for special
                     requests like events or temporary Strings, dynamic instances are necessary. To support such, a BlockHeap concept with equals
                     blocks is slated. The dynamic objects should have a limited size. It may be opportune in embedded control.
                  </p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  <pre> Type[] array;
</pre></td>
               <td class="stdTable_td">
                  <pre> Type_AY array;
</pre></td>
               <td class="stdTable_td">
                  
                  <p class="std_td">
                     <b>ready</b>. Arrays can be used at C level as referenced arrays. An array pointer type is defined for any type. It contains head information
                     and the data. Such arrays should instanciated dynamically with any length. The head information contains the length of the
                     array.
                  </p>
                  
                  <p class="std_td">prio2: Only one-dimensional arrays are implemented yet. More as one dimensions are TODO.</p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  <pre> final Type[] array = new Type[123];
</pre></td>
               <td class="stdTable_td">
                  <pre> struct{ ObjectJc object;
         int32 length, ...
         Type data[123]
       } array;
</pre></td>
               <td class="stdTable_td">
                  
                  <p class="std_td">
                     <b>ready</b>. If an Array is fix, it is implemented as embedded instance. The elements of the array may be embedded or referenced. If
                     also the elements are embedded, the array occupies only one memory area inside another struct. It is the commonly used opportune
                     memory model of C programming.
                  </p>
                  
                  <p class="std_td">prio2: Only one-dimensional arrays are implemented yet. More as one dimensions are TODO.</p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  <pre> /**@Java2C=simpleArray;*/
 Type[] array = new Type[123];
</pre></td>
               <td class="stdTable_td">
                  <pre> Type array[123];
</pre></td>
               <td class="stdTable_td">
                  
                  <p class="std_td">
                     <b>ready</b>. Arrays without any head informations are common used in C. If an algorithm is tested well in Java, and the array itself
                     isn't use as Object in container classes, it can be implemented pure directly like C-programmers knows it. The <code>array.length</code> is translated to a macro <code>ARRAYLEN(array)</code> using sizeof mechanism.
                  </p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  <pre> try{...} catch throw
</pre></td>
               <td class="stdTable_td">
                  <pre> STACKTRC_ENTRY("name");
 TRY{...}_TRY
 CATCH(...){...}
 FINALLY{...}
 END_TRY
</pre></td>
               <td class="stdTable_td">
                  
                  <p class="std_td">
                     <b>ready</b>. The try-catch-throw concept is essentially in Java, found in C++ and a convenient and necessary feature in C. The implementation
                     of throw in C is done using the longjmp-concept, known since 1970 and available for all processors. For C++ environments also
                     the try/throw of C++ is useable. See german description at <a href="http://www.vishia.org/Jc/html/Exception_Jc.html">http://www.vishia.org/Jc/html/Exception_Jc.html</a>. There are use some macros to produce a better readable C code. The macros contains simple tests and sets, see <code>ExceptionJc.h</code>.
                  </p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  <pre> String ss = "a" + 5;
</pre></td>
               <td class="stdTable_td">
                  <pre> StringJc ss;
 ss = toString_StringBufferJc
      ( iXJc( ...s0BXJc(
      "a"), 5));
</pre></td>
               <td class="stdTable_td">
                  
                  <p class="std_td">
                     <b>ready</b>. Strings are necessary in embedded control to assembly error messages or such ones. The concatenation of Strings is done
                     with a StringBuilder. The Buffer can be allocated in Heap, in Stack or in a ThreadContext-range. The necessity persistence
                     of the String are controlled by annotations in the Java-Code. If a String doesn't need to be persistent, it doesn't need dynamic
                     memory. Therefore working without dynamic memory is possible. The basic features of <code>java.lang.StringBuilder</code> is implemented.
                  </p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  
                  <p class="std_td">java.lang.String, java.lang.Thread</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">ThreadJc, RunnableJc</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">
                     <b>ready</b>. Multithreading is a basic needfull feature of embedded control. Not all features, especially not ThreadGroup etc. are supported.
                  </p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  
                  <p class="std_td">java.util.List, LinkedList, ArrayList, TreeMap, Container</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">ListJc, LinkedListJc, ArrayListJc</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">Prio1. This features are interestedly and supports the reason to work with java. C don't know a good concept of container.
                     All this features are implemented in C level in CRuntimeJavalike. It should be work together with the Garbage-Collector -
                     BlockHeap- concept, because the Nodes of Lists are managed with them.
                  </p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  
                  <p class="std_td">java.awt, javax.swing</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">nothing</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">
                     <b>not supported</b>. If graphical features should be used with Java style, the using of Virtual Machines for Java for embedded controller should
                     be considered. There are some offers, like <a href="http://aicas.com/jamaica.html">Jamaica-VM</a>. It is possible to connect C routines with Java at the same processor using JNI or localhost-InterProcessComm or at a second
                     processor. It is a good decision using embedded control in connection with PC based software.
                  </p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  
                  <p class="std_td">java.net.Socket</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">InterProcessComm</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">
                     <b>ready</b>. The InterProcessComm implementations in C and Java are adapted together. The socket communication should use this wrapper.
                     It is a concept using Socket communication or other communication ways like serial or DualPortRam, above the java.net.Socket-classes.
                     The InterProcessComm may be the basic concept to connect processors with several programming concepts.
                  </p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  
                  <p class="std_td">java.io</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">FileIOJc.h, FileOutputStream, os_file.h</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">
                     <b>ready</b>. The accesses to the file system are a basic feature in C since anno 1970, but they are lightweightly different. Therefore
                     an OSAL-layer is used to adapt it. The layer above is defined with routines in FileIOJc.h. Basicly requirements of file-handling
                     are complied with them. It is opportune with requirements of embedded control-software.
                  </p>
               </td>
            </tr>
         </table>
      </div><br clear="all"><a id="w0aaab1" name="chapter_2"></a><a id="w0aaab1" name="2"></a><h2>2 Changes from..to revision</h2><a id="w0aaab1b1" name="chapter_2.1"></a><a id="w0aaab1b1" name="2.1"></a><h3>2.1 Changes from 0.91 to 0.93</h3><a id="w0aaab1b1b3" name="Topic.Java2C.changes091_093."></a><div class="" id="Topic.Java2C.changes091_093.">
         <p class="debug">Topic:.Java2C.changes091_093.</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <p class="std">. Date: 2010-12-31</p>
      </div><br clear="all"><a id="w0aaab1b1b4" name="chapter_2.1.1"></a><a id="w0aaab1b1b4" name="2.1.1"></a><h4>2.1.1 Java2C - core</h4><a id="w0aaab1b1b4b3" name="Topic.Java2C.changes091_093.Java2C."></a><div class="" id="Topic.Java2C.changes091_093.Java2C.">
         <p class="debug">Topic:.Java2C.changes091_093.Java2C.</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <p class="std">There was done a lot of work in detail in the last year.</p>
         
         <ul class="std">
            <li>
               <p class="std">bugfix: 2009-10-25 Hartmut: A description of statements were written three times, now fixed. Only short description is got
                  from Java code and transported to the C-code.
               </p>
            </li>
            <li>
               <p class="std">bugfix: 2010-01-24 Hartmut: On super.call() the reference was written with <code>ythis</code>, now <code>(&amp;ythis-&gt;base.super)</code>. Source: SecondPass.java.gen_reference(...)
               </p>
            </li>
            <li>
               <p class="std">chg: 2010-05-14 If a file is to translate because the Java-src is newer, but the file exists, it will be renamed to "...bak".
                  The other choice may be: It have to be deleted! In other way an error while translating left the file unchanged, the error
                  isn't detected and changes are not applied.
               </p>
            </li>
            <li>
               <p class="std">chg: 2010-04-04 The String processing is changed again: Now the calling of <code>toString()</code> or any other routine which returns a String is optimal respectively fast realtime and works without dynamically memory: The
                  String is not copied in a independend buffer, but it is referenced where it is (other than in Java!). The String is copied
                  later when necessary. The behaviour is able to determine with some new annotations in comment, so working without dynamic
                  memory and with restricted usage possibilities but hard realtime is able to establish, in responsibility to the user. The
                  String processing is documented out of the view of the CRumtimeJavalike-library (basics of C-Programming) in german language,
                  see <span class="removedHref">Jc/String_Jc</span>. In that work the behaviour of the Java2C-translator is checked and improved too.
               </p>
            </li>
            <li>
               <p class="std">new/bugfix: 2010-04-11 Hartmut: If an inner type of a class is need calling <code>LocalIdents.getType()</code>, and the environment class was not translated yet, the <code>getLocalIdents()</code> of the environment type was returned <code>null</code>. Now the method <code>JavaSrcTreeFile.getLocalIdents()</code> tests whether the file is translated. It translate it if necessary and returns the correct data.
               </p>
            </li>
            <li>
               <p class="std">new: 2010-04-25 A new idea: If an instance is designated with <code>@java2c=embeddedType:Name</code> than an instance is implemented as embedded instance, also if it is not intitialized, and also, the reference type is a base
                  type. The translator reserves the memory for the given instance type, and handle the reference adequate to the annotaion <code>@java2c=instanceType</code>. It means, in Java a base class or interface may be used, but in C the given type is used without dynamically call of methods.
                  The constructor may be called later, at that moment, where in Java <code>new Type(...)</code> is called. Than a <code>init_ObjectJc(...)</code> and before that a <code>finalize_ObjectJc()</code> is called. A <code>new Type(...)</code> can be called more as one time, the instance were initialized newly. Thats why the <code>finalize</code> is called before. If the instance is referenced, the reference refers the new instance after them. This behaviour is other
                  than in Java. The Java2C-translator may control, whether a reference is used, and it may warn on that (later, TODO). In a
                  embedded software it should be easily comprehansible. This feature were necessary because the instance of a <code>java.IO.FileOutputStream</code> is only possible with given Filename with opened file. Without this feature either a dynamic memory management were obligated
                  or a special wrapper with an open-method were necessary. With this feature the originally Java src-style for such constructs
                  is able to use.
               </p>
            </li>
            <li>
               <p class="std">new: 2010-02-09: If a method returns a non-primitive type, it is a reference. That reference is excluded from the <code>activategGarbageCollection(...)</code>-call before return. It means, the block is not activated for garbage collection. That is important, because the block is
                  footloose just now, not staticly referenced. Its reference is returned in stack, and the block may be used footloose yet.
                  But the calling routine have to call <code>activategGarbageCollection(...)</code> for that block. This is determined by setting the annotation <code>@java2c=return-new</code> for that method. Than the caller stores the reference and activates the block for garbage collection, also if it doesn't
                  use itself. This is the decisive step to enable the working of garbage collection in a higher priority as other threads. Elsewhere
                  if a block war activated for garbage collection, and it was found as 'non-used', but it is used as stack-referenced, it would
                  be freed wrongly.
               </p>
            </li>
            <li>
               <p class="std">new: 2010-05-15: The check of parameter in the routine ClassData.searchMethod() uses a score. The method, which uses less
                  conversion of parameter, wins. It is important to select the appropriate method. A method whith variable arguments have the
                  lowest score. The problem is found while testing LogMessage.
               </p>
            </li>
            <li>
               <p class="std">new: 2010-0612: Initial values were written as initial values in C too. Changed in GenerateClass.gen_variableDefinition(...).
                  The problem is: Java accepts definition of variable inside the block, C only at begin. If the value is const, it is set on
                  begin of the block. If it is non-const, the order of execution have to be regarded. Therefore a initializing at begin of block
                  may be fault, it isn't done, instead the setting of the value at the correct position in the thread of code.
               </p>
            </li>
            <li>
               <p class="std">new: 2010-0612: Methods with variable argument list are stored with <code>keyname#*</code> only one time instead more as one for all imaginable number of parameters. Therewith the usage of stc-file for example for
                  <code>LogMessageFW.sendMsg(...)</code> is possible. In the stc-file it is written with <code>... name</code> as the last parameter.
               </p>
            </li>
            <li>
               <p class="std">new:2010-0725: The stc-File-parsing is redesigned. See <span class="removedHref">java2c:ReadStructure</span>. The content is parsed firstly, and then evaluate. It is important for inner classes. They should be known first before evaluate
                  the content of other elements which uses it. A second output of structure of a <span class="removedHref">java2c:ClassData</span>-Definition is written if a sub-directory <code>stcCmp</code> exists at level of source directory of a read stc-file. It is to compare, for test, whether the parsed content is equal to
                  originally written one. Only for test. If this directory doesn't exist, no second output will be written. The older version
                  wrote a <code>.sec..file any time, but in the last versions without content.</code></p>
            </li>
            <li>
               <p class="std">new:2010-0807: The package replacement and the creation of <span class="removedHref">java2c:JavaSrcTreeFile</span> is changed respectively corrected. The older variant assumes, that all Java-files should be found as Java-files, though they
                  are not scheduled to translate. For example, if a <code>org/vishia/util/StringPart</code> is used, it have to be found in the Java-sourcepath of the configuration of Java2C-translation, though it is present in the
                  translated form (<code>J1c/StringPartJc.c</code>). Now, if a Java-Type is used and its package-replacement is given, the associated stc-file is found, though a affiliated
                  Java-file is not existing in the current translation focus. That is better and more practical.
               </p>
            </li>
            <li>
               <p class="std">new:2010-0807: The package path and the package replacement are corrected:</p>
            </li>
            <li>
               <p class="std">In <span class="removedHref">java2c:CRuntimeJavalikeClassData</span>, all standard packages are created. It is for example <code>java/io</code>, <code>java/util</code>, but <code>org/vishia/bridgeC</code> and <code>org/vishia/util</code> too.
               </p>
            </li>
            <li>
               <p class="std">The package- and javafile-replacement for all files, which are contained in the CRuntimeJavalike, were set there too.</p>
            </li>
            <li>
               <p class="std">But the concretely contents of the java-files respectively there representation in the CRuntimeJavalike in C are contained
                  in stc-files. The stc-files should be parsed, if the types are used. It need a piece of calculation time. But the parsing
                  needs less time (milliseconds). The advantage is, the content is adjustable at text-level. If a method is changed in the CRuntimeJavalike-C-library,
                  the translator shouldn't be changed. Only the stc-file should be adapted. The stc-file is a mapping of structure in relation
                  to the header-files.
               </p>
            </li>
            <li>
               <p class="std">The standard types and simple structures are definded in the <span class="removedHref">java2c:CRuntimeJavalikeClassData</span> still.
               </p>
            </li>
            <li>
               <p class="std">new:2010-0826: Anonymous inner classes are implemented now. It was complex to do so, but anonymous classes are interesting
                  for a good design of Java-sources. In C automatically named classes are build. The constructor is derived from the called
                  constructor of the base class. Hint: Anonymous classes are built in Java with the syntax 'new Type(param){ derived content
                  of class };'
               </p>
            </li>
            <li>
               <p class="std">new: 2010-0826: All methods should be found now. Previously, a non-found-method are created and marked as "/*unknown method*/".
                  It means, now the stc-files have to be completely. If a method isn't found, a detailed error message is given.
               </p>
            </li>
            <li>
               <p class="std">new: 2010-0826: ClassData contains the information 'sourceOfClassData' to evaluate, where and when the ClassData are created.
                  It contains either the path of the stc-file or of the Java-file. Or "CRuntimeJavalike-std" is contained there, if the ClassData
                  are created in <span class="removedHref">java2c:CRuntimeJavalike</span>.
               </p>
            </li>
            <li>
               <p class="std">new: 2010-12-05: embedded types are handled more correctly, see <span class="removedHref">java2c:Docu.G_Instantiation#g7_embeddedTypes()</span>. Embedded types should be defined as final in Java. Because-they have its mem-space in C. There are not referenced in C.
               </p>
            </li>
            <li>
               <p class="std">new: 2010-12-01: The 2. pass of the translation is running after the first pass of the file, not only after all first passes.
                  It has an advantage if some errors of translation occurs. If a second pass war run successfully, it is finished.
               </p>
            </li>
            <li>
               <p class="std">new: 2010-12: Some error messages are improved. For example if a method is missed in an stc-file, the signature of the method
                  is shown in the error messages. It may be a hand written stc-file, which can be completed with this informations. The source
                  of the gotten ClassData in the translation process is stored in the ClassData therefore.
               </p>
            </li>
            <li>
               <p class="std">new: 2010-12: const as attribute of a class in an stc-file: The class-pointer is designated as Type const* this then. A const
                  instance is built-able in C (read-only methods). ClassData.isConstant as attribute.
               </p>
            </li>
            <li>
               <p class="std">new: 2010-12: Persistence of referenced instances, especially used for Strings: The modeStatic in FieldData is used now to
                  designate non-persistent fields using a 'r' as char. It is set if @java2c=nonPersistent is annotated.
               </p>
            </li>
            <li>
               <p class="std">new: 2010-12: A new class org/vishia/util/Java4C was created. It contains annotation-interfaces. There are not used yet, but
                  in preparation. It is better to use annotation classes than annotations in the description/comment. It helps for example in
                  Eclipse using word-completion. That annotation classes should be established in the next version.
               </p>
            </li>
            <li>
               <p class="std">new: 2010-12-31: abstract classes don't produce now method tables. The first class where it was detected was ByteDataAccess.
                  An abstract method hasn't an implementation, therefore the pointer to the method doesn't exist. The method table of an abstract
                  class is never used because it is never the type of an instance.
               </p>
            </li>
         </ul>
      </div><br clear="all"><a id="w0aaab1b1b5" name="chapter_2.1.2"></a><a id="w0aaab1b1b5" name="2.1.2"></a><h4>2.1.2 Documentation</h4><a id="w0aaab1b1b5b3" name="Topic.Java2C.changes091_093.docu."></a><div class="" id="Topic.Java2C.changes091_093.docu.">
         <p class="debug">Topic:.Java2C.changes091_093.docu.</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <p class="std">Some things added.</p>
      </div><br clear="all"><a id="w0aaab1b1b6" name="chapter_2.1.3"></a><a id="w0aaab1b1b6" name="2.1.3"></a><h4>2.1.3 CRuntimeJavalike</h4><a id="w0aaab1b1b6b3" name="Topic.Java2C.changes091_093.Jc."></a><div class="" id="Topic.Java2C.changes091_093.Jc.">
         <p class="debug">Topic:.Java2C.changes091_093.Jc.</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <ul class="std">
            <li>
               <p class="std">chg: 2010-01-25 Hartmut: ReflectionJc.c: An access to a remote memory (at example via FPGA to DSP) was established. Not necessary
                  yet for Java2C.
               </p>
            </li>
            <li>
               <p class="std">bugfix: 2010-04-09 Hartmut: BlockHeapJc_GarbageCol.c:testBlockCluster_GarbageCollectorJc(...) and BlockHeapJc_GarbageCol.c:allocObject_IIs_BlockHeapJc(...):
                  If the heap is overflowed (empty), the <code>ythis-&gt;lastFreeBlock</code> should set to null too. If any block is freed, and <code>ythis-&gt;firstFreeBlock == null</code>, than this is the first now available block. The bug was, if the heap was overflowed, after them freed blocks are not available
                  any time. The situation was noticeable especially if the garbage collector was running because no block are available calling
                  <code>alloc_ObjectJc(...)</code>.
               </p>
            </li>
            <li>
               <p class="std">bugfix: 2010-04-09 Hartmut: BlockHeapJc_GarbageCol.c, <code>runUserCalledGc_BlockHeapJc(...)</code>: A running garbage collection was aborted setting <code>bAbortTestBecauseUserCall</code> to <code>true</code>. But this setting had effect also to the current call, it was aborted too. Now the method <code>garbageCollection_BlockHeapJc(bool bUserCall)</code> knows, whether it is a user call or a normal call.
               </p>
            </li>
            <li>
               <p class="std">new: 2010-05-23 Hartmut: Fwc/LogMessage_FW is enhanced with 2 virtual methods: MT_sendMsg_LogMessageFW and MT_sendMsg_time_LogMessageFW.
                  Though a direct virtual call using the method table can be used instead a call of sendMsg_Szv_LogMessageFW(...) which is implemented
                  in LogMessage_FW and calls <span class="removedHref">Jc/getMtbl_ObjectJc(...)</span>. The new possibility is faster!
               </p>
            </li>
            <li>
               <p class="std">chg: 2010-07-03 Hartmut: The size of blocks in the BlockHeap is defined now as a constant SIZEBLOCK_BlockHeapJc in the file
                  fw_platform_conventions.h. A variable size of blocks in several instances of Blockheap isn't supported anymore. It was a too
                  complex concept, which handicaps a fast calculation from an address inside a block to the start of block. Mostly, the memory
                  is not a strong limited ressource, so fine tunings of block size to save memory is less times necessary as the save of calculation
                  time.
               </p>
            </li>
            <li>
               <p class="std">bugfix: 2010-08-16 Hartmut: The Macro SETREFJc has used the argument OBJP twice, so the code is called twice, with side effect
                  of double allocation of memory.
               </p>
            </li>
            <li>
               <p class="std">new: 2010-08-15 Hartmut: Some corrections on messages of garbageCollection_BlockHeapJc().</p>
            </li>
            <li>
               <p class="std">new: 2010-12: Improvement of String processing. The String processing is able to use especially without garbage collection,
                  the necessity of persistence of String can be designated in Java2C via annotations or in C direct with usage of the proper
                  methods.
               </p>
            </li>
            <li>
               <p class="std">new: 2010-12: New type ByteStringJc. It is adequat to StringJc, but a ByteStringJc is a byte-container in any case. A StringJc
                  may be a container of UTF-16 chars too (if it is need).
               </p>
            </li>
            <li>
               <p class="std">new: 2010-10: The OSAL-adaption is done for Linux. It is not ready yet and not tested in all features, but it is started to
                  do.
               </p>
            </li>
            <li>
               <p class="std">new: 2011-01-01: The order of elements in <code>OS_ValuePtr</code> is changed, now it is renamed to <code>OS_PtrValue</code>. It needs an adaption in some files, maybe also in user-spaces, and for all os-specific <code>os_types_def.h</code>-files. The reason for this change: There is not a difference between access to the pointer for enhanced references. It simplifies
                  the handling in an inspector tool, which works with symbolic access to all variables of a controller software. The pointer
                  is the first element now.
               </p>
            </li>
            <li>
               <p class="std">new: 2010-12: Some checks and improvements are done.</p>
            </li>
         </ul>
      </div><br clear="all"><a id="w0aaab1b1b7" name="chapter_2.1.4"></a><a id="w0aaab1b1b7" name="2.1.4"></a><h4>2.1.4 Examples</h4><a id="w0aaab1b1b7b3" name="Topic.Java2C.changes091_093.examples."></a><div class="" id="Topic.Java2C.changes091_093.examples.">
         <p class="debug">Topic:.Java2C.changes091_093.examples.</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <p class="std">The <em>PositionControl</em>-Example is completed with a graphical output now. You can see how the calculation works. The graphic representation is a
            Java-program, working with SWT-Graphic with an own concept of building the GUI-application. This concept is used only here.
            It is not described extensively here.
         </p>
         
         <p class="std">The data-communication between the <em>PositionControl</em>-programm and the GUI based on a Socket communication using the <em>InterProcessComm</em>-Interface, which is provided in C as in Java.
         </p>
         
         <p class="std">The <em>testAllConcepts</em>-examples are completed especially with String checks.
         </p>
      </div><br clear="all"><a id="w0aaab1b2" name="chapter_2.2"></a><a id="w0aaab1b2" name="2.2"></a><h3>2.2 Detect bugs and requirements</h3><a id="w0aaab1b2b3" name="Topic.Java2C.TODO."></a><div class="" id="Topic.Java2C.TODO.">
         <p class="debug">Topic:.Java2C.TODO.</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <p class="std">.</p>
      </div><br clear="all"><a id="w0aaab1b2b4" name="chapter_2.2.1"></a><a id="w0aaab1b2b4" name="2.2.1"></a><h4>2.2.1 Detect bugs and requirements of the translation process</h4><a id="w0aaab1b2b4b3" name="Topic.Java2C.TODO.bugsTranslator."></a><div class="" id="Topic.Java2C.TODO.bugsTranslator.">
         <p class="debug">Topic:.Java2C.TODO.bugsTranslator.</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <ul class="std">
            <li>
               <p class="std">calling of methods from super-superclasses or from interfaces of superclasses were wrong anyway. In access to method table
                  the nested method table is absent: at ex. <code>mtthis-&gt;Ifc_Test.processIfcMethod(...)</code> is produced, correct is <code>mtthis-&gt;ImplIfc_Test.Ifc_Test.processIfcMethod(...)</code> It should be able to fix with small effort! - 2011-01-02: It may be fixed now- to test.
               </p>
            </li>
            <li>
               <p class="std">
                  <code>apppend_L_StringBuffer(..., ObjectJc*)</code> is not implemented yet, the call of <code>toString(...)</code> from any Object is not tested.
               </p>
            </li>
            <li>
               <p class="std">for-loop-variant using iterator isn't implemented yet.</p>
            </li>
            <li>
               <p class="std">The [] for array type should be arranged also after the indentifier, not only after the type. Support 'long array[]', not
                  only 'long[] array'. This bug isn't fixed yet.
               </p>
            </li>
            <li>
               <p class="std">If StringJc is generated in the reflection, it isn't an enhanced reference!</p>
            </li>
            <li>
               <p class="std">bug100514a: (new TestgarbageCollector()).test(); doesn't work</p>
            </li>
            <li>
               <p class="std">unnamed inner classes (anonymous) - only one class is admissibile - because algorithm to build the name.</p>
            </li>
         </ul>
      </div><br clear="all"><a id="w0aaab1b2b5" name="chapter_2.2.2"></a><a id="w0aaab1b2b5" name="2.2.2"></a><h4>2.2.2 Detect bugs and requirements in the appearance of generated C-Code</h4><a id="w0aaab1b2b5b3" name="Topic.Java2C.TODO.genCCode."></a><div class="" id="Topic.Java2C.TODO.genCCode.">
         <p class="debug">Topic:.Java2C.TODO.genCCode.</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <p class="std">This part describes, which changes should be done in the form of generated C-Code</p>
         
         <ul class="std">
            <li>
               <p class="std">bug_genCC912_01 If StringJc is generated in the reflection, it isn't an enhanced reference! ?check whether is fixed?</p>
            </li>
         </ul>
      </div><br clear="all"><a id="w0aaab1b2b6" name="chapter_2.2.3"></a><a id="w0aaab1b2b6" name="2.2.3"></a><h4>2.2.3 Detect bugs and requirements of CRuntimeJavalike</h4><a id="w0aaab1b2b6b3" name="Topic.Java2C.TODO.bugsCRJ."></a><div class="" id="Topic.Java2C.TODO.bugsCRJ.">
         <p class="debug">Topic:.Java2C.TODO.bugsCRJ.</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <ul class="std">
            <li>
               <p class="std">The Linux implementation for the OSAL-Layer is not ready yet.</p>
            </li>
         </ul>
      </div><br clear="all"><a id="w0aaab1b2b7" name="chapter_2.2.4"></a><a id="w0aaab1b2b7" name="2.2.4"></a><h4>2.2.4 Detect bugs and requirements of the whole presentation</h4><a id="w0aaab1b2b7b3" name="Topic.Java2C.TODO.bugsDownload."></a><div class="" id="Topic.Java2C.TODO.bugsDownload.">
         <p class="debug">Topic:.Java2C.TODO.bugsDownload.</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <ul class="std">
            <li>
               <p class="std">Some Linux-shell-scripts to translated are present, but they are not tested in the current version.</p>
            </li>
         </ul>
      </div><br clear="all"><a id="w0aaab1b2b8" name="chapter_2.2.5"></a><a id="w0aaab1b2b8" name="2.2.5"></a><h4>2.2.5 View to the near future</h4><a id="w0aaab1b2b8b3" name="Topic.Java2C.TODO.future."></a><div class="" id="Topic.Java2C.TODO.future.">
         <p class="debug">Topic:.Java2C.TODO.future.</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <ul class="std">
            <li>
               <p class="std">LinkedList etc. (Container) should be implemented in the near future. Some basics for that are done. A ConcurrentLinkedQueue
                  is present in the CRuntimeJavalike, it works since 2007. But it isn't full integrated in Java2C.
               </p>
            </li>
            <li>
               <p class="std">The garbage collector should be tested explicitely, still to do. I assume, it works.</p>
            </li>
         </ul>
      </div><br clear="all"><a id="w0aaab2" name="chapter_3"></a><a id="w0aaab2" name="3"></a><h2>3 JcLib or CRuntimeJavalike</h2>
      <div class="">
         <div class="">
            <p class="">The CRuntimeJavalike is the runtime system of the C-translated Java sources. It contains some classes, which are part of <code>java.lang</code> or <code>java.util</code>. Some of implementations are made regarding C-typically things.
            </p>
         </div>
      </div><br clear="all"><div class="">
         <div class="">
            <p class="">The JcLib based on a OSAL-interface (Operation System Adapting Layer). That OSAL should be adapted to the given RTOS. The
               download contains an adaption to MS-Windows using API-calls. It may be worked under typically Windows-Versions, started with
               Win-NT. It is tested under XP.
            </p>
         </div>
      </div><br clear="all"><div class="">
         <div class="">
            <p class="">The CRuntimeJavalike is documented in German language yet only. See <a href="http://www.vishia.org/Jc/index.html">CRuntimeJavalike</a>.
            </p>
         </div>
      </div><br clear="all"><a id="w0aaab3" name="chapter_4"></a><a id="w0aaab3" name="4"></a><h2>4 Examples</h2><a id="w0aaab3b3" name="Topic.Java2C.Examples."></a><div class="" id="Topic.Java2C.Examples.">
         <p class="debug">Topic:.Java2C.Examples.</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <p class="std">
            <a href="examplePositionControl.html">Java2C-download:html/examplePositionControl.html</a>: A praxis-oriented example. Translated Java-sources to C up to now with a Visual-Studio-6-Project (running under windows).
            In the future: Eclipse-project for Linux too. See local folder <a href="examples/positionControl">Java2C-download:html/examples/positionControl</a></p>
         
         <p class="std">
            <a href="http://www.vishia.org/Java/docuSrcJavaSrc/org/vishia/java2C/test/TestAllConcepts.html">javasrc:_org/vishia/java2C/test/TestAllConcepts</a>: Java classes translated to C. See local folder <a href="../examples/testAllConcepts">Java2C-download:examples/testAllConcepts</a></p>
      </div><br clear="all"><a id="w0aaab4" name="chapter_5"></a><a id="w0aaab4" name="5"></a><h2>5 Documentation</h2><a id="w0aaab4b3" name="Topic.Java2C.Documentation."></a><div class="" id="Topic.Java2C.Documentation.">
         <p class="debug">Topic:.Java2C.Documentation.</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <ul class="std">
            <li>
               <p class="std">
                  <a href="http://www.vishia.org/Java/docuSrcJavaSrc/org/vishia/java2C/Docu.html">javasrc:_org/vishia/java2C/Docu</a>,
               </p>
            </li>
            <li>
               <p class="std">
                  <a href="http://www.vishia.org/Java/docuSrcJavaSrc/org/vishia/java2C/test/TestAllConcepts.html">javasrc:_org/vishia/java2C/test/TestAllConcepts</a>,
               </p>
            </li>
            <li>
               <p class="std">
                  <a href="http://www.vishia.org/Java/docuSrcJavaSrc/org/vishia/java2C/test/TestThread.html">javasrc:_org/vishia/java2C/test/TestThread</a>,
               </p>
            </li>
            <li>
               <p class="std">
                  <a href="http://www.vishia.org/Java/docuSrcJavaSrc/org/vishia/java2C/Java2C.html">javasrc:_org/vishia/java2C/Java2C</a>,
               </p>
            </li>
            <li>
               <p class="std">
                  <a href="http://www.vishia.org/Java/docuSrcJavaSrc/org/vishia/java2C/ClassData.html">javasrc:_org/vishia/java2C/ClassData</a>,
               </p>
            </li>
            <li>
               <p class="std">
                  <a href="http://www.vishia.org/Java/docuSrcJavaSrc/org/vishia/java2C/LocalIdents.html">javasrc:_org/vishia/java2C/LocalIdents</a>,
               </p>
            </li>
            <li>
               <p class="std">
                  <a href="http://www.vishia.org/Java/docuSrcJavaSrc/org/vishia/java2C/SecondPass.html">javasrc:_org/vishia/java2C/SecondPass</a>,
               </p>
            </li>
            <li>
               <p class="std">
                  <a href="http://www.vishia.org/Java/docuSrcJavaSrc/org/vishia/java2C/StatementBlock.html">javasrc:_org/vishia/java2C/StatementBlock</a>,
               </p>
            </li>
         </ul>
      </div><br clear="all"><a id="w0aaab5" name="chapter_6"></a><a id="w0aaab5" name="6"></a><h2>6 Concepts</h2>
      <div class="">
         <div class="">
            <p class="">See org/vishia/Java2C/Docu.java. This file contains detaild descriptions.</p>
         </div>
      </div><br clear="all"><a id="w0aaab5b2" name="chapter_6.1"></a><a id="w0aaab5b2" name="6.1"></a><h3>6.1 Programming concepts</h3><a id="w0aaab5b2b3" name="Topic.Java2C.swConceptsInCentury."></a><div class="" id="Topic.Java2C.swConceptsInCentury.">
         <p class="debug">Topic:.Java2C.swConceptsInCentury.</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <ul class="std">
            <li>
               <p class="std">
                  <b>1955</b>: <b>COBOL</b>, Fortran: <b>High level Language Programming</b></p>
            </li>
            <li>
               <p class="std">
                  <b>1975</b>: <b>C</b> (Algol, Pascal): <b>Structural Programming</b></p>
            </li>
            <li>
               <p class="std">
                  <b>1995</b>: <b>Java</b> (UML): <b>Object Oriented Programming</b> (C++ is not a new concept, only the application of OOP to C with some additional ideas)
               </p>
            </li>
            <li>
               <p class="std">
                  <b>2015</b>: commonly using of dynamic programming languages? Functional Programming as new concept after OOP?
               </p>
            </li>
         </ul>
         
         <p class="std">All programming language are still in use.</p>
      </div><br clear="all"><a id="w0aaab5b3" name="chapter_6.2"></a><a id="w0aaab5b3" name="6.2"></a><h3>6.2 Differences from C, C++, Java, Solution in Java2C</h3><a id="w0aaab5b3b3" name="Topic.Java2C.CvsJavaImplinJava2C."></a><div class="" id="Topic.Java2C.CvsJavaImplinJava2C.">
         <p class="debug">Topic:.Java2C.CvsJavaImplinJava2C.</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <table class="stdTable">
            <tr class="stdTable">
               <td class="stdTable_td">
                  
                  <p class="std_td">topic</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">C</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">C++</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">Java</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">Solution in Java2C</p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  
                  <p class="std_td">classes</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">manually with struct and associated C-routines</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">basic concept</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">basic concept</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">struct and associated C-routines with a fix schema</p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  
                  <p class="std_td">packages</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">no, unified global names.</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">namespaces as possibility of solution (?)</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">basic concept</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">definition of alternative C-names of classes (prefix, postfix) to keep unified names.</p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  
                  <p class="std_td">extension of classes</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">struct in struct, manually</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">basic concept</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">basic concept</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">struct in struct with a fix schema</p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  
                  <p class="std_td">interfaces, dynamic call</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">manually, function-pointer</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">using class with abstract methods</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">basic concept</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">dynamic call tables with a fix schema</p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  
                  <p class="std_td">common base class for common features of all classes</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">unknown, manual solutions</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">unknown, manual solutions</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">basic concept: Object</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">basic concept ObjectJc, but it is shrinking useable.</p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  
                  <p class="std_td">inner classes</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">manually possible</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">only classes like static in Java, elsewhere manually</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">access to outer class without programming effort. Is it a ObjectOriented Conecpt? It is a visibleness concept of nested structures!
                     It is well useable.
                  </p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">implented with outer-&gt;</p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  
                  <p class="std_td">Container</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">No standard solution, some reuseable libs</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">The Standard Template Library, but extensively using of dynamical memory, therefore often improperly for embedded solutions.</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">java.util</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">LinkedListJc, ArrayListJc, etc. using BlockHeapJc-Concept for fast realtime memory management.</p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  
                  <p class="std_td">String-processing</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">zero-terminated strings as basicly idea, sprintf(...), but <b>unsafely</b> because length of strings are unpredictably.
                  </p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">std::string, but extensively using of dynamical memory, therefore often improperly for embedded solutions. Often using of
                     C-concepts with there unsafetyness.
                  </p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">basic concept String, extensively using of dynamical memory while concatenating strings. Therefore safe! Dynamic memory handling
                     fast!
                  </p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">StringJc, 2 Solutions: a) Without dynamic memory using StringBuilder-Buffer, but safe! Checks the persistence. b) Problem
                     of temorary memory soluted with block heap concept.
                  </p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  
                  <p class="std_td">dynamic memory</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">malloc(), but often using static memory because memory leak problem. Problem of management of usage of instances - dangling
                     pointer and memory-glutton.
                  </p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">new(), memory leak problem is the same like C. Who calls delete()?</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">Garbage Collection, managed also the memory segmentation, therefore no memory leaks. But often not for hard realtime.</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">BlockHeapJc-concept with blocks with same size, only for small data portions (temporary strings, event-data, nodes for LinkedList).
                     Interrupt-able Garbage Collector for the BlockHeap.
                  </p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  
                  <p class="std_td">static memory</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">baisc concept, either malloc() at startup-time or static variables. embedded structs.</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">same like C</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">no concept, possible new at startup-time, but not vulgarizes, JTRES: new concept of immortal memory.</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">same like C, especially support of building of embedded struct on</p>
                  <pre> Type ref = new Type();
</pre>
                  <p class="std_td">if Type is final.</p>
                  
                  <p class="std_td">Orientation of new at startup-time or static memory in C-sources outside Java2C-translated code.</p>
               </td>
            </tr>
            <tr class="stdTable">
               <td class="stdTable_td">
                  
                  <p class="std_td">Multi-Threading</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">No concept, special operation system support necessary</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">same like C, some special libraries</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">basic concept, java.lang.Thread, synchronized, Object.wait, java.util.concurrent etc.</p>
               </td>
               <td class="stdTable_td">
                  
                  <p class="std_td">basic concept, ThreadJc, ConcurrentLinkedListJc etc., fix os-interface to adapt to any operation system: OSAL-layer.</p>
               </td>
            </tr>
         </table>
      </div><br clear="all"><a id="w0aaab5b4" name="chapter_6.3"></a><a id="w0aaab5b4" name="6.3"></a><h3>6.3 The block heap concept and garbage collection</h3><a id="w0aaab5b4b3" name="Topic.Java2C.BlockHeapConcept."></a><div class="" id="Topic.Java2C.BlockHeapConcept.">
         <p class="debug">Topic:.Java2C.BlockHeapConcept.</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <p class="std">In hard realtime long-running systems the using of dynamic allocated memory isn't allowed often. The reason is the hazard
            of appearance of memory leaks. Memory is allocated and freed to any times in any allocated sizes. An algorithm to sort the
            allocated areas can't be run because it need non interrupted CPU time to work.
         </p>
         
         <p class="std">But in more complexly algorithms a usage of dynamic memory is desirable. Using Java it is more suggesting to do so. At example:</p>
         
         <ul class="std">
            <li>
               <p class="std">The assembling of a textual output with some informations need a buffer. In C the using of <code>sprintf</code> is a decision. But the buffer should be supplied or existing.
               </p>
            </li>
            <li>
               <p class="std">Events in a statemachine- or event driven system often needs dynamic allocated memory for itself or for there data.</p>
            </li>
            <li>
               <p class="std">In C or C++ without using dynamic memory a self-made memory management for special cases is implemented often. But this implementations
                  are user specific though it is a system requirement. It is an effort in the users software.
               </p>
            </li>
         </ul>
         
         <p class="std">Another topic regarding Java-usage is the garbage collector. A typical C or C++ implementation uses malloc or new and the
            opposite call of free or delete. But if data are interchanged between modules, one module allocated the memory spaces and
            another module or more as one another module use it. Which module should delete it?
         </p>
         
         <p class="std">The answer for Java-like programming with hard realtime long running systems is the BlockHeap-Concept. It combines both requirements,
            the prevention of memory leaks and the garbage collection.
         </p>
         
         <p class="std">A base idea is, that a dynamically required memory is not a large memory. All main data should be instantiated statically.
            Dynamically required data are only small pieces of data: A buffer for textual assembling, a buffer for new event data, or
            such ones.
         </p>
      </div><br clear="all"><a id="w0aaab5b4b4" name="chapter_6.3.1"></a><a id="w0aaab5b4b4" name="6.3.1"></a><h4>6.3.1 Blocks of equal sizes</h4><a id="w0aaab5b4b4b3" name="Topic.Java2C.BlockHeapConcept.."></a><div class="" id="Topic.Java2C.BlockHeapConcept..">
         <p class="debug">Topic:.Java2C.BlockHeapConcept..</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <p class="std">Therefore the BlockHeap works with blocks with equal size. If any dynamically memory is required, a whole block is occupied.
            It is not so effective in memory using, but the kilobytes of available memory are not the first problem. In fine tuning there
            are supported two block sizes: also small blocks inside a normal block, and third a blocksize for nodes of LinkedList, TreeMap
            etc.
         </p>
         
         <p class="std">The BlockHeap management are able to instantiate more as one time. Therewith a independent using of blocks is possible. A
            outreaching usage of blocks from one BlockHeap management instance don't block the other functionality.
         </p>
      </div><br clear="all"><a id="w0aaab5b4b5" name="chapter_6.3.2"></a><a id="w0aaab5b4b5" name="6.3.2"></a><h4>6.3.2 The garbage collector</h4><a id="w0aaab5b4b5b3" name="Topic.Java2C.BlockHeapConcept.."></a><div class="" id="Topic.Java2C.BlockHeapConcept..">
         <p class="debug">Topic:.Java2C.BlockHeapConcept..</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <p class="std">The garbage collector is a basic concept in Java and it should be worked also in C-translated parts. The garbage collector
            is based on the BlockHeap-Concept.
         </p>
      </div><br clear="all"><a id="w0aaab5b4b5b4" name="chapter_6.3.2.1"></a><a id="w0aaab5b4b5b4" name="6.3.2.1"></a><h5>6.3.2.1 Concept of back references</h5><a id="w0aaab5b4b5b4b3" name="Topic.Java2C.BlockHeapConcept..."></a><div class="" id="Topic.Java2C.BlockHeapConcept...">
         <p class="debug">Topic:.Java2C.BlockHeapConcept...</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <p class="std">To detect whether a block of the BlockHeap is used, it should be known if references to it are existing. The Blockheap works
            with backward references:
         </p>
         
         <p class="std">From all references to blocks of a BlockHeap backward references are noted inside the appropriate Block of the BlockHeap.
            By storing a reference the appropriated back reference from the block to the using reference should be set. This work is done
            by calling
         </p>
         <pre> bool setBackRefJc(ObjectRefValuesJc* refbase, void const* src);
</pre>
         <p class="std">where refbase is the memory address of the reference, from member refbase, and src is the object which is referenced and which
            is located in any block of any blockheap. The memory address of src needn't be the start of the block, it may an address inside
            a block. At example it may be a reference to an embedded struct or to a part of a string.
         </p>
         
         <p class="std">The algorithm of <code>setBackRefJc()</code> detects first, to which heap and to which block in the heap the src is appendant. This is a simple address comparing with
            all known heaps (there are about 1..10 in a users application) and a simple mask of the address, because each block has a
            size of power of two. It is possible, that <code>src</code> isn't a reference to a block. Than no action is done.
         </p>
         
         <p class="std">With knowledge of the correct BlockHeap manager and the block, the back reference to the reference can be set into the block.
            The setting of back-refs needs a few instruction time, but not much one. In the block there is a array of back references.
            Typically 1..10 back references can be stored. If there are more, the effort is little more, because the back references need
            an own block in the Blockheap. But this is not typical. The index of the back reference array element is stored in the enhanced
            reference, inside the element <code>refbase</code>. So a reference <b>knows</b>, whether and where it has a back reference. It may be also of note in test or debug situations.
         </p>
         
         <p class="std">If a reference is changed, set to null or removed, the back reference have to be deleted. This work is done by calling</p>
         <pre> bool clearBackRefJc(ObjectRefValuesJc* refbase);
</pre>
         <p class="std">Because the index to the back reference is known, this is a fast access.</p>
      </div><br clear="all"><a id="w0aaab5b4b5b5" name="chapter_6.3.2.2"></a><a id="w0aaab5b4b5b5" name="6.3.2.2"></a><h5>6.3.2.2 Using the back reference info for garbage collection</h5><a id="w0aaab5b4b5b5b3" name="Topic.Java2C.BlockHeapConcept..."></a><div class="" id="Topic.Java2C.BlockHeapConcept...">
         <p class="debug">Topic:.Java2C.BlockHeapConcept...</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <p class="std">The back reference contains the memory address of the reference to the block. The reference may be located in another block
            of a BlockHeap, or it is a reference from outside. <em>Outside</em> means, it is from static allocated memory, or possible from a reference in the stack. All references are so named <em>enhanced reference</em>s, containing the reference (pointer in C) and the additional info <em>refbase</em>.
         </p>
         
         <p class="std">If a reference comes from outside, the block is used!</p>
         
         <p class="std">If a reference comes from another block of a BlockHeap, it comes from <em>inside</em>. That is a dynamically allocated memory location, also to treat by GC. Thereby it is possible that this block is not referenced
            from anywhere. The garbage collector assembles all blocks that are referencing together, and test them. It is a <em>cluster of blocks</em>. If no outside references to any block of the cluster are found, there are only internal dangling references. The blocks
            are not in use. This blocks should be freed. In normally, there are a less number of blocks per cluster, 2 or 3... but it
            is possible it's more.
         </p>
         
         <p class="std">
            <b>Abort GC if the referencing situation is changed</b></p>
         
         <p class="std">But a thread timing effect maybe: At example A and B references it together. B is referenced from outside. The GC recognizes,
            A is not used from outside, B will be attempted to test.
         </p>
         <pre>                  A &lt;----&gt; B &lt;---outside
</pre>
         <p class="std">Now a higher prior thread interrupts the GC, and changes the reference situation to</p>
         <pre>   outside -----&gt; A &lt;----&gt; B
</pre>
         <p class="std">This is a simple example, but it describes the common situation. If the GC is continued after this operation, the GC <em>thinks</em>, that A is not be used from outside, and recognized yet, that B is also not be referenced from outside. But this is false.
         </p>
         
         <p class="std">Therefore the garbage collector is aborted in its work if a block is reused with a new or other reference while it is in the
            testing cluster. The GC should test the blocks of this cluster again, it should forgot the found now assessment. But second,
            if the same block is tested again, and a fast algorithm switches the references between this blocks again and again, the GC
            is aborted again and again and it doesn't step forward. Thats why the aborted GC doesn't start with test of the same (aborted)
            block, it starts in generally with the next block in the BlockHeap.
         </p>
         
         <p class="std">All tested blocks of a cluster are queued. The queue uses the element <code>nextBlock</code> in the head data of any block. The queue is used and drained, if the whole cluster of blocks is detect as used or free. To
            implement the behavior of aborting GC, the <code>nextBlock</code>-reference of a new referenced block is tested. If it is not null, the block is member of the current tested cluster. If a
            <code>setBackref()</code> handle such a block, it set a bit (signal) to the GC to dismiss its work with the cluster.
         </p>
         
         <p class="std">
            <b>References from freed blocks: The backward references have to be deleted</b></p>
         
         <p class="std">A Cluster spans only the block they have references one another. References from internal data of outside blocks are not tested
            from GC because they are unknown. But backward references may exist from outside to the freeing-candidate blocks. The next
            figure show it: <code>X</code> and <code>Y</code> are referenced from <code>A</code> and <code>B</code>. <code>X</code> and <code>Y</code> are not tested yet. <code>A</code> is tested first.
         </p>
         <pre>       X &lt;--- Y &lt;--- A &lt;---- B
</pre>
         <p class="std">A is referenced from <code>B</code>, but no references from outside are detected furthermore. Therefore <code>A</code> and <code>B</code> builds a cluster and are freed. The result is:
         </p>
         <pre>       X &lt;--- Y &lt;--- ?
</pre>
         <p class="std">The question mark symbols a reference to Y inside the old, now freed <code>A</code>.
         </p>
         
         <p class="std">The backward references in outside blocks to the freeing-candidate blocks should be purged. It is done to set <code>null</code> to inside references. But the user doesn't should be done it at Java level. This action is done in the <code>finalize()</code>-routine of any class. The <code>finalize()</code> is called from garbage collector before freeing the block using dynamic call concept. The <code>finalize_UserType()</code> is generated from Java2C, regarding all references of the <code>UserType</code>. <code>finalize_UserType()</code> contains this generated part of code, plus the part of a possible <code>finalize()</code>-routine from Java level.
         </p>
      </div><br clear="all"><a id="w0aaab5b4b5b6" name="chapter_6.3.2.3"></a><a id="w0aaab5b4b5b6" name="6.3.2.3"></a><h5>6.3.2.3 Optimizations of back-ref-using</h5><a id="w0aaab5b4b5b6b3" name="Topic.Java2C.BlockHeapConcept..."></a><div class="" id="Topic.Java2C.BlockHeapConcept...">
         <p class="debug">Topic:.Java2C.BlockHeapConcept...</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <p class="std">Enhanced references with the necessity of call <em>setBackRefJc()</em> are not used
         </p>
         
         <ul class="std">
            <li>
               <p class="std">for local (stack-) -variables and method arguments,</p>
            </li>
            <li>
               <p class="std">for classes there are not slated for using in dynamically memory, that classes should be marked with <code>@staticInstance</code> in the description of class.
               </p>
            </li>
         </ul>
         
         <p class="std">If a reference to a block is only stored in a stack variable without back-reference, it should not be considered by garbage
            collector to prevent a free of this block while using. Therefore the first (single) using of a block is marked with a bit.
            If the first back-ref is stored, the block is marked to consider by GC.  If no back-reference is stored, the block may be
            only used locally in a thread. But after its using it should be freed. Therefore on end of the statement block, in which the
            block is allocated, a call of <code>activateGarbageCollectorAccess_BlockHeapJc()</code> is done to commit it to the GC. After this block either the reference is stored with notation of back-ref, if it is used
            later again or in another thread, or it is not used furthermore.
         </p>
         
         <p class="std">But there is a second situation, at example with following Java code:</p>
         <pre> void example()
 { Type ref1 = this-&gt;ref;
   this-&gt;ref = null;
   return ref1;
 }
</pre>
         <p class="std">called by</p>
         <pre> Type ref1 = example();
 ref1.dosomething;
 this-&gt;ref2 = ref1;
</pre>
         <p class="std">In the 3. line of <code>example()</code> the reference is set to null. It means, the object is not referenced by <code>this-&gt;ref</code>. But because the <code>ref1</code> is not registered as back reference, because it is a stack variable, the GC may free this block, though it is in use. To
            prevent this situation, there are two solutions:
         </p>
         
         <ul class="std">
            <li>
               <p class="std">first: The GC should only run, if no other thread is running. It means, it don't interrupt any algorithm. This solution is
                  possible, if a realtime system have only fast threads, there are limited in calculation time. It is typically for time cyclic
                  control algorithms. A system which uses a real Java Virtual Machine for longer processing algorithms, and implements only
                  the fast cyclic parts in C, are a matching example. The GC should run in the lowest thread priority or in a background loop.
               </p>
            </li>
            <li>
               <p class="std">second: All accesses to the value of a references should be implement the setting of the same bit mConsideredInGarbage_Type_Object
                  in the head data of the block like after a new-statement. All in this manner used blocks should be stored in a list, and should
                  be processed with <code>activateGarbageCollectorAccess_BlockHeapJc()</code> at the end of the visibility of the stack reference. But exclusive that value, which is returned. But this value of block
                  reference should be handled in the stack level above.
               </p>
            </li>
         </ul>
         
         <p class="std">The second algorithm is implementable in Java2C-translated sources because the translator knowns all situations. But it needs
            additional calculation time and it is not optimal for fast control.
         </p>
         
         <p class="std">There is a third solution:</p>
         
         <ul class="std">
            <li>
               <p class="std">A reference stored as class member should never used only locally, it should be set to null in class member only if the usage
                  of it is excluded. - But this is a request to the programming style.
               </p>
            </li>
         </ul>
         
         <p class="std">At this time the first solution is focused. If it is necessary, the third solution can be used. The effort of the second solution
            should be estimated.
         </p>
      </div><br clear="all"><a id="w0aaab5b4b5b7" name="chapter_6.3.2.4"></a><a id="w0aaab5b4b5b7" name="6.3.2.4"></a><h5>6.3.2.4 Advantage of auto generation</h5><a id="w0aaab5b4b5b7b3" name="Topic.Java2C.BlockHeapConcept..."></a><div class="" id="Topic.Java2C.BlockHeapConcept...">
         <p class="debug">Topic:.Java2C.BlockHeapConcept...</p>
         <p class="debug"> pStyle=std tableStyle=stdTable</p>
         
         <p class="std">If an concept of garbage collection is used, it don't care which, some special operations should be done. Using C++, automatic
            generated destructors or overloaded operators can be used. But in C it should be programmed manually. Therefore the automatic
            code generation from Java to C helps to do this things. The Java2C translator produces the right code without any slips.
         </p>
      </div><br clear="all"></body>
</html>