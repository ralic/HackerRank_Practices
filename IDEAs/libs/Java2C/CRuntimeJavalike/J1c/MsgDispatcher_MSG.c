/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "J1c/MsgDispatcher_MSG.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "Fwc/fw_Exception.h"  //reference-association: ExceptionJc
#include "Fwc/fw_MemC.h"  //embedded type in class data
#include "J1c/StringPartJc.h"  //embedded type in block
#include "Jc/ArraysJc.h"  //reference-association: ArraysJc
#include "Jc/ConcurrentLinkedQueueJc.h"  //new object
#include "Jc/FileIoJc.h"  //reference-association: FileDescriptorJc
#include "Jc/ObjectJc.h"  //reference-association: IntegerJc
#include "Jc/SystemJc.h"  //reference-association: SystemJc


const char sign_Mtbl_MsgDispatcher_MSG[] = "MsgDispatcher_MSG"; //to mark method tables of all implementations

typedef struct MtblDef_MsgDispatcher_MSG_t { Mtbl_MsgDispatcher_MSG mtbl; MtblHeadJc end; } MtblDef_MsgDispatcher_MSG;
 extern MtblDef_MsgDispatcher_MSG const mtblMsgDispatcher_MSG;

/*Constructor */
struct MsgDispatcher_MSG_t* ctorO_MsgDispatcher_MSG(ObjectJc* othis, int32 maxDispatchEntries, int32 maxQueue, int32 maxOutputs, int32 nrofMixedOutputs, ThCxt* _thCxt)
{ MsgDispatcher_MSG_s* ythis = (MsgDispatcher_MSG_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_MsgDispatcher_MSG");
  checkConsistence_ObjectJc(othis, sizeof(MsgDispatcher_MSG_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_MsgDispatcher_MSG_s, sizeof(MsgDispatcher_MSG_s));  
  //j2c: Initialize all class variables:
  {
    //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(ythis->testCnt.base.object), sizeof(ythis->testCnt), 0); 
      ctorO_TestCnt_MsgDispatcher_MSG(/*static*/&(ythis->testCnt.base.object), _thCxt);
    ythis->outputConsole = create_LogMessageStream_FW(/*static*/(* (out_FileDescriptorJc)), _thCxt);
    ythis->maxDst = 0;
  }
  { 
    Entry_MsgDispatcher_MSG_Y* entries;   /**/
    int32 idxEntry = 0; 
    MemC mNodes;   /*A queue in C without dynamically memory management should have a pool of nodes.*/
    
    ObjectJc *newObj1_1=null, *newObj1_2=null, *newObj1_3=null, *newObj1_4=null; //J2C: temporary Objects for new operations
    
    if(nrofMixedOutputs < 0 || nrofMixedOutputs > 28) { throw_s0Jc(ident_IllegalArgumentExceptionJc, "max. nrofMixedOutputs", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    ythis->nrofMixedOutputs = nrofMixedOutputs;
    ythis->mDstMixedOutputs = (1 << nrofMixedOutputs) - 1;
    ythis->mDstOneOutput = mDispatchBits_MsgDispatcher_MSG & ~ythis->mDstMixedOutputs;
    
    entries = (Entry_MsgDispatcher_MSG_Y*)ctorO_ObjectArrayJc((newObj1_1 = alloc_ObjectJc( sizeof(ObjectArrayJc) + (maxQueue) * sizeof(Entry_MsgDispatcher_MSG_s), mIsLargeSize_objectIdentSize_ObjectJc, _thCxt)), maxQueue, sizeof(Entry_MsgDispatcher_MSG_s),&reflection_Entry_MsgDispatcher_MSG_s, 0);
    { int32 idxEntry; 
      for(idxEntry = 0; idxEntry < entries->head.length; idxEntry++)
        { 
          
          //J2C: constructor for embedded element-MemC
          ctorM_Entry_MsgDispatcher_MSG(/*static*/build_MemC(&entries->data[idxEntry], sizeof(entries->data[idxEntry])), _thCxt);
        }
    }
    /*no initvalue*/
    mNodes = alloc_MemC(/*static*/(maxQueue + 2) * sizeof(Entry_MsgDispatcher_MSG_s));
    ythis->freeOrders = ctorO_MemC_ConcurrentLinkedQueueJc(/*static*/(newObj1_2 = alloc_ObjectJc(sizeof_ConcurrentLinkedQueueJc_s, 0, _thCxt)), mNodes, _thCxt);
    ythis->listOrders = ctorO_Clq_ConcurrentLinkedQueueJc(/*static*/(newObj1_3 = alloc_ObjectJc(sizeof_ConcurrentLinkedQueueJc_s, 0, _thCxt)), ythis->freeOrders, _thCxt);
    /**All entries, 1 time allocated, are stored in the freeOrders*/
    for(idxEntry = 0; idxEntry < maxQueue; idxEntry++)
      { 
        
        add_ConcurrentLinkedQueueJc(ythis->freeOrders, & (entries->data[idxEntry]), _thCxt);
      }
    
    { 
      ObjectJc *newObj2_1=null, *newObj2_2=null; //J2C: temporary Objects for new operations
      
      ythis->listIdents = (int32_Y*)ctorO_ObjectArrayJc((newObj2_1 = alloc_ObjectJc( sizeof(ObjectArrayJc) + (maxDispatchEntries) * sizeof(int32), mIsLargeSize_objectIdentSize_ObjectJc, _thCxt)), maxDispatchEntries, sizeof(int32),REFLECTION_int32, 0);  //J2C: assign a new ObjectArrayJc. ;
      ythis->listBitDst = (int32_Y*)ctorO_ObjectArrayJc((newObj2_2 = alloc_ObjectJc( sizeof(ObjectArrayJc) + (maxDispatchEntries) * sizeof(int32), mIsLargeSize_objectIdentSize_ObjectJc, _thCxt)), maxDispatchEntries, sizeof(int32),REFLECTION_int32, 0);  //J2C: assign a new ObjectArrayJc. ;
      ythis->listIdents->data[0] = 0;
      ythis->listIdents->data[1] = MAX_VALUE_IntegerJc;
      ythis->listBitDst->data[0] = 0;
      ythis->listBitDst->data[1] = 0xffffffff;//this value will be unused because MAX_VALUE don't be used.
      
      ythis->actNrofListIdents = 2;
      activateGarbageCollectorAccess_BlockHeapJc(newObj2_1, null);
      activateGarbageCollectorAccess_BlockHeapJc(newObj2_2, null);
    }
    /*allocate the output array: */
    ythis->outputs = (Output_MsgDispatcher_MSG_Y*)ctorO_ObjectArrayJc((newObj1_4 = alloc_ObjectJc( sizeof(ObjectArrayJc) + (maxOutputs) * sizeof(Output_MsgDispatcher_MSG_s), mIsLargeSize_objectIdentSize_ObjectJc, _thCxt)), maxOutputs, sizeof(Output_MsgDispatcher_MSG_s),&reflection_Output_MsgDispatcher_MSG_s, 0);  //J2C: assign a new ObjectArrayJc. ;
    { int32 idxDst; 
      for(idxDst = 0; idxDst < maxOutputs; idxDst++)
        { 
          
          //J2C: constructor for embedded element-MemC
          ctorM_Output_MsgDispatcher_MSG(/*static*/build_MemC(&ythis->outputs->data[idxDst], sizeof(ythis->outputs->data[idxDst])), _thCxt);
        }
    }
    /**Set default output to console. */
    setOutputRoutine_MsgDispatcher_MSG(ythis, 0, s0_StringJc("CON"), false, ythis->outputConsole, _thCxt);//mConsole
    
    setOutputRoutine_MsgDispatcher_MSG(ythis, 1, s0_StringJc("qCON"), true, ythis->outputConsole, _thCxt);//mConsoleQueued
    
    setOutputRange_MsgDispatcher_MSG(ythis, 0, MAX_VALUE_IntegerJc, mConsole_MsgDispatcher_MSG, mSet_MsgDispatcher_MSG, 3, _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(newObj1_1, null);
    activateGarbageCollectorAccess_BlockHeapJc(newObj1_2, null);
    activateGarbageCollectorAccess_BlockHeapJc(newObj1_3, null);
    activateGarbageCollectorAccess_BlockHeapJc(newObj1_4, null);
  }
  STACKTRC_LEAVE;
  return ythis;
}



/**Gets the internal free entries for sharing with an other log output,*/
struct ConcurrentLinkedQueueJc_t* getSharedFreeEntries_MsgDispatcher_MSG(MsgDispatcher_MSG_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getSharedFreeEntries_MsgDispatcher_MSG");
  
  { 
    
    { STACKTRC_LEAVE;
      return ythis->freeOrders;
    }
  }
  STACKTRC_LEAVE;
}

void setDefaults_MsgDispatcher_MSG(MsgDispatcher_MSG_s* ythis, StringJc fileOut, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setDefaults_MsgDispatcher_MSG");
  
  { 
    
    setOutputRoutine_MsgDispatcher_MSG(ythis, 0, s0_StringJc("CON"), false, ythis->outputConsole, _thCxt);//mConsole
    
    setOutputRoutine_MsgDispatcher_MSG(ythis, 1, s0_StringJc("qCON"), true, ythis->outputConsole, _thCxt);//mConsoleQueued
    
    setOutputRange_MsgDispatcher_MSG(ythis, 0, MAX_VALUE_IntegerJc, mConsole_MsgDispatcher_MSG, mSet_MsgDispatcher_MSG, 3, _thCxt);
  }
  STACKTRC_LEAVE;
}

int32 searchDispatchBits_MsgDispatcher_MSG(MsgDispatcher_MSG_s* ythis, int32 ident, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("searchDispatchBits_MsgDispatcher_MSG");
  
  { 
    int32 bitDst = 0; 
    int32 idx; 
    
    
    /*no initvalue*/
    if(ident < 0) 
    { 
      
      /**a negative ident means: going state. The absolute value is to dispatch! */
      ident = -ident;
    }
    idx = binarySearch_int_ii_ArraysJc(/*static*/ythis->listIdents/*J2C-error testAndChangeAccess: XY*/, 0, ythis->actNrofListIdents, ident, _thCxt);
    if(idx < 0) idx = -idx - 2;//example: nr between idx=2 and 3 returns -4, converted to 2
    
    if(idx < 0) idx = 0;//if nr before idx = 0, use properties of msg nr=0
    
    bitDst = ythis->listBitDst->data[idx];
    { STACKTRC_LEAVE;
      return bitDst;
    }
  }
  STACKTRC_LEAVE;
}


/**inserts an ident range after given position:*/
int32 insertIdent_MsgDispatcher_MSG(MsgDispatcher_MSG_s* ythis, int32 idx, int32 fromIdent, int32 toIdent, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("insertIdent_MsgDispatcher_MSG");
  
  { 
    int32 ident0; 
    int32 ident3; 
    int32 idxFrom = 0; 
    
    
    ident0 = ythis->listIdents->data[idx];
    ident3 = ythis->listIdents->data[idx + 1];
    /*no initvalue*/
    if(ident0 < fromIdent && toIdent + 1 < ident3) 
    { 
      
      /**insert two new positions, {..., ident0, fromIdent, toIdent, ident3, ...} :*/
      idxFrom = idx + 1;
      ythis->actNrofListIdents += 2;//copy after idx, src from idx+1, because the content at idx is okay.
      
      arraycopy_SystemJc(/*static*/& ((ythis->listIdents)->head.object), idx + 1, & ((ythis->listIdents)->head.object), idx + 3, ythis->actNrofListIdents - (idx + 3), _thCxt);
      arraycopy_SystemJc(/*static*/& ((ythis->listBitDst)->head.object), idx + 1, & ((ythis->listBitDst)->head.object), idx + 3, ythis->actNrofListIdents - (idx + 3), _thCxt);
      ythis->listIdents->data[idxFrom] = fromIdent;
      ythis->listIdents->data[idxFrom + 1] = toIdent + 1;
      /**Copy the mask from range ident0.. to the new positions. */
      ythis->listBitDst->data[idxFrom] = ythis->listBitDst->data[idxFrom + 1] = /*? assignment*/ythis->listBitDst->data[idx];//listBitDst[idxFrom] |= mask;
      
    }
    else if(ident0 < fromIdent) 
    { 
      
      /**insert one new positions, {..., ident0, fromIdent, ident3, ...} :*/
      ASSERT(/*static*/toIdent + 1 == ident3);
      idxFrom = idx + 1;
      ythis->actNrofListIdents += 1;
      arraycopy_SystemJc(/*static*/& ((ythis->listIdents)->head.object), idx + 1, & ((ythis->listIdents)->head.object), idx + 2, ythis->actNrofListIdents - (idx + 2), _thCxt);
      arraycopy_SystemJc(/*static*/& ((ythis->listBitDst)->head.object), idx + 1, & ((ythis->listBitDst)->head.object), idx + 2, ythis->actNrofListIdents - (idx + 2), _thCxt);
      ythis->listIdents->data[idxFrom] = fromIdent;
      /**Copy the mask from range ident0.. to the new positions. */
      ythis->listBitDst->data[idxFrom] = ythis->listBitDst->data[idx];//listBitDst[idxFrom] |= mask;
      
    }
    else if(ident0 == fromIdent && toIdent + 1 < ident3) 
    { 
      
      /**insert one new positions, {..., ident0, toIdent, ident3, ...} :*/
      ythis->actNrofListIdents += 1;
      idxFrom = idx;
      arraycopy_SystemJc(/*static*/& ((ythis->listIdents)->head.object), idx + 1, & ((ythis->listIdents)->head.object), idx + 2, ythis->actNrofListIdents - (idx + 2), _thCxt);
      arraycopy_SystemJc(/*static*/& ((ythis->listBitDst)->head.object), idx + 1, & ((ythis->listBitDst)->head.object), idx + 2, ythis->actNrofListIdents - (idx + 2), _thCxt);
      ythis->listIdents->data[idx + 1] = toIdent + 1;
      /**Copy the mask from range ident0.. to the new positions. */
      ythis->listBitDst->data[idx + 1] = ythis->listBitDst->data[idx];
    }
    else 
    { 
      
      ASSERT(/*static*/ident0 == fromIdent && toIdent + 1 == ident3);
      idxFrom = idx;//replace only
      
    }
    { STACKTRC_LEAVE;
      return idxFrom;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets a destination interface to a index for dispatching.*/
void setOutputRoutine_MsgDispatcher_MSG(MsgDispatcher_MSG_s* ythis, int32 dstIdx, StringJc name, bool bQueued, struct LogMessageFW_t* dst, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setOutputRoutine_MsgDispatcher_MSG");
  
  { 
    int32 mask = 0; 
    
    
    /*no initvalue*/
    if(dstIdx < 0 || dstIdx > ythis->outputs->head.length) { throw_s0Jc(ident_IllegalArgumentExceptionJc, "dstIdx fault. Hint: an index, not a mask!", 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    if(ythis->maxDst <= dstIdx) 
    { 
      
      ythis->maxDst = dstIdx + 1;
    }
    /*if(dstIdx > nrofMixedOutputs)*/
    SETREFJc(ythis->outputs->data[dstIdx].outputIfc, dst, LogMessageFW_i);
    ythis->outputs->data[dstIdx].dstInDispatcherThread = bQueued;
    set_StringJc(&(ythis->outputs->data[dstIdx].name), name);
  }
  STACKTRC_LEAVE;
}


/**Sets the output dispatch bits for the given message number range.*/
int32 setOutputRange_MsgDispatcher_MSG(MsgDispatcher_MSG_s* ythis, int32 fromIdent, int32 toIdent, int32 dst, int32 mode, int32 level, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setOutputRange_MsgDispatcher_MSG");
  
  { 
    int32 idx1 = 0;   /*Found index where the idents are arranged in . */
    int32 idx2 = 0;   /*Found index where the idents are arranged in . */
    int32 maskSet; 
    int32 ident2; 
    int32 idx1Mask = 0;   /*The first index at which the mask is changed. */
    int32 idx2Mask = 0;   /*The next index after last index which mask is changed. */
    
    
    /*no initvalue*/
    /*no initvalue*/
    maskSet = completeDispatchInThreadBits_MsgDispatcher_MSG(ythis, dst, _thCxt);
    if(toIdent == MAX_VALUE_IntegerJc) 
    { //:the range is from ...inclusive to, let the MAX_VALUE outside, because there should be and end entry,
      
      
      toIdent = MAX_VALUE_IntegerJc - 1;
    }
    idx1 = binarySearch_int_ii_ArraysJc(/*static*/ythis->listIdents/*J2C-error testAndChangeAccess: XY*/, 0, ythis->actNrofListIdents, fromIdent, _thCxt);
    if(idx1 < 0) idx1 = -idx1 - 2;//example: nr between idx=2 and 3 returns -4, converted to 2
    
    if(idx1 < 0) idx1 = 0;//if nr before idx = 0, use properties of msg nr=0
    //at idx1 : ident0  <= fromIdent
    
    ident2 = ythis->listIdents->data[idx1 + 1];
    /*no initvalue*/
    /*no initvalue*/
    if(toIdent < ident2) 
    { //:the whole range fromIdent...toIdent is at or between idx1...idx1+1
      
      
      idx1Mask = insertIdent_MsgDispatcher_MSG(ythis, idx1, fromIdent, toIdent, _thCxt);
      idx2Mask = idx1Mask + 1;
    }
    else 
    { 
      int32 ident1; 
      int32 ident3; 
      int32 mask3; 
      
      
      ident1 = ythis->listIdents->data[idx1 + 1];
      idx1Mask = insertIdent_MsgDispatcher_MSG(ythis, idx1, fromIdent, ident1 - 1, _thCxt);//inserts after idx1, if necessary
      
      idx2 = binarySearch_int_ii_ArraysJc(/*static*/ythis->listIdents/*J2C-error testAndChangeAccess: XY*/, 0, ythis->actNrofListIdents, toIdent + 1, _thCxt);
      if(idx2 < 0) idx2 = -idx2 - 2;//example: nr between idx=2 and 3 returns -4, converted to 2
      //at idx2 : ident3 <= toIdent //<= ident3
      
      ident3 = ythis->listIdents->data[idx2 + 1];
      mask3 = ythis->listBitDst->data[idx2];
      idx2Mask = insertIdent_MsgDispatcher_MSG(ythis, idx2, toIdent + 1, ident3 - 1, _thCxt);//inserts before idx2+1, if necessary
      
    }
    { int32 imask; 
      for(imask = idx1Mask; imask < idx2Mask; imask++)
        { 
          
          switch(mode){
            case mSet_MsgDispatcher_MSG: ythis->listBitDst->data[imask] = maskSet;break;
            case mAdd_MsgDispatcher_MSG: ythis->listBitDst->data[imask] |= maskSet;break;
            case mRemove_MsgDispatcher_MSG: ythis->listBitDst->data[imask] &= ~(maskSet & mDispatchBits_MsgDispatcher_MSG);break;
            default: { throw_s0Jc(ident_IllegalArgumentExceptionJc, "failed mode", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
          }/*switch*/;
        }
    }
    { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the output from a String content.*/
StringJc setOutputFromString_MsgDispatcher_MSG(MsgDispatcher_MSG_s* ythis, StringJc ctrl, struct StringBuilderJc_t* errorBuffer, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setOutputFromString_MsgDispatcher_MSG");
  
  { 
    StringJc sError = NULL_StringJc; 
    StringPartJc_s spCtrl = { 0 };   /**/
    bool continueAll = true; 
    
    
    sError = null_StringJc/*J2C:non-persistent*/;
    if(errorBuffer != null) 
    { 
      
      setLength_StringBuilderJc(errorBuffer, 0, _thCxt);
    }
    
    //J2C: constructor for embedded element-ObjectJc
    init_ObjectJc(&(spCtrl.base.object), sizeof(spCtrl), 0); 
    ctorO_S_StringPartJc(/*static*/&(spCtrl.base.object), ctrl, _thCxt);
    setIgnoreWhitespaces_StringPartJc_F(& (spCtrl), true, _thCxt);
    setIgnoreComment_SS_StringPartJc_F(& (spCtrl), s0_StringJc("/*"), s0_StringJc("*/"), _thCxt);
    setIgnoreEndlineComment_S_StringPartJc_F(& (spCtrl), s0_StringJc("//"), _thCxt);
    continueAll = true;
    TRY
    { 
      
      do 
        { 
          int32 fromIdent = 0; 
          int32 toIdent = 0; 
          
          
          /*no initvalue*/
          /*no initvalue*/
          if(
          ( seekNoWhitespaceOrComments_StringPartJc_F(& (spCtrl), _thCxt)
          , length_StringPartJc_F(& (spCtrl), _thCxt)
          ) == 0) 
          { 
            
            continueAll = false;//finish.
            
          }
          else if(
          ( scanInteger_StringPartJc_F(& (spCtrl), _thCxt)
          , scanOk_StringPartJc_F(& (spCtrl), _thCxt)
          )) 
          { 
            
            fromIdent = (int32)getLastScannedIntegerNumber_StringPartJc_F(& (spCtrl), _thCxt);
            toIdent = -1;
            if(
            ( scan_StringPartJc_F(& (spCtrl), s0_StringJc(".."), _thCxt)
            , scanInteger_StringPartJc_F(& (spCtrl), _thCxt)
            , scanOk_StringPartJc_F(& (spCtrl), _thCxt)
            )) 
            { 
              
              toIdent = (int32)getLastScannedIntegerNumber_StringPartJc_F(& (spCtrl), _thCxt);
            }
            if(!
            ( scan_StringPartJc_F(& (spCtrl), s0_StringJc(":"), _thCxt)
            , scanOk_StringPartJc_F(& (spCtrl), _thCxt)
            )) 
            { 
              
              sError = z_StringJc(toIdent == -1 ? "\":\"or \"..\" expected" : "\":\" expected")/*J2C:non-persistent*/;
            }
            else 
            { 
              
              if(toIdent == -1) 
              { 
                
                toIdent = fromIdent;
              }
              if(
              ( scanHexOrDecimal_StringPartJc_F(& (spCtrl), 8, _thCxt)
              , scanOk_StringPartJc_F(& (spCtrl), _thCxt)
              )) 
              { 
                int32 dst; 
                
                
                dst = (int32)getLastScannedIntegerNumber_StringPartJc_F(& (spCtrl), _thCxt);
                setOutputRange_MsgDispatcher_MSG(ythis, fromIdent, toIdent, dst, mSet_MsgDispatcher_MSG, 3, _thCxt);
                if(!
                ( scan_StringPartJc_F(& (spCtrl), s0_StringJc(";"), _thCxt)
                , scanOk_StringPartJc_F(& (spCtrl), _thCxt)
                )) 
                { 
                  
                  sError = z_StringJc("\";\" expected after number-output.")/*J2C:non-persistent*/;
                }
              }
              else 
              { 
                bool continueEntry = true; 
                int32 mode; 
                
                
                continueEntry = true;
                mode = mSet_MsgDispatcher_MSG;
                do 
                  { 
                    StringJc sOutput = NULL_StringJc; 
                    
                    
                    sOutput = null_StringJc/*J2C:non-persistent*/;
                    if(
                  ( scan_StringPartJc_F(& (spCtrl), s0_StringJc("+"), _thCxt)
                  , scanOk_StringPartJc_F(& (spCtrl), _thCxt)
                  )) 
                    { 
                      
                      mode = mAdd_MsgDispatcher_MSG;
                    }
                    else if(
                  ( scan_StringPartJc_F(& (spCtrl), s0_StringJc("-"), _thCxt)
                  , scanOk_StringPartJc_F(& (spCtrl), _thCxt)
                  )) 
                    { 
                      
                      mode = mRemove_MsgDispatcher_MSG;
                    }
                    else if(
                  ( scan_StringPartJc_F(& (spCtrl), s0_StringJc(";"), _thCxt)
                  , scanOk_StringPartJc_F(& (spCtrl), _thCxt)
                  )) 
                    { 
                      
                      continueEntry = false;
                    }
                    else 
                    { 
                      
                      if(mode != mSet_MsgDispatcher_MSG) 
                      { 
                        
                        sError = z_StringJc("\"+\" or \"-\" or \";\" expected")/*J2C:non-persistent*/;
                      }
                    }
                    if(continueEntry && sError.ptr__== null) 
                    { 
                      
                      if(
                    ( scanIdentifier_StringPartJc_F(& (spCtrl), _thCxt)
                    , scanOk_StringPartJc_F(& (spCtrl), _thCxt)
                    )) 
                      { 
                        StringJc _persistring9_1=NULL_StringJc; //J2C: temporary persistent Strings
                        
                        sOutput = _persistring9_1 = persist_StringJc(getLastScannedString_StringPartJc_F(& (spCtrl), _thCxt))/*J2C:non-persistent*/;
                        activateGarbageCollectorAccess_BlockHeapJc(PTR_StringJc(_persistring9_1), null);
                      }
                      else 
                      { 
                        
                        sError = z_StringJc("\"DST\" expected, DST should be an identifier.")/*J2C:non-persistent*/;
                      }
                      if(sError.ptr__== null) 
                      { 
                        int32 bitOutput = -1; 
                        int32 idxDst = 0; 
                        
                        
                        ASSERT(/*static*/sOutput.ptr__!= null);
                        bitOutput = -1;
                        idxDst = 0;
                        
                        while(idxDst < ythis->outputs->head.length && bitOutput == -1)
                          { 
                            
                            if(ythis->outputs->data[idxDst].name.ptr__!= null && equals_StringJc(ythis->outputs->data[idxDst].name, sOutput)) 
                            { 
                              
                              bitOutput = 1 << idxDst;
                            }
                            else 
                            { 
                              
                              idxDst++;
                            }
                          }
                        if(bitOutput == -1) 
                        { 
                          
                          if(errorBuffer != null) 
                          { 
                            
                            
                          ( append_z_StringBuilderJc(errorBuffer, "Output not found:", _thCxt)
                          , append_s_StringBuilderJc(errorBuffer, sOutput, _thCxt)
                          );
                          }
                          sError = sOutput/*J2C:non-persistent*/;//short variant if buffer isn't given.
                          
                          continueAll = false;
                        }
                        else 
                        { 
                          
                          setOutputRange_MsgDispatcher_MSG(ythis, fromIdent, toIdent, bitOutput, mode, 3, _thCxt);
                          mode = -1;//other mode as mSet expected.
                          
                        }
                      }
                    }
                  }while(sError.ptr__== null && continueEntry && continueAll);
              }//if hexInt else ident;
              
            }//: scanned
            
          }
          else 
          { 
            
            sError = z_StringJc("Number for first message to dispatch expected")/*J2C:non-persistent*/;
            continueAll = false;
          }
        }while(continueAll && sError.ptr__== null);
    }_TRY
    CATCH(ParseException, exc)
    
      { 
        
        sError = getMessage_ExceptionJc(exc, _thCxt)/*J2C:non-persistent*/;
      }
    END_TRY
    if(sError.ptr__!= null && errorBuffer != null && length_StringBuilderJc(errorBuffer) == 0) 
    { 
      int32 nrofCharsRest;   /*Write the error in the buffer, with fault input string position. */
      
      
      nrofCharsRest = capacity_StringBuilderJc(errorBuffer) - length_StringJc(sError) - 5;
      /**Prevent Buffer expansion, use rest size. */
      
        ( append_s_StringBuilderJc(errorBuffer, sError, _thCxt)
        , append_z_StringBuilderJc(errorBuffer, " at:", _thCxt)
        , append_s_StringBuilderJc(errorBuffer, getCurrent_StringPartJc_F(& (spCtrl), nrofCharsRest, _thCxt), _thCxt)
        );
    }
    { STACKTRC_LEAVE;
      return sError;
    }
  }
  STACKTRC_LEAVE;
}


/**Writes the msg dispatching outputs in file.*/
bool reportOutput_MsgDispatcher_MSG(MsgDispatcher_MSG_s* ythis, struct FileWriterJc_t* file, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("reportOutput_MsgDispatcher_MSG");
  
  { 
    bool bOk = true; 
    
    
    bOk = true;
    TRY
    { 
      StringBuilderJc line = { 0 };   /**/
      
      
      /**A temporary buffer, in C in Stack*/
      write_FileWriterJc(file, s0_StringJc("//Syntax-Example\n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("//  1200..1257: +File +qCON -CON;\n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("//  4567:File;\n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("//Ident number from..to or only one ident number.\n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("//\":\" and \";\" are obligatory. Whitespaces in a line and line end comment are allowed.\n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("//if first DST without \"+\" or \"-\": Redirect first only to this destination, all existing dst are deleted.\n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("//All following dst have to be separated with \"+\" or \"-\":\n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("//\"+\" means: use Dst, \"-\" means, don't use, delete if exists before.\n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("//at exampe switch off file output for a single ident, than write:\n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("//1234:-File;  \n"), _thCxt);
      write_FileWriterJc(file, s0_StringJc("\n//All existing dst (destinations):\n"), _thCxt);
      
      //J2C: constructor for embedded element-ObjectJc
      init_ObjectJc(&(line.base.object), sizeof(line), 0); 
      ctorO_I_StringBuilderJc(/*static*/&(line.base.object), 200, _thCxt);
      { int32 ii; 
        for(ii = 0; ii < ythis->maxDst; ii++)
          { 
            struct Output_MsgDispatcher_MSG_t* dst; 
            
            
            setLength_StringBuilderJc(& (line), 0, _thCxt);
            dst = & (ythis->outputs->data[ii]);
            if(REFJc(dst->outputIfc) != null) 
            { 
              
              
              ( append_z_StringBuilderJc(& (line), "//", _thCxt)
              , append_I_StringBuilderJc(& (line), ii, _thCxt)
              , append_z_StringBuilderJc(& (line), ": ", _thCxt)
              , append_s_StringBuilderJc(& (line), dst->name, _thCxt)
              );
              if(dst->dstInDispatcherThread) 
              { 
                
                append_z_StringBuilderJc(& (line), " - queued", _thCxt);
              }
              append_z_StringBuilderJc(& (line), ";\n", _thCxt);
              write_FileWriterJc(file, toString_StringBuilderJc(& ((line).base.object), _thCxt), _thCxt);
            }
          }
      }
      write_FileWriterJc(file, s0_StringJc("\n//All existing dispatching entries:\n"), _thCxt);
      { int32 ii; 
        for(ii = 0; ii < ythis->actNrofListIdents - 1; ii++)
          { 
            int32 ident1; 
            int32 ident2; 
            int32 bitDst; 
            bool bFirst = true; 
            int32 maskBitDst = 1; 
            
            
            ident1 = ythis->listIdents->data[ii];
            ident2 = ythis->listIdents->data[ii + 1] - 1;
            setLength_StringBuilderJc(& (line), 0, _thCxt);
            append_I_StringBuilderJc(& (line), ident1, _thCxt);
            if(ident2 != ident1) 
            { 
              
              /**not single message ident */
              
              ( append_z_StringBuilderJc(& (line), "..", _thCxt)
              , append_I_StringBuilderJc(& (line), ident2, _thCxt)
              );
            }
            append_z_StringBuilderJc(& (line), ":", _thCxt);
            bitDst = ythis->listBitDst->data[ii];
            bFirst = true;
            maskBitDst = 1;
            { int32 iDst; 
              for(iDst = 0; iDst < ythis->maxDst; iDst++)
                { 
                  
                  if((bitDst & maskBitDst) != 0) 
                  { 
                    struct Output_MsgDispatcher_MSG_t* dst; 
                    
                    
                    dst = & (ythis->outputs->data[iDst]);
                    if(REFJc(dst->outputIfc) != null) 
                    { 
                      
                      if(!bFirst) 
                      { 
                        
                        append_z_StringBuilderJc(& (line), "+", _thCxt);
                      }
                      else 
                      { 
                        
                        bFirst = false;
                      }
                      append_s_StringBuilderJc(& (line), dst->name, _thCxt);
                    }
                  }
                  if(iDst < ythis->nrofMixedOutputs) 
                  { 
                    
                    /**Test next bit. */
                    maskBitDst <<= 1;
                  }
                  else 
                  { 
                    int32 idxNonMixedDst;   /*A non mixed output: */
                    
                    
                    idxNonMixedDst = ((bitDst & ythis->mDstOneOutput) >> ythis->nrofMixedOutputs) - 1 + ythis->nrofMixedOutputs;
                    if(idxNonMixedDst >= ythis->nrofMixedOutputs) 
                    { 
                      struct Output_MsgDispatcher_MSG_t* dst; 
                      
                      
                      dst = & (ythis->outputs->data[iDst]);
                      if(REFJc(dst->outputIfc) != null) 
                      { 
                        
                        if(!bFirst) 
                        { 
                          
                          append_z_StringBuilderJc(& (line), "+", _thCxt);
                        }
                        else 
                        { 
                          
                          bFirst = false;
                        }
                        append_s_StringBuilderJc(& (line), dst->name, _thCxt);
                      }
                    }
                  }
                }//for,all dst of one line
                
            }
            append_z_StringBuilderJc(& (line), ";\n", _thCxt);
            write_FileWriterJc(file, toString_StringBuilderJc(& ((line).base.object), _thCxt), _thCxt);
          }
      }
    }_TRY
    CATCH(IOException, exc)
    
      { 
        
        bOk = false;//end it. write no more lines. It may be disk is full.
        
      }
    END_TRY
    { STACKTRC_LEAVE;
      return bOk;
    }
  }
  STACKTRC_LEAVE;
}


/**Completes a destination bit mask with the information, whether any destinations are used*/
int32 completeDispatchInThreadBits_MsgDispatcher_MSG(MsgDispatcher_MSG_s* ythis, int32 dstBits, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("completeDispatchInThreadBits_MsgDispatcher_MSG");
  
  { 
    int32 dstBitRet; 
    int32 idst = 0; 
    
    
    dstBitRet = dstBits;
    /**Assert: The bits should not be negative, because elsewhere >> shifts a 1-bit into,*/
    ASSERT(/*static*/dstBits >= 0);
    idst = 0;
    
    while(dstBits != 0)
      { 
        
        if((dstBits & 1) != 0) 
        { 
          
          if(ythis->outputs->data[idst].dstInDispatcherThread) 
          { 
            
            dstBitRet |= mDispatchInDispatcherThread_MsgDispatcher_MSG;
          }
          else 
          { 
            
            dstBitRet |= mDispatchInCallingThread_MsgDispatcher_MSG;
          }
        }
        dstBits >>= 1;
        idst += 1;
      }
    { STACKTRC_LEAVE;
      return dstBitRet;
    }
  }
  STACKTRC_LEAVE;
}


/**Dispatches a message*/
int32 dispatchMsg_MsgDispatcher_MSG(MsgDispatcher_MSG_s* ythis, int32 dstBits, bool bDispatchInDispatcherThread, int32 identNumber, OS_TimeStamp creationTime, char const* text, Va_listFW args, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("dispatchMsg_MsgDispatcher_MSG");
  
  { //:final boolean bDispatchInDispatcherThread = (dstBits & mDispatchInDispatcherThread)!=0;
    //:assert, that dstBits is positive, because >>=1 and 0-test fails elsewhere.
    //:The highest Bit has an extra meaning, also extract above.
    
    int32 bitTest = 0x1; 
    int32 idst = 0; 
    
    
    dstBits &= mDispatchBits_MsgDispatcher_MSG;
    bitTest = 0x1;
    idst = 0;
    
    while(dstBits != 0 && bitTest < mDispatchBits_MsgDispatcher_MSG)
      { 
        
        if((dstBits & bitTest) != 0 && ((ythis->outputs->data[idst].dstInDispatcherThread && bDispatchInDispatcherThread) || (!ythis->outputs->data[idst].dstInDispatcherThread && !bDispatchInDispatcherThread))) 
        { 
          struct LogMessageFW_t* out; 
          
          
          out = REFJc(ythis->outputs->data[idst].outputIfc);
          if(out != null) 
          { 
            bool sent; 
            
            
            sent = ((/*J2C:cast% from void*/bool)(((Mtbl_LogMessageFW const*)getMtbl_ObjectJc(&(out)->base.object, sign_Mtbl_LogMessageFW) )->sendMsgVaList(out, identNumber, creationTime, text, args, _thCxt)));
            if(sent) 
            { 
              
              dstBits &= ~bitTest;//if sent, reset the associated bit.
              
            }
          }
          else 
          { 
            
            dstBits &= ~bitTest;//reset the associated bit, send isn't possible
            
            ythis->testCnt.noOutput += 1;
          }
        }
        bitTest <<= 1;
        idst += 1;
      }
    { STACKTRC_LEAVE;
      return dstBits;
    }
  }
  STACKTRC_LEAVE;
}


/**Sends a message*/
bool sendMsg_izv_MsgDispatcher_MSG(LogMessageFW_i* ithis, int32 identNumber, char const* text, char const* args, ...)
{ MsgDispatcher_MSG_s* ythis = (MsgDispatcher_MSG_s*)ithis;
  
  STACKTRC_ENTRY("sendMsg_izv_MsgDispatcher_MSG");
  
  { 
    Va_listFW vaArgs = { 0 };   /*store the variable arguments in a Va_list to handle for next call.*/
    
    
    
    va_start(vaArgs.args, args); vaArgs.typeArgs = args;
    { STACKTRC_LEAVE;
      return sendMsgVaList_iDtzv_MsgDispatcher_MSG(& ((* (ythis)).base.LogMessageFW)/*J2cT1*/, identNumber, os_getDateTime(), text, vaArgs, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sends a message*/
bool sendMsgTime_iDtzv_MsgDispatcher_MSG(LogMessageFW_i* ithis, int32 identNumber, OS_TimeStamp creationTime, char const* text, char const* args, ...)
{ MsgDispatcher_MSG_s* ythis = (MsgDispatcher_MSG_s*)ithis;
  
  STACKTRC_ENTRY("sendMsgTime_iDtzv_MsgDispatcher_MSG");
  
  { 
    Va_listFW vaArgs = { 0 };   /*store the variable arguments in a Va_list to handle for next call.*/
    
    
    
    va_start(vaArgs.args, args); vaArgs.typeArgs = args;
    { STACKTRC_LEAVE;
      return sendMsgVaList_iDtzv_MsgDispatcher_MSG(& ((* (ythis)).base.LogMessageFW)/*J2cT1*/, identNumber, creationTime, text, vaArgs, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sends a message*/
bool sendMsgVaList_iDtzv_MsgDispatcher_MSG(LogMessageFW_i* ithis, int32 identNumber, OS_TimeStamp creationTime, char const* text, Va_listFW args, ThCxt* _thCxt)
{ MsgDispatcher_MSG_s* ythis = (MsgDispatcher_MSG_s*)ithis;
  
  STACKTRC_TENTRY("sendMsgVaList_iDtzv_MsgDispatcher_MSG");
  
  { //: TODO Auto-generated method stub
    
    int32 dstBits; 
    
    
    dstBits = searchDispatchBits_MsgDispatcher_MSG(ythis, identNumber, _thCxt);
    if(dstBits != 0) 
    { 
      int32 dstBitsForDispatcherThread = 0; 
      
      
      /*no initvalue*/
      if((dstBits & mDispatchInCallingThread_MsgDispatcher_MSG) != 0) 
      { 
        
        /**dispatch in this calling thread: */
        dstBitsForDispatcherThread = dispatchMsg_MsgDispatcher_MSG(ythis, dstBits, false, identNumber, creationTime, text, args, _thCxt);
      }
      else 
      { 
        
        /**No destinations are to use in calling thread. */
        dstBitsForDispatcherThread = dstBits;
      }//if((dstBits & mDispatchInDispatcherThread) != 0)
      
      if(dstBitsForDispatcherThread != 0) 
      { 
        struct Entry_MsgDispatcher_MSG_t* entry;   /*store in queue, dispatch in a common thread of the message dispatcher:*/
        
        
        entry = ((/*J2C:cast from void*/Entry_MsgDispatcher_MSG_s*)(poll_ConcurrentLinkedQueueJc(ythis->freeOrders, _thCxt)));
        if(entry == null) 
        { //:TODO test if it is a important message
          
          
          println_z_PrintStreamJc(REFJc(out_SystemJc), "**************** NO ENTRIES", _thCxt);
        }
        else 
        { 
          
          /**write the informations to the entry, store it. */
          entry->dst = dstBitsForDispatcherThread;
          entry->ident = identNumber;
          entry->text = text;
          set_OS_TimeStamp(entry->timestamp, creationTime);
          copyFrom_VaArgBuffer(& (entry->values), text, args, _thCxt);
          offer_ConcurrentLinkedQueueJc(ythis->listOrders, entry, _thCxt);
        }
      }
    }
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}


/**Dispatches all messages, which are stored in the queue.*/
int32 dispatchQueuedMsg_MsgDispatcher_MSG(MsgDispatcher_MSG_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("dispatchQueuedMsg_MsgDispatcher_MSG");
  
  { 
    int32 nrofFoundMsg = 0; 
    int32 cntDispatchedMsg = 100;   /*Limit the number of while-loops to prevent thread hanging. */
    bool bCont = 0; 
    struct Entry_MsgDispatcher_MSG_t* firstNotSentMsg = null; 
    
    
    nrofFoundMsg = 0;
    cntDispatchedMsg = 100;
    /*no initvalue*/
    firstNotSentMsg = null;
    do 
      { 
        struct Entry_MsgDispatcher_MSG_t* entry; 
        
        
        entry = ((/*J2C:cast from void*/Entry_MsgDispatcher_MSG_s*)(poll_ConcurrentLinkedQueueJc(ythis->listOrders, _thCxt)));
        bCont = (entry != null && entry != firstNotSentMsg);
        if(bCont) 
        { 
          int32 notDispatchedDst; 
          
          
          nrofFoundMsg += 1;
          notDispatchedDst = dispatchMsg_MsgDispatcher_MSG(ythis, entry->dst, true, entry->ident, entry->timestamp, entry->text, get_va_list_VaArgBuffer(& (entry->values), _thCxt), _thCxt);
          if(true || notDispatchedDst == 0) 
          { 
            
            clean_VaArgBuffer(& (entry->values), _thCxt);
            entry->ident = 0;
            offer_ConcurrentLinkedQueueJc(ythis->freeOrders, entry, _thCxt);
          }
          else 
          { 
            
            /**Not all destinations are processed.*/
            if(firstNotSentMsg == null) 
            { 
              
              firstNotSentMsg = entry;
            }//parkedOrders.offer(entry);
            
          }
        }
      }while(bCont && (--cntDispatchedMsg) >= 0);
    if(cntDispatchedMsg == 0) 
    { //:printf("MsgDisp: WARNING to much messages in queue\n");
      
      
      /**Count this situation to enable to inspect it. */
      ythis->testCnt.tomuchMsgPerThread += 1;
    }
    { STACKTRC_LEAVE;
      return nrofFoundMsg;
    }
  }
  STACKTRC_LEAVE;
}


/**It's a debug helper. The method is empty, but it is a mark to set a breakpoint. */
void stop_MsgDispatcher_MSG(MsgDispatcher_MSG_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("stop_MsgDispatcher_MSG");
  
  { 
    
    
  }
  STACKTRC_LEAVE;
}


/**close and flush forces the dispatching of the messages in the queue.*/
void close_MsgDispatcher_MSG_F(LogMessageFW_i* ithis, ThCxt* _thCxt)
{ MsgDispatcher_MSG_s* ythis = (MsgDispatcher_MSG_s*)ithis;
  
  STACKTRC_TENTRY("close_MsgDispatcher_MSG_F");
  
  { //:flush(); //do the same
    
    
    dispatchQueuedMsg_MsgDispatcher_MSG(ythis, _thCxt);
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void close_MsgDispatcher_MSG(LogMessageFW_i* ithis, ThCxt* _thCxt)
{ Mtbl_LogMessageFW const* mtbl = (Mtbl_LogMessageFW const*)getMtbl_ObjectJc(&ithis->base.object, sign_Mtbl_LogMessageFW);
  mtbl->close((LogMessageFW_i*)ithis, _thCxt);
}


/**flush forces the dispatching of the messages in the queue.*/
void flush_MsgDispatcher_MSG_F(LogMessageFW_i* ithis, ThCxt* _thCxt)
{ MsgDispatcher_MSG_s* ythis = (MsgDispatcher_MSG_s*)ithis;
  
  STACKTRC_TENTRY("flush_MsgDispatcher_MSG_F");
  
  { 
    
    dispatchQueuedMsg_MsgDispatcher_MSG(ythis, _thCxt);
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void flush_MsgDispatcher_MSG(LogMessageFW_i* ithis, ThCxt* _thCxt)
{ Mtbl_LogMessageFW const* mtbl = (Mtbl_LogMessageFW const*)getMtbl_ObjectJc(&ithis->base.object, sign_Mtbl_LogMessageFW);
  mtbl->flush((LogMessageFW_i*)ithis, _thCxt);
}

bool isOnline_MsgDispatcher_MSG_F(LogMessageFW_i* ithis, ThCxt* _thCxt)
{ MsgDispatcher_MSG_s* ythis = (MsgDispatcher_MSG_s*)ithis;
  
  STACKTRC_TENTRY("isOnline_MsgDispatcher_MSG_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return true;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool isOnline_MsgDispatcher_MSG(LogMessageFW_i* ithis, ThCxt* _thCxt)
{ Mtbl_LogMessageFW const* mtbl = (Mtbl_LogMessageFW const*)getMtbl_ObjectJc(&ithis->base.object, sign_Mtbl_LogMessageFW);
  return mtbl->isOnline((LogMessageFW_i*)ithis, _thCxt);
}


/**Outputs the queued messages calling {@link LogMessage#flush()} for all queued outputs.*/
void tickAndFlushOrClose_MsgDispatcher_MSG(MsgDispatcher_MSG_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("tickAndFlushOrClose_MsgDispatcher_MSG");
  
  { 
    
    dispatchQueuedMsg_MsgDispatcher_MSG(ythis, _thCxt);
    { int32 ix; 
      for(ix = 0; ix < ythis->outputs->head.length; ix++)
        { 
          struct Output_MsgDispatcher_MSG_t* output; 
          
          
          output = & (ythis->outputs->data[ix]);
          if(output->dstInDispatcherThread) 
          { 
            
            ((Mtbl_LogMessageFW const*)getMtbl_ObjectJc(&(REFJc(output->outputIfc))->base.object, sign_Mtbl_LogMessageFW) )->flush(REFJc(output->outputIfc), _thCxt);
          }
        }
    }
  }
  STACKTRC_LEAVE;
}



/**J2C: Reflections and Method-table *************************************************/
const MtblDef_MsgDispatcher_MSG mtblMsgDispatcher_MSG = {
{ { sign_Mtbl_MsgDispatcher_MSG//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
  /**J2C: Mtbl-interfaces of MsgDispatcher_MSG: */
, { { sign_Mtbl_LogMessageFW//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((6 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , sendMsgVaList_iDtzv_MsgDispatcher_MSG //sendMsgVaList
  , flush_MsgDispatcher_MSG_F //flush
  , close_MsgDispatcher_MSG_F //close
  , isOnline_MsgDispatcher_MSG_F //isOnline
  , sendMsg_izv_MsgDispatcher_MSG //sendMsg
  , sendMsgTime_iDtzv_MsgDispatcher_MSG //sendMsgTime
  , { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_ObjectJc_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_ObjectJc_F //toString
    }
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_MsgDispatcher_MSG_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_MsgDispatcher_MSG_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_MsgDispatcher_MSG, ObjectJc) }
   }
 };

 extern struct ClassJc_t const reflection_LogMessageFW_i;
 static struct ifcClasses_MsgDispatcher_MSG_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }interfaces_MsgDispatcher_MSG_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
, { {&reflection_LogMessageFW_i, OFFSET_Mtbl(Mtbl_MsgDispatcher_MSG, LogMessageFW) }
  }
};

extern struct ClassJc_t const reflection_MsgDispatcher_MSG_s;
extern struct ClassJc_t const reflection_ConcurrentLinkedQueueJc_s;
extern struct ClassJc_t const reflection_LogMessageFW_i;
extern struct ClassJc_t const reflection_Output_MsgDispatcher_MSG_s;
extern struct ClassJc_t const reflection_TestCnt_MsgDispatcher_MSG_s;
const struct Reflection_Fields_MsgDispatcher_MSG_s_t
{ ObjectArrayJc head; FieldJc data[12];
} reflection_Fields_MsgDispatcher_MSG_s =
{ CONST_ObjectArrayJc(FieldJc, 12, OBJTYPE_FieldJc, null, &reflection_Fields_MsgDispatcher_MSG_s)
, {
     { "nrofMixedOutputs"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((MsgDispatcher_MSG_s*)(0x1000))->nrofMixedOutputs) - (int32)(MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_MsgDispatcher_MSG_s
    }
   , { "mDstMixedOutputs"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((MsgDispatcher_MSG_s*)(0x1000))->mDstMixedOutputs) - (int32)(MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_MsgDispatcher_MSG_s
    }
   , { "mDstOneOutput"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((MsgDispatcher_MSG_s*)(0x1000))->mDstOneOutput) - (int32)(MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_MsgDispatcher_MSG_s
    }
   , { "testCnt"
    , 0 //nrofArrayElements
    , &reflection_TestCnt_MsgDispatcher_MSG_s
    , kEmbedded_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((MsgDispatcher_MSG_s*)(0x1000))->testCnt) - (int32)(MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_MsgDispatcher_MSG_s
    }
   , { "listOrders"
    , 0 //nrofArrayElements
    , &reflection_ConcurrentLinkedQueueJc_s
    , kReference_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((MsgDispatcher_MSG_s*)(0x1000))->listOrders) - (int32)(MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_MsgDispatcher_MSG_s
    }
   , { "freeOrders"
    , 0 //nrofArrayElements
    , &reflection_ConcurrentLinkedQueueJc_s
    , kReference_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((MsgDispatcher_MSG_s*)(0x1000))->freeOrders) - (int32)(MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_MsgDispatcher_MSG_s
    }
   , { "actNrofListIdents"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((MsgDispatcher_MSG_s*)(0x1000))->actNrofListIdents) - (int32)(MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_MsgDispatcher_MSG_s
    }
   , { "listIdents"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc |kObjectArrayJc_Modifier_reflectJc |kReferencedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((MsgDispatcher_MSG_s*)(0x1000))->listIdents) - (int32)(MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_MsgDispatcher_MSG_s
    }
   , { "listBitDst"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc |kObjectArrayJc_Modifier_reflectJc |kReferencedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((MsgDispatcher_MSG_s*)(0x1000))->listBitDst) - (int32)(MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_MsgDispatcher_MSG_s
    }
   , { "outputs"
    , 0 //nrofArrayElements
    , &reflection_Output_MsgDispatcher_MSG_s
    , kEmbedded_Modifier_reflectJc |kObjectArrayJc_Modifier_reflectJc |kReferencedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((MsgDispatcher_MSG_s*)(0x1000))->outputs) - (int32)(MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_MsgDispatcher_MSG_s
    }
   , { "outputConsole"
    , 0 //nrofArrayElements
    , &reflection_LogMessageFW_i
    , kReference_Modifier_reflectJc |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((MsgDispatcher_MSG_s*)(0x1000))->outputConsole) - (int32)(MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_MsgDispatcher_MSG_s
    }
   , { "maxDst"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((MsgDispatcher_MSG_s*)(0x1000))->maxDst) - (int32)(MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_MsgDispatcher_MSG_s
    }
} };
const ClassJc reflection_MsgDispatcher_MSG_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "MsgDispatcher_MSG_s"
, (int16)((int32)(&((MsgDispatcher_MSG_s*)(0x1000))->base.object) - (int32)(MsgDispatcher_MSG_s*)0x1000)
, sizeof(MsgDispatcher_MSG_s)
, (FieldJcArray const*)&reflection_Fields_MsgDispatcher_MSG_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_MsgDispatcher_MSG_s //superclass
, (ClassOffset_idxMtblJcARRAY*)&interfaces_MsgDispatcher_MSG_s //interfaces
, mObjectJc_Modifier_reflectJc
, &mtblMsgDispatcher_MSG.mtbl.head
};

/**Stores all data of a message if the message is queued here. */


const char sign_Mtbl_Entry_MsgDispatcher_MSG[] = "Entry_MsgDispatcher_MSG"; //to mark method tables of all implementations


/*Constructor *//**J2C: autogenerated as default constructor. */
struct Entry_MsgDispatcher_MSG_t* ctorM_Entry_MsgDispatcher_MSG(MemC mthis, ThCxt* _thCxt)
{ Entry_MsgDispatcher_MSG_s* ythis = PTR_MemC(mthis, Entry_MsgDispatcher_MSG_s);  //reference casting to the real class.
  int sizeObj = size_MemC(mthis);
  STACKTRC_TENTRY("ctor_Entry_MsgDispatcher_MSG");
  if(sizeof(Entry_MsgDispatcher_MSG_s) > sizeObj) THROW_s0(IllegalArgumentException, "faut size", sizeObj);
  //j2c: Initialize all class variables:
  {
    //J2C: constructor for embedded element
      INIT_OS_TimeStamp(/*static*/ythis->timestamp);
    //J2C: constructor for embedded element-MemC
      ctorM_VaArgBuffer(/*static*/build_MemC(&ythis->values, sizeof(ythis->values)), 11, _thCxt);
  }/*J2C:No body for constructor*/

  STACKTRC_LEAVE;
  return ythis;
}


int32 _sizeof_Entry_MsgDispatcher_MSG(/*static*/ ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_sizeof_Entry_MsgDispatcher_MSG");
  
  { 
    
    { STACKTRC_LEAVE;
      return 1;
    }
  }
  STACKTRC_LEAVE;
}

extern struct ClassJc_t const reflection_Entry_MsgDispatcher_MSG_s;
extern struct ClassJc_t const reflection_OS_TimeStamp;
extern struct ClassJc_t const reflection_VaArgBuffer;
const struct Reflection_Fields_Entry_MsgDispatcher_MSG_s_t
{ ObjectArrayJc head; FieldJc data[5];
} reflection_Fields_Entry_MsgDispatcher_MSG_s =
{ CONST_ObjectArrayJc(FieldJc, 5, OBJTYPE_FieldJc, null, &reflection_Fields_Entry_MsgDispatcher_MSG_s)
, {
     { "ident"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Entry_MsgDispatcher_MSG_s*)(0x1000))->ident) - (int32)(Entry_MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_Entry_MsgDispatcher_MSG_s
    }
   , { "dst"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Entry_MsgDispatcher_MSG_s*)(0x1000))->dst) - (int32)(Entry_MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_Entry_MsgDispatcher_MSG_s
    }
   , { "text"
    , 0 //nrofArrayElements
    , REFLECTION_char
    , mReference_Modifier_reflectJc//bitModifiers
    , (int16)((int32)(&((Entry_MsgDispatcher_MSG_s*)(0x1000))->text) - (int32)(Entry_MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_Entry_MsgDispatcher_MSG_s
    }
   , { "timestamp"
    , 0 //nrofArrayElements
    , &reflection_OS_TimeStamp
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Entry_MsgDispatcher_MSG_s*)(0x1000))->timestamp) - (int32)(Entry_MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_Entry_MsgDispatcher_MSG_s
    }
   , { "values"
    , 0 //nrofArrayElements
    , &reflection_VaArgBuffer
    , kEmbedded_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Entry_MsgDispatcher_MSG_s*)(0x1000))->values) - (int32)(Entry_MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_Entry_MsgDispatcher_MSG_s
    }
} };
const ClassJc reflection_Entry_MsgDispatcher_MSG_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "Entry_MsgDispatcher_MSG_s"
,  0 //position of ObjectJc
, sizeof(Entry_MsgDispatcher_MSG_s)
, (FieldJcArray const*)&reflection_Fields_Entry_MsgDispatcher_MSG_s
, null //method
, null //superclass
, null //interfaces
, 0    //modifiers
};

/**This class contains some test-counts for debugging. It is a own class because structuring of attributes.
@xxxjava2c=noObject.  //NOTE: ctor without ObjectJc not implemented yet.
*/


const char sign_Mtbl_TestCnt_MsgDispatcher_MSG[] = "TestCnt_MsgDispatcher_MSG"; //to mark method tables of all implementations

typedef struct MtblDef_TestCnt_MsgDispatcher_MSG_t { Mtbl_TestCnt_MsgDispatcher_MSG mtbl; MtblHeadJc end; } MtblDef_TestCnt_MsgDispatcher_MSG;
 extern MtblDef_TestCnt_MsgDispatcher_MSG const mtblTestCnt_MsgDispatcher_MSG;

/*Constructor *//**J2C: autogenerated as default constructor. */
struct TestCnt_MsgDispatcher_MSG_t* ctorO_TestCnt_MsgDispatcher_MSG(ObjectJc* othis, ThCxt* _thCxt)
{ TestCnt_MsgDispatcher_MSG_s* ythis = (TestCnt_MsgDispatcher_MSG_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_TestCnt_MsgDispatcher_MSG");
  checkConsistence_ObjectJc(othis, sizeof(TestCnt_MsgDispatcher_MSG_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_TestCnt_MsgDispatcher_MSG_s, sizeof(TestCnt_MsgDispatcher_MSG_s));  
  //j2c: Initialize all class variables:
  {
  }/*J2C:No body for constructor*/

  STACKTRC_LEAVE;
  return ythis;
}




/**J2C: Reflections and Method-table *************************************************/
const MtblDef_TestCnt_MsgDispatcher_MSG mtblTestCnt_MsgDispatcher_MSG = {
{ { sign_Mtbl_TestCnt_MsgDispatcher_MSG//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_ObjectJc_F //toString
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_TestCnt_MsgDispatcher_MSG_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_TestCnt_MsgDispatcher_MSG_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_TestCnt_MsgDispatcher_MSG, ObjectJc) }
   }
 };

extern struct ClassJc_t const reflection_TestCnt_MsgDispatcher_MSG_s;
const struct Reflection_Fields_TestCnt_MsgDispatcher_MSG_s_t
{ ObjectArrayJc head; FieldJc data[2];
} reflection_Fields_TestCnt_MsgDispatcher_MSG_s =
{ CONST_ObjectArrayJc(FieldJc, 2, OBJTYPE_FieldJc, null, &reflection_Fields_TestCnt_MsgDispatcher_MSG_s)
, {
     { "noOutput"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestCnt_MsgDispatcher_MSG_s*)(0x1000))->noOutput) - (int32)(TestCnt_MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestCnt_MsgDispatcher_MSG_s
    }
   , { "tomuchMsgPerThread"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((TestCnt_MsgDispatcher_MSG_s*)(0x1000))->tomuchMsgPerThread) - (int32)(TestCnt_MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_TestCnt_MsgDispatcher_MSG_s
    }
} };
const ClassJc reflection_TestCnt_MsgDispatcher_MSG_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "TestCnt_MsgDispatcher_MSG_s"
,  0 //position of ObjectJc
, sizeof(TestCnt_MsgDispatcher_MSG_s)
, (FieldJcArray const*)&reflection_Fields_TestCnt_MsgDispatcher_MSG_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_TestCnt_MsgDispatcher_MSG_s //superclass
, null //interfaces
, 0    //modifiers
, &mtblTestCnt_MsgDispatcher_MSG.mtbl.head
};

/**This class contains all infomations for a output. There is an array of this type in MsgDispatcher.
*/


const char sign_Mtbl_Output_MsgDispatcher_MSG[] = "Output_MsgDispatcher_MSG"; //to mark method tables of all implementations


/*Constructor *//**J2C: autogenerated as default constructor. */
struct Output_MsgDispatcher_MSG_t* ctorM_Output_MsgDispatcher_MSG(MemC mthis, ThCxt* _thCxt)
{ Output_MsgDispatcher_MSG_s* ythis = PTR_MemC(mthis, Output_MsgDispatcher_MSG_s);  //reference casting to the real class.
  int sizeObj = size_MemC(mthis);
  STACKTRC_TENTRY("ctor_Output_MsgDispatcher_MSG");
  if(sizeof(Output_MsgDispatcher_MSG_s) > sizeObj) THROW_s0(IllegalArgumentException, "faut size", sizeObj);
  //j2c: Initialize all class variables:
  {
  }/*J2C:No body for constructor*/

  STACKTRC_LEAVE;
  return ythis;
}



void finalize_Output_MsgDispatcher_MSG_F(Output_MsgDispatcher_MSG_s* ythis, ThCxt* _thCxt)
{ STACKTRC_TENTRY("finalize_Output_MsgDispatcher_MSG_F");
  CLEAR_REFJc(ythis->outputIfc);
  STACKTRC_LEAVE;
}


extern struct ClassJc_t const reflection_Output_MsgDispatcher_MSG_s;
extern struct ClassJc_t const reflection_LogMessageFW_i;
extern struct ClassJc_t const reflection_StringJc;
const struct Reflection_Fields_Output_MsgDispatcher_MSG_s_t
{ ObjectArrayJc head; FieldJc data[3];
} reflection_Fields_Output_MsgDispatcher_MSG_s =
{ CONST_ObjectArrayJc(FieldJc, 3, OBJTYPE_FieldJc, null, &reflection_Fields_Output_MsgDispatcher_MSG_s)
, {
     { "name"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((Output_MsgDispatcher_MSG_s*)(0x1000))->name) - (int32)(Output_MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_Output_MsgDispatcher_MSG_s
    }
   , { "outputIfc"
    , 0 //nrofArrayElements
    , &reflection_LogMessageFW_i
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Output_MsgDispatcher_MSG_s*)(0x1000))->outputIfc) - (int32)(Output_MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_Output_MsgDispatcher_MSG_s
    }
   , { "dstInDispatcherThread"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((Output_MsgDispatcher_MSG_s*)(0x1000))->dstInDispatcherThread) - (int32)(Output_MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_Output_MsgDispatcher_MSG_s
    }
} };
const ClassJc reflection_Output_MsgDispatcher_MSG_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "Output_MsgDispatcher_MSG_s"
,  0 //position of ObjectJc
, sizeof(Output_MsgDispatcher_MSG_s)
, (FieldJcArray const*)&reflection_Fields_Output_MsgDispatcher_MSG_s
, null //method
, null //superclass
, null //interfaces
, 0    //modifiers
};

/**Class to organize a dispachter thread.


*/


const char sign_Mtbl_DispatcherThread_MsgDispatcher_MSG[] = "DispatcherThread_MsgDispatcher_MSG"; //to mark method tables of all implementations

typedef struct MtblDef_DispatcherThread_MsgDispatcher_MSG_t { Mtbl_DispatcherThread_MsgDispatcher_MSG mtbl; MtblHeadJc end; } MtblDef_DispatcherThread_MsgDispatcher_MSG;
 extern MtblDef_DispatcherThread_MsgDispatcher_MSG const mtblDispatcherThread_MsgDispatcher_MSG;

/*Constructor */
struct DispatcherThread_MsgDispatcher_MSG_t* ctorO_DispatcherThread_MsgDispatcher_MSG(struct MsgDispatcher_MSG_t* outer, ObjectJc* othis, int32 cycleMillisec, ThCxt* _thCxt)
{ DispatcherThread_MsgDispatcher_MSG_s* ythis = (DispatcherThread_MsgDispatcher_MSG_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_DispatcherThread_MsgDispatcher_MSG");
  checkConsistence_ObjectJc(othis, sizeof(DispatcherThread_MsgDispatcher_MSG_s), null, _thCxt);  
  //J2C:super Constructor
  ctorO_z_ThreadJc(/*static*/othis, "MsgDisptch", _thCxt);
  setReflection_ObjectJc(othis, &reflection_DispatcherThread_MsgDispatcher_MSG_s, sizeof(DispatcherThread_MsgDispatcher_MSG_s));  
  ythis->outer = outer;
  //j2c: Initialize all class variables:
  {
  }
  { 
    
    ythis->cycleMillisec = cycleMillisec;
    start_ThreadJc(& ((* (ythis)).base.super), -1, _thCxt);
  }
  STACKTRC_LEAVE;
  return ythis;
}


void run_DispatcherThread_MsgDispatcher_MSG_F(ObjectJc* ithis, ThCxt* _thCxt)
{ DispatcherThread_MsgDispatcher_MSG_s* ythis = (DispatcherThread_MsgDispatcher_MSG_s*)ithis;
  
  STACKTRC_TENTRY("run_DispatcherThread_MsgDispatcher_MSG_F");
  
  { 
    
    
    while(true)
      { 
        
        TRY
        { 
          
          sleep_ThreadJc(/*static*/ythis->cycleMillisec, _thCxt);
        }_TRY
        CATCH(InterruptedException, exc)
        
          { 
            
            
          }
        END_TRY
        tickAndFlushOrClose_MsgDispatcher_MSG((ythis)->outer, _thCxt);
      }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void run_DispatcherThread_MsgDispatcher_MSG(ObjectJc* ithis, ThCxt* _thCxt)
{ Mtbl_RunnableJc const* mtbl = (Mtbl_RunnableJc const*)getMtbl_ObjectJc(ithis, sign_Mtbl_RunnableJc);
  mtbl->run(ithis, _thCxt);
}



/**J2C: Reflections and Method-table *************************************************/
const MtblDef_DispatcherThread_MsgDispatcher_MSG mtblDispatcherThread_MsgDispatcher_MSG = {
{ { sign_Mtbl_DispatcherThread_MsgDispatcher_MSG//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, { { sign_Mtbl_ThreadJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((0 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    , clone_ObjectJc_F //clone
    , equals_ObjectJc_F //equals
    , finalize_ObjectJc_F //finalize
    , hashCode_ObjectJc_F //hashCode
    , toString_ObjectJc_F //toString
    }
    /**J2C: Mtbl-interfaces of DispatcherThread_MsgDispatcher_MSG: */
  , { { sign_Mtbl_RunnableJc//J2C: Head of methodtable.
      , (struct Size_Mtbl_t*)((1 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
      }
    , run_DispatcherThread_MsgDispatcher_MSG_F //run
    , { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
        , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
        }
      , clone_ObjectJc_F //clone
      , equals_ObjectJc_F //equals
      , finalize_ObjectJc_F //finalize
      , hashCode_ObjectJc_F //hashCode
      , toString_ObjectJc_F //toString
      }
    }
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ThreadJc_s;
 static struct superClasses_DispatcherThread_MsgDispatcher_MSG_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_DispatcherThread_MsgDispatcher_MSG_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ThreadJc_s, OFFSET_Mtbl(Mtbl_DispatcherThread_MsgDispatcher_MSG, ThreadJc) }
   }
 };

extern struct ClassJc_t const reflection_DispatcherThread_MsgDispatcher_MSG_s;
extern struct ClassJc_t const reflection_ConcurrentLinkedQueueJc_s;
extern struct ClassJc_t const reflection_LogMessageFW_i;
extern struct ClassJc_t const reflection_Output_MsgDispatcher_MSG_s;
extern struct ClassJc_t const reflection_TestCnt_MsgDispatcher_MSG_s;
const struct Reflection_Fields_DispatcherThread_MsgDispatcher_MSG_s_t
{ ObjectArrayJc head; FieldJc data[1];
} reflection_Fields_DispatcherThread_MsgDispatcher_MSG_s =
{ CONST_ObjectArrayJc(FieldJc, 1, OBJTYPE_FieldJc, null, &reflection_Fields_DispatcherThread_MsgDispatcher_MSG_s)
, {
     { "cycleMillisec"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((DispatcherThread_MsgDispatcher_MSG_s*)(0x1000))->cycleMillisec) - (int32)(DispatcherThread_MsgDispatcher_MSG_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_DispatcherThread_MsgDispatcher_MSG_s
    }
} };
const ClassJc reflection_DispatcherThread_MsgDispatcher_MSG_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "DispatcherThread_M_her_MSG_s"
,  0 //position of ObjectJc
, sizeof(DispatcherThread_MsgDispatcher_MSG_s)
, (FieldJcArray const*)&reflection_Fields_DispatcherThread_MsgDispatcher_MSG_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_DispatcherThread_MsgDispatcher_MSG_s //superclass
, null //interfaces
, 0    //modifiers
, &mtblDispatcherThread_MsgDispatcher_MSG.mtbl.head
};
