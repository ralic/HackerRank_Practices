/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "J1c/StringPartJc.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "J1c/SpecialCharStringsJc.h"  //reference-association: SpecialCharStringsJc_s
#include "Jc/MathJc.h"  //reference-association: MathJc_s
#include "Jc/ObjectJc.h"  //reference-association: IntegerJc

/**The StringPart class represents a flexible valid part of a character string which spread is changeable.
This is a enhancement of the standard class String or StringBuffer.<br>
The StringPart class is associated to a String. Additionaly 4 Parameters determine the actual part of the String
and the limits of changing this actual part. The followed image is used to explain the spreadness of the parts:<pre>
abcdefghijklmnopqrstuvwxyz  Sample of the whole associated String
=====================     The === indicates the maximal part
-----------             The --- indicates the valid part before some operation
+++++             The +++ indicates the valid part after some operation
</pre>
At a first idea a part is likely a substring.
But the actual part of the string is changeable, without building a new substring.
So some operations of seeking and scanning
are supported. The collectivity methods to scan strings from a file (Reader) are supported from a derivated
class StringScan of this class.<br/>
Types of Methods:
<ul><li>seek: changes the position of the actual (current) string part, do not change the end of the actual part,
from there, seek changes the length. Seek returns this, so concatenation of methods calls is able.</li>
<li>lento: changes the end of the actual string part. </li>
<li>scan: test wether the scanning condition is matched. If so, the actual part is shortened by the overscanning
characters, if no, the bCurrentOk-Flag is set to false and all scanning invokes after are not executed.
The scan methods returns this, so concatenation of methods calls is able.
The last call should be <code>scanOk</code>, see there.</li>
<li>get: Gets an content without changing.</li>
<li>set: Sets a total new content.</li>
<li>Some string methods are also supported like String</li>
</ul>
*/


const char sign_Mtbl_StringPartJc[] = "StringPartJc"; //to mark method tables of all implementations

typedef struct MtblDef_StringPartJc_t { Mtbl_StringPartJc mtbl; MtblHeadJc end; } MtblDef_StringPartJc;
 extern MtblDef_StringPartJc const mtblStringPartJc;
const int32 seekToLeft_StringPartJc = mSeekToLeft__StringPartJc + mSeekBackward__StringPartJc;
const int32 seekBack_StringPartJc = 0x20 + mSeekBackward__StringPartJc;
const char cStartOfText_StringPartJc = (char)(0x2);
const char cEndOfText_StringPartJc = (char)(0x3);

/*Constructor */
struct StringPartJc_t* ctorO_StringPartJc(ObjectJc* othis, ThCxt* _thCxt)
{ StringPartJc_s* ythis = (StringPartJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringPartJc");
  checkConsistence_ObjectJc(othis, sizeof(StringPartJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_StringPartJc_s, sizeof(StringPartJc_s));  
  //j2c: Initialize all class variables:
  {
    ythis->nLineCt = 1;
    ythis->bCurrentOk = true;
    ythis->bStartScan = true;
    ythis->bFound = true;
    /*J2C: newArray*/
      init_ObjectJc(&ythis->nLastIntegerNumber.head.object, sizeof_ARRAYJc(int64, 5), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&ythis->nLastIntegerNumber.head.object, 5, sizeof(int64), null, 0);//J2C: constructor for embedded array;
    ythis->idxLastIntegerNumber = -1;
    /*J2C: newArray*/
      init_ObjectJc(&ythis->nLastFloatNumber.head.object, sizeof_ARRAYJc(double, 5), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&ythis->nLastFloatNumber.head.object, 5, sizeof(double), null, 0);//J2C: constructor for embedded array;
    ythis->idxLastFloatNumber = -1;
    ythis->bitMode = 0;
    set_StringJc(&(ythis->sCommentStart), z_StringJc("/*"));
    set_StringJc(&(ythis->sCommentEnd), z_StringJc("*/"));
    set_StringJc(&(ythis->sCommentToEol), z_StringJc("//"));
  }
  { 
    
    set_StringJc(&(ythis->content), null_StringJc);
    ythis->startMin = ythis->start = /*? assignment*/ythis->startLast = /*? assignment*/0;
    ythis->endLast = ythis->endMax = /*? assignment*/ythis->end = /*? assignment*/0;//report = null;
    
  }
  STACKTRC_LEAVE;
  return ythis;
}



/*Constructor */
struct StringPartJc_t* ctorO_S_StringPartJc(ObjectJc* othis, StringJc content, ThCxt* _thCxt)
{ StringPartJc_s* ythis = (StringPartJc_s*)othis;  //upcasting to the real class.
  Mtbl_StringPartJc const* mtthis = &mtblStringPartJc.mtbl;
  STACKTRC_TENTRY("ctorO_StringPartJc");
  checkConsistence_ObjectJc(othis, sizeof(StringPartJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_StringPartJc_s, sizeof(StringPartJc_s));  
  //j2c: Initialize all class variables:
  {
    ythis->nLineCt = 1;
    ythis->bCurrentOk = true;
    ythis->bStartScan = true;
    ythis->bFound = true;
    /*J2C: newArray*/
      init_ObjectJc(&ythis->nLastIntegerNumber.head.object, sizeof_ARRAYJc(int64, 5), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&ythis->nLastIntegerNumber.head.object, 5, sizeof(int64), null, 0);//J2C: constructor for embedded array;
    ythis->idxLastIntegerNumber = -1;
    /*J2C: newArray*/
      init_ObjectJc(&ythis->nLastFloatNumber.head.object, sizeof_ARRAYJc(double, 5), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&ythis->nLastFloatNumber.head.object, 5, sizeof(double), null, 0);//J2C: constructor for embedded array;
    ythis->idxLastFloatNumber = -1;
    ythis->bitMode = 0;
    set_StringJc(&(ythis->sCommentStart), z_StringJc("/*"));
    set_StringJc(&(ythis->sCommentEnd), z_StringJc("*/"));
    set_StringJc(&(ythis->sCommentToEol), z_StringJc("//"));
  }
  { 
    
    mtthis->assign_S(ythis, content, _thCxt);//report = null;
    
  }
  STACKTRC_LEAVE;
  return ythis;
}



/*Constructor */
struct StringPartJc_t* ctorO_XX_StringPartJc(ObjectJc* othis, struct StringPartJc_t* src, ThCxt* _thCxt)
{ StringPartJc_s* ythis = (StringPartJc_s*)othis;  //upcasting to the real class.
  Mtbl_StringPartJc const* mtthis = &mtblStringPartJc.mtbl;
  STACKTRC_TENTRY("ctorO_StringPartJc");
  checkConsistence_ObjectJc(othis, sizeof(StringPartJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_StringPartJc_s, sizeof(StringPartJc_s));  
  //j2c: Initialize all class variables:
  {
    ythis->nLineCt = 1;
    ythis->bCurrentOk = true;
    ythis->bStartScan = true;
    ythis->bFound = true;
    /*J2C: newArray*/
      init_ObjectJc(&ythis->nLastIntegerNumber.head.object, sizeof_ARRAYJc(int64, 5), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&ythis->nLastIntegerNumber.head.object, 5, sizeof(int64), null, 0);//J2C: constructor for embedded array;
    ythis->idxLastIntegerNumber = -1;
    /*J2C: newArray*/
      init_ObjectJc(&ythis->nLastFloatNumber.head.object, sizeof_ARRAYJc(double, 5), 0);   //J2C: ctor embedded array.
      ctorO_ObjectArrayJc(&ythis->nLastFloatNumber.head.object, 5, sizeof(double), null, 0);//J2C: constructor for embedded array;
    ythis->idxLastFloatNumber = -1;
    ythis->bitMode = 0;
    set_StringJc(&(ythis->sCommentStart), z_StringJc("/*"));
    set_StringJc(&(ythis->sCommentEnd), z_StringJc("*/"));
    set_StringJc(&(ythis->sCommentToEol), z_StringJc("//"));
  }
  { 
    
    mtthis->assign_XX(ythis, src, _thCxt);//report = null;
    
  }
  STACKTRC_LEAVE;
  return ythis;
}



/**Sets the content to the given string, forgets the old content*/
struct StringPartJc_t* assign_S_StringPartJc_F(StringPartJc_s* ythis, StringJc content, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assign_S_StringPartJc_F");
  
  { 
    
    set_StringJc(&(ythis->content), content);
    ythis->startMin = ythis->startLast = /*? assignment*/ythis->start = /*? assignment*/0;
    ythis->endMax = ythis->end = /*? assignment*/ythis->endLast = /*? assignment*/length_StringJc(content);
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* assign_S_StringPartJc(StringPartJc_s* ythis, StringJc content, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->assign_S(ythis, content, _thCxt);
}


/**Sets the StringPart with the same String object as the given StringPart, forgets the old content.*/
struct StringPartJc_t* assign_XX_StringPartJc_F(StringPartJc_s* ythis, struct StringPartJc_t* src, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assign_XX_StringPartJc_F");
  
  { 
    
    if(src == ythis) 
    { //:set from the own instance: the maxPart is the actual one.
      
      
      ythis->startMin = ythis->startLast = /*? assignment*/ythis->start;
      ythis->endMax = ythis->endLast = /*? assignment*/ythis->end;
    }
    else 
    { //:set from a other instance, inherit the content.
      
      
      set_StringJc(&(ythis->content), src->content);
      ythis->startMin = ythis->startLast = /*? assignment*/ythis->start = /*? assignment*/src->start;
      ythis->endMax = ythis->end = /*? assignment*/ythis->endLast = /*? assignment*/src->end;
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* assign_XX_StringPartJc(StringPartJc_s* ythis, struct StringPartJc_t* src, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->assign_XX(ythis, src, _thCxt);
}


/**Sets the content of the StringPart , forgets the old content*/
struct StringPartJc_t* assignFromEnd_StringPartJc_F(StringPartJc_s* ythis, struct StringPartJc_t* src, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assignFromEnd_StringPartJc_F");
  
  { 
    
    set_StringJc(&(ythis->content), src->content);
    ythis->startLast = ythis->start;
    ythis->startMin = ythis->start = /*? assignment*/src->end;//from actual end
    
    ythis->endLast = ythis->endMax = /*? assignment*/ythis->end = /*? assignment*/src->endMax;//from maximal end
    
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* assignFromEnd_StringPartJc(StringPartJc_s* ythis, struct StringPartJc_t* src, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->assignFromEnd(ythis, src, _thCxt);
}


/**Set the mode of ignoring comments.*/
bool setIgnoreComment_b_StringPartJc_F(StringPartJc_s* ythis, bool bSet, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreComment_b_StringPartJc_F");
  
  { 
    bool bRet; 
    
    
    bRet = (ythis->bitMode & mSkipOverCommentInsideText_mode_StringPartJc) != 0;
    if(bSet) ythis->bitMode |= mSkipOverCommentInsideText_mode_StringPartJc;
    else ythis->bitMode &= ~mSkipOverCommentInsideText_mode_StringPartJc;
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool setIgnoreComment_b_StringPartJc(StringPartJc_s* ythis, bool bSet, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->setIgnoreComment_b(ythis, bSet, _thCxt);
}


/**Set the character string of inline commentmode of ignoring comments.*/
bool setIgnoreComment_SS_StringPartJc_F(StringPartJc_s* ythis, StringJc sStart, StringJc sEnd, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreComment_SS_StringPartJc_F");
  
  { 
    bool bRet; 
    
    
    bRet = (ythis->bitMode & mSkipOverCommentInsideText_mode_StringPartJc) != 0;
    ythis->bitMode |= mSkipOverCommentInsideText_mode_StringPartJc;
    set_StringJc(&(ythis->sCommentStart), sStart);
    set_StringJc(&(ythis->sCommentEnd), sEnd);
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool setIgnoreComment_SS_StringPartJc(StringPartJc_s* ythis, StringJc sStart, StringJc sEnd, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->setIgnoreComment_SS(ythis, sStart, sEnd, _thCxt);
}


/**Set the mode of ignoring comments to end of line.*/
bool setIgnoreEndlineComment_b_StringPartJc_F(StringPartJc_s* ythis, bool bSet, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreEndlineComment_b_StringPartJc_F");
  
  { 
    bool bRet; 
    
    
    bRet = (ythis->bitMode & mSkipOverCommentToEol_mode_StringPartJc) != 0;
    if(bSet) ythis->bitMode |= mSkipOverCommentToEol_mode_StringPartJc;
    else ythis->bitMode &= ~mSkipOverCommentToEol_mode_StringPartJc;
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool setIgnoreEndlineComment_b_StringPartJc(StringPartJc_s* ythis, bool bSet, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->setIgnoreEndlineComment_b(ythis, bSet, _thCxt);
}


/**Set the character string introducing the comments to end of line.*/
bool setIgnoreEndlineComment_S_StringPartJc_F(StringPartJc_s* ythis, StringJc sStart, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreEndlineComment_S_StringPartJc_F");
  
  { 
    bool bRet; 
    
    
    bRet = (ythis->bitMode & mSkipOverCommentToEol_mode_StringPartJc) != 0;
    ythis->bitMode |= mSkipOverCommentToEol_mode_StringPartJc;
    set_StringJc(&(ythis->sCommentToEol), sStart);
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool setIgnoreEndlineComment_S_StringPartJc(StringPartJc_s* ythis, StringJc sStart, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->setIgnoreEndlineComment_S(ythis, sStart, _thCxt);
}


/**Set the mode of ignoring whitespaces.*/
bool setIgnoreWhitespaces_StringPartJc_F(StringPartJc_s* ythis, bool bSet, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIgnoreWhitespaces_StringPartJc_F");
  
  { 
    bool bRet; 
    
    
    bRet = (ythis->bitMode & mSkipOverWhitespace_mode_StringPartJc) != 0;
    if(bSet) ythis->bitMode |= mSkipOverWhitespace_mode_StringPartJc;
    else ythis->bitMode &= ~mSkipOverWhitespace_mode_StringPartJc;
    { STACKTRC_LEAVE;
      return bRet;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool setIgnoreWhitespaces_StringPartJc(StringPartJc_s* ythis, bool bSet, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->setIgnoreWhitespaces(ythis, bSet, _thCxt);
}


/**Sets the start of the maximal part to the actual start of the valid part.*/
struct StringPartJc_t* setBeginMaxPart_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setBeginMaxPart_StringPartJc_F");
  
  { 
    
    ythis->startMin = ythis->start;
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* setBeginMaxPart_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->setBeginMaxPart(ythis, _thCxt);
}


/**Sets the start of the part to the exclusively end, set the end to the end of the content.*/
struct StringPartJc_t* fromEnd_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("fromEnd_StringPartJc_F");
  
  { 
    
    ythis->startLast = ythis->start;
    ythis->endLast = ythis->end;
    ythis->start = ythis->end;
    ythis->end = ythis->endMax;
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* fromEnd_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->fromEnd(ythis, _thCxt);
}


/**get the Line ct*/
int32 getLineCt_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLineCt_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return ythis->nLineCt;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 getLineCt_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->getLineCt(ythis, _thCxt);
}


/**Gets the length of the valid part*/
int32 getLen_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("getLen_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return mtthis->length(ythis, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 getLen_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->getLen(ythis, _thCxt);
}


/**Returns the valid lenght of the acutual part*/
int32 length_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("length_StringPartJc_F");
  
  { 
    
    if(ythis->end > ythis->start) { STACKTRC_LEAVE;
      return ythis->end - ythis->start;
    }
    else { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 length_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->length(ythis, _thCxt);
}


/**Returns the lenght of the maximal part from current position*/
int32 lengthMaxPart_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lengthMaxPart_StringPartJc_F");
  
  { 
    
    if(ythis->endMax > ythis->start) { STACKTRC_LEAVE;
      return ythis->endMax - ythis->start;
    }
    else { STACKTRC_LEAVE;
      return 0;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 lengthMaxPart_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->lengthMaxPart(ythis, _thCxt);
}


/**Sets the endposition of the part of string to the given chars after start.*/
struct StringPartJc_t* lento_i_StringPartJc_F(StringPartJc_s* ythis, int32 len, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("lento_i_StringPartJc_F");
  
  { 
    int32 endNew; 
    
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    ythis->endLast = ythis->end;
    endNew = ythis->start + len;
    if(endNew < ythis->start) /***/
    mtthis->throwIndexOutOfBoundsException(ythis, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "lento(int) negative:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, (endNew - ythis->start), _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), _thCxt);
    if(endNew > ythis->endMax) /***/
    mtthis->throwIndexOutOfBoundsException(ythis, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "lento(int) after endMax:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, (endNew - ythis->endMax), _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), _thCxt);
    ythis->end = endNew;
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* lento_i_StringPartJc(StringPartJc_s* ythis, int32 len, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->lento_i(ythis, len, _thCxt);
}


/**Sets the endposition of the part of string to exclusively the char cc.*/
struct StringPartJc_t* lento_c_StringPartJc_F(StringPartJc_s* ythis, char cc, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lento_c_StringPartJc_F");
  
  { 
    int32 pos; 
    
    StringJc _temp1_1; //J2C: temporary references for concatenation
    
    ythis->endLast = ythis->end;
    pos = 
      ( _temp1_1= substring_StringJc(ythis->content, ythis->start, ythis->end, _thCxt)
      , indexOf_C_StringJc(_temp1_1, cc)
      );
    ythis->bFound = (pos >= 0);
    if(pos >= 0) 
    { 
      
      ythis->end = ythis->start + pos;
    }
    else 
    { 
      
      ythis->end = ythis->start;
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* lento_c_StringPartJc(StringPartJc_s* ythis, char cc, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->lento_c(ythis, cc, _thCxt);
}


/**Sets the endposition of the part of string to exclusively the given string.*/
struct StringPartJc_t* lento_S_StringPartJc_F(StringPartJc_s* ythis, StringJc ss, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("lento_S_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return mtthis->lento_Si(ythis, ss, seekNormal_StringPartJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* lento_S_StringPartJc(StringPartJc_s* ythis, StringJc ss, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->lento_S(ythis, ss, _thCxt);
}


/**Sets the endposition of the part of string to exclusively the given string.*/
struct StringPartJc_t* lento_Si_StringPartJc_F(StringPartJc_s* ythis, StringJc ss, int32 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lento_Si_StringPartJc_F");
  
  { 
    int32 pos; 
    
    StringJc _temp1_1; //J2C: temporary references for concatenation
    
    ythis->endLast = ythis->end;
    pos = 
      ( _temp1_1= substring_StringJc(ythis->content, ythis->start, ythis->end, _thCxt)
      , indexOf_s_StringJc(_temp1_1, ss)
      );
    ythis->bFound = (pos >= 0);
    if(pos >= 0) 
    { 
      
      ythis->end = ythis->start + pos;
      if((mode & seekEnd_StringPartJc) != 0) 
      { 
        
        ythis->end += length_StringJc(ss);
      }
    }
    else 
    { 
      
      ythis->end = ythis->start;
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* lento_Si_StringPartJc(StringPartJc_s* ythis, StringJc ss, int32 mode, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->lento_Si(ythis, ss, mode, _thCxt);
}


/**Sets the endposition of the part of string to the end of the identifier which is beginning on start.*/
struct StringPartJc_t* lentoIdentifier_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("lentoIdentifier_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return mtthis->lentoIdentifier_SS(ythis, null_StringJc, null_StringJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* lentoIdentifier_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->lentoIdentifier(ythis, _thCxt);
}


/**Sets the endposition of the part of string to the end of the identifier which is beginning on start.*/
struct StringPartJc_t* lentoIdentifier_SS_StringPartJc_F(StringPartJc_s* ythis, StringJc additionalStartChars, StringJc additionalChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lentoIdentifier_SS_StringPartJc_F");
  
  { 
    
    ythis->endLast = ythis->end;
    ythis->end = ythis->start;
    if(ythis->end >= ythis->endMax) 
    { 
      
      ythis->bFound = false;
    }
    else 
    { 
      char cc; 
      
      
      cc = charAt_StringJc(ythis->content, ythis->end);
      if(cc == '_' || (cc >= 'A' && cc <= 'Z') || (cc >= 'a' && cc <= 'z') || (additionalStartChars.ptr__!= null && indexOf_C_StringJc(additionalStartChars, cc) >= 0)) 
      { 
        
        ythis->end += 1;
        
        while(ythis->end < ythis->endMax && ((cc = /*? assignment*/charAt_StringJc(ythis->content, ythis->end)) == '_' || (cc >= '0' && cc <= '9') || (cc >= 'A' && cc <= 'Z') || (cc >= 'a' && cc <= 'z') || (additionalChars.ptr__!= null && indexOf_C_StringJc(additionalChars, cc) >= 0)))
          { 
            
            ythis->end += 1;
          }
      }
      ythis->bFound = (ythis->end > ythis->start);
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* lentoIdentifier_SS_StringPartJc(StringPartJc_s* ythis, StringJc additionalStartChars, StringJc additionalChars, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->lentoIdentifier_SS(ythis, additionalStartChars, additionalChars, _thCxt);
}


/**Sets the len to the first position of any given char, but not if the char is escaped.*/
struct StringPartJc_t* lentoAnyNonEscapedChar_StringPartJc_F(StringPartJc_s* ythis, StringJc sCharsEnd, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("lentoAnyNonEscapedChar_StringPartJc_F");
  
  { 
    
    if(ythis->bCurrentOk) 
    { 
      char cEscape = '\\'; 
      int32 pos; 
      
      
      cEscape = '\\';
      ythis->endLast = ythis->end;
      pos = mtthis->indexOfAnyChar_Sii(ythis, sCharsEnd, 0, maxToTest, _thCxt);
      
      while(pos > ythis->start + 1 && charAt_StringJc(ythis->content, pos - 1) == cEscape)
        { //:the escape char is before immediately. It means, the end char is not matched.
          
          
          pos = mtthis->indexOfAnyChar_Sii(ythis, sCharsEnd, pos + 1 - ythis->start, maxToTest, _thCxt);
        }
      if(pos < 0) 
      { 
        
        ythis->end = ythis->start;
        ythis->bFound = false;
      }
      else 
      { 
        
        ythis->end = ythis->start + pos;
        ythis->bFound = true;
      }
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* lentoAnyNonEscapedChar_StringPartJc(StringPartJc_s* ythis, StringJc sCharsEnd, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->lentoAnyNonEscapedChar(ythis, sCharsEnd, maxToTest, _thCxt);
}


/**Sets the len to the first position of any given char, but not if the char is escaped.*/
struct StringPartJc_t* lentoNonEscapedString_StringPartJc_F(StringPartJc_s* ythis, StringJc sEnd, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("lentoNonEscapedString_StringPartJc_F");
  
  { 
    
    if(ythis->bCurrentOk) 
    { 
      char cEscape = '\\'; 
      int32 pos; 
      
      
      cEscape = '\\';
      ythis->endLast = ythis->end;
      pos = mtthis->indexOf_Sii(ythis, sEnd, 0, maxToTest, _thCxt);
      
      while(pos > 1 && charAt_StringJc(ythis->content, ythis->start + pos - 1) == cEscape)
        { //:the escape char is before immediately. It means, the end char is not matched.
          
          
          pos = mtthis->indexOf_Sii(ythis, sEnd, pos + 1, maxToTest, _thCxt);
        }
      if(pos < 0) 
      { 
        
        ythis->end = ythis->start;
        ythis->bFound = false;
      }
      else 
      { 
        
        ythis->end = ythis->start + pos;
        ythis->bFound = true;
      }
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* lentoNonEscapedString_StringPartJc(StringPartJc_s* ythis, StringJc sEnd, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->lentoNonEscapedString(ythis, sEnd, maxToTest, _thCxt);
}


/**Displaces the start of the part for some chars to left or to right.*/
struct StringPartJc_t* seek_i_StringPartJc_F(StringPartJc_s* ythis, int32 nr, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("seek_i_StringPartJc_F");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    ythis->startLast = ythis->start;
    ythis->start += nr;
    if(ythis->start > ythis->end) /***/
    mtthis->throwIndexOutOfBoundsException(ythis, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "seek=", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, nr, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, " start=", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, (ythis->start - nr), _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, " end=", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, ythis->end, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), _thCxt);
    else if(ythis->start < ythis->startMin) /***/
    mtthis->throwIndexOutOfBoundsException(ythis, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "seek=", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, nr, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, " start=", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, (ythis->start - nr), _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, " start-min=", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, ythis->startMin, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), _thCxt);
    ythis->bFound = true;
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* seek_i_StringPartJc(StringPartJc_s* ythis, int32 nr, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->seek_i(ythis, nr, _thCxt);
}


/**Displaces the start of the part to the first char it is no whitespace.*/
struct StringPartJc_t* seekNoWhitespace_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekNoWhitespace_StringPartJc_F");
  
  { 
    
    ythis->startLast = ythis->start;
    
    while(ythis->start < ythis->end && indexOf_C_StringJc(zI_StringJc(" \t\r\n\f",5), charAt_StringJc(ythis->content, ythis->start)) >= 0)
      { 
        
        ythis->start += 1;
      }
    ythis->bFound = (ythis->start > ythis->startLast);
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* seekNoWhitespace_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->seekNoWhitespace(ythis, _thCxt);
}


/**skip over comment and whitespaces*/
struct StringPartJc_t* skipWhitespaceAndComment_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("skipWhitespaceAndComment_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return mtthis->seekNoWhitespaceOrComments(ythis, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* skipWhitespaceAndComment_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->skipWhitespaceAndComment(ythis, _thCxt);
}


/**Displaces the start of the part to the first char it is no whitespace or comment.*/
struct StringPartJc_t* seekNoWhitespaceOrComments_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("seekNoWhitespaceOrComments_StringPartJc_F");
  
  { 
    int32 start00; 
    int32 start0 = 0; 
    
    
    start00 = ythis->start;
    /*no initvalue*/
    do 
      { 
        
        start0 = ythis->start;
        if((ythis->bitMode & mSkipOverWhitespace_mode_StringPartJc) != 0) 
        { 
          
          mtthis->seekNoWhitespace(ythis, _thCxt);
        }
        if((ythis->bitMode & mSkipOverCommentInsideText_mode_StringPartJc) != 0) 
        { 
          StringJc _temp3_1; //J2C: temporary references for concatenation
          
          if(
          ( _temp3_1= mtthis->getCurrentPart(ythis, _thCxt)
          , startsWith_StringJc(_temp3_1, ythis->sCommentStart)
          )) 
          { 
            
            mtthis->seek_Si(ythis, ythis->sCommentEnd, seekEnd_StringPartJc, _thCxt);
          }
        }
        if((ythis->bitMode & mSkipOverCommentToEol_mode_StringPartJc) != 0) 
        { 
          StringJc _temp3_1; //J2C: temporary references for concatenation
          
          if(
          ( _temp3_1= mtthis->getCurrentPart(ythis, _thCxt)
          , startsWith_StringJc(_temp3_1, ythis->sCommentToEol)
          )) 
          { 
            
            mtthis->seek_ci(ythis, '\n', seekEnd_StringPartJc, _thCxt);
          }
        }
      }while(ythis->start != start0);//:TRICKY: if something is done, repeat all conditions.
    
    ythis->bFound = (ythis->start > start00);
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* seekNoWhitespaceOrComments_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->seekNoWhitespaceOrComments(ythis, _thCxt);
}


/****/
bool isFound_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("isFound_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return mtthis->found(ythis, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool isFound_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->isFound(ythis, _thCxt);
}


/**Returns true, if the last called seek__(), lento__() or skipWhitespaceAndComment()*/
bool found_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("found_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return ythis->bFound;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool found_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->found(ythis, _thCxt);
}


/**Displaces the start of the part to the leftest possible start.*/
struct StringPartJc_t* seekBegin_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekBegin_StringPartJc_F");
  
  { 
    
    ythis->start = ythis->startLast = /*? assignment*/ythis->startMin;
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* seekBegin_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->seekBegin(ythis, _thCxt);
}


/**Searchs the given String inside the valid part, posits the start of the part to the begin of the searched string.*/
struct StringPartJc_t* seek_Si_StringPartJc_F(StringPartJc_s* ythis, StringJc sSeek, int32 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seek_Si_StringPartJc_F");
  
  { 
    StringJc sSeekArea = NULL_StringJc; 
    int32 posNotFound = 0; 
    int32 pos = 0; 
    
    
    ythis->startLast = ythis->start;
    /*no initvalue*/
    /*no initvalue*/
    if((mode & mSeekToLeft__StringPartJc) == mSeekToLeft__StringPartJc) 
    { 
      int32 posAreaEnd; 
      
      
      posAreaEnd = ythis->start + length_StringJc(sSeek) - 1;
      if(posAreaEnd > ythis->endMax) posAreaEnd = ythis->endMax;//but not over the end.
      
      sSeekArea = substring_StringJc(ythis->content, ythis->startMin, posAreaEnd, _thCxt)/*J2C:non-persistent*/;
      posNotFound = ythis->start;//if not found, the rightest position of area
      
    }
    else 
    { 
      
      sSeekArea = substring_StringJc(ythis->content, ythis->start, ythis->end, _thCxt)/*J2C:non-persistent*/;
      posNotFound = ythis->end;//if not found, the rightest position of area
      
    }
    /*no initvalue*/
    if((mode & mSeekBackward__StringPartJc) == mSeekBackward__StringPartJc) 
    { 
      
      pos = lastIndexOf_s_StringJc(sSeekArea, sSeek);
    }
    else 
    { 
      
      pos = indexOf_s_StringJc(sSeekArea, sSeek);
    }
    if(pos < 0) 
    { 
      
      ythis->start = posNotFound;
      ythis->bFound = false;
    }
    else 
    { 
      
      ythis->bFound = true;
      if((mode & mSeekToLeft__StringPartJc) == mSeekToLeft__StringPartJc) ythis->start = ythis->startMin + pos;
      else ythis->start = ythis->start + pos;
      if((mode & seekEnd_StringPartJc) == seekEnd_StringPartJc) 
      { 
        
        ythis->start += length_StringJc(sSeek);
      }
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* seek_Si_StringPartJc(StringPartJc_s* ythis, StringJc sSeek, int32 mode, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->seek_Si(ythis, sSeek, mode, _thCxt);
}


/**Searchs the given String inside the valid part, posits the start of the part to the begin of the searched string.*/
struct StringPartJc_t* seekAnyString_StringPartJc_F(StringPartJc_s* ythis, StringJc_Y* strings, int32_Y* nrofFoundString, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("seekAnyString_StringPartJc_F");
  
  { 
    int32 pos = 0; 
    
    
    ythis->startLast = ythis->start;
    /*no initvalue*/
    pos = mtthis->indexOfAnyString(ythis, strings, 0, MAX_VALUE_IntegerJc, nrofFoundString, null, _thCxt);
    if(pos < 0) 
    { 
      
      ythis->bFound = false;
      ythis->start = ythis->end;
    }
    else 
    { 
      
      ythis->bFound = true;
      ythis->start = ythis->start + pos;
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* seekAnyString_StringPartJc(StringPartJc_s* ythis, StringJc_Y* strings, int32_Y* nrofFoundString, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->seekAnyString(ythis, strings, nrofFoundString, _thCxt);
}


/**Searchs the given character inside the valid part, posits the start of the part to the begin of the searched char.*/
struct StringPartJc_t* seek_ci_StringPartJc_F(StringPartJc_s* ythis, char cSeek, int32 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seek_ci_StringPartJc_F");
  
  { 
    StringJc sSeekArea = NULL_StringJc; 
    int32 posNotFound = 0; 
    int32 pos = 0; 
    
    
    ythis->startLast = ythis->start;
    /*no initvalue*/
    /*no initvalue*/
    if((mode & mSeekToLeft__StringPartJc) == mSeekToLeft__StringPartJc) 
    { 
      int32 posAreaEnd; 
      
      
      posAreaEnd = ythis->start;
      if(posAreaEnd > ythis->endMax) posAreaEnd = ythis->endMax;//but not over the end.
      
      sSeekArea = substring_StringJc(ythis->content, ythis->startMin, posAreaEnd, _thCxt)/*J2C:non-persistent*/;
      posNotFound = ythis->start;//if not found, the rightest position of area
      
    }
    else 
    { 
      
      sSeekArea = substring_StringJc(ythis->content, ythis->start, ythis->end, _thCxt)/*J2C:non-persistent*/;
      posNotFound = ythis->end;//if not found, the rightest position of area
      
    }
    /*no initvalue*/
    if((mode & mSeekBackward__StringPartJc) == mSeekBackward__StringPartJc) pos = lastIndexOf_C_StringJc(sSeekArea, cSeek);
    else pos = indexOf_C_StringJc(sSeekArea, cSeek);
    if(pos < 0) 
    { 
      
      ythis->start = posNotFound;
      ythis->bFound = false;
    }
    else 
    { 
      
      ythis->bFound = true;
      if((mode & mSeekToLeft__StringPartJc) == mSeekToLeft__StringPartJc) ythis->start = ythis->startMin + pos;
      else ythis->start = ythis->start + pos;
      if((mode & seekEnd_StringPartJc) == seekEnd_StringPartJc) 
      { 
        
        ythis->start += 1;
      }
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* seek_ci_StringPartJc(StringPartJc_s* ythis, char cSeek, int32 mode, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->seek_ci(ythis, cSeek, mode, _thCxt);
}


/**Searchs the given String inside the valid part, posits the start of the part after the end of the searched string.*/
struct StringPartJc_t* xxxseekEnd_StringPartJc_F(StringPartJc_s* ythis, StringJc sSeek, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("xxxseekEnd_StringPartJc_F");
  
  { 
    int32 pos; 
    
    
    ythis->startLast = ythis->start;
    pos = indexOf_sI_StringJc(ythis->content, sSeek, ythis->start);
    if(pos >= 0) pos += length_StringJc(sSeek);
    if(pos > ythis->end || pos < 0) ythis->start = ythis->end;
    else ythis->start = pos;
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* xxxseekEnd_StringPartJc(StringPartJc_s* ythis, StringJc sSeek, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->xxxseekEnd(ythis, sSeek, _thCxt);
}


/**Posits the start of the part after all of the chars given in the parameter string.*/
struct StringPartJc_t* seekNoChar_StringPartJc_F(StringPartJc_s* ythis, StringJc sChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("seekNoChar_StringPartJc_F");
  
  { 
    
    ythis->startLast = ythis->start;
    
    while(ythis->start < ythis->end && indexOf_C_StringJc(sChars, charAt_StringJc(ythis->content, ythis->start)) >= 0)ythis->start += 1;
    if(ythis->start < ythis->end) ythis->bFound = true;
    else ythis->bFound = false;
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* seekNoChar_StringPartJc(StringPartJc_s* ythis, StringJc sChars, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->seekNoChar(ythis, sChars, _thCxt);
}


/**Returns the position of one of the chars in sChars within the part, started inside the part with fromIndex,*/
int32 indexOfAnyChar_Sii_StringPartJc_F(StringPartJc_s* ythis, StringJc sChars, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfAnyChar_Sii_StringPartJc_F");
  
  { 
    int32 pos; 
    int32 max; 
    int32 nChars; 
    
    
    pos = ythis->start + fromWhere;
    max = (ythis->end - pos) < maxToTest ? ythis->end : pos + maxToTest;
    
    while(pos < max && indexOf_C_StringJc(sChars, charAt_StringJc(ythis->content, pos)) < 0)pos += 1;
    nChars = pos - ythis->start;
    if(pos < max || (pos == max && indexOf_C_StringJc(sChars, cEndOfText_StringPartJc) >= 0)) 
    { 
      
      nChars = pos - ythis->start;
    }
    else 
    { 
      
      nChars = -1;
    }
    { STACKTRC_LEAVE;
      return nChars;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 indexOfAnyChar_Sii_StringPartJc(StringPartJc_s* ythis, StringJc sChars, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->indexOfAnyChar_Sii(ythis, sChars, fromWhere, maxToTest, _thCxt);
}


/**Returns the last position of one of the chars in sChars*/
int32 lastIndexOfAnyChar_StringPartJc_F(StringPartJc_s* ythis, StringJc sChars, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lastIndexOfAnyChar_StringPartJc_F");
  
  { 
    int32 pos; 
    int32 min; 
    int32 index; 
    
    
    pos = (ythis->end - ythis->start) < maxToTest ? ythis->end - 1 : ythis->start + maxToTest - 1;
    min = ythis->start + fromWhere;
    
    while(pos >= min && indexOf_C_StringJc(sChars, charAt_StringJc(ythis->content, pos)) < 0)
      { 
        
        pos -= 1;
      }
    index = pos >= min ? pos - ythis->start : -1;
    { STACKTRC_LEAVE;
      return index;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 lastIndexOfAnyChar_StringPartJc(StringPartJc_s* ythis, StringJc sChars, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->lastIndexOfAnyChar(ythis, sChars, fromWhere, maxToTest, _thCxt);
}


/**Returns the position of one of the chars in sChars within the part, started inside the part with fromIndex,*/
int32 indexOfAnyString_StringPartJc_F(StringPartJc_s* ythis, StringJc_Y* listStrings, int32 fromWhere, int32 maxToTest, int32_Y* nrofFoundString, StringJc_Y* foundString, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("indexOfAnyString_StringPartJc_F");
  
  { 
    int32 pos; 
    int32 max; 
    StringBuilderJc sFirstCharBuffer = { 0 };   /**/
    bool acceptToEndOfText = false; 
    StringJc sFirstChars;   /**/
    bool found = false; 
    int32 nChars = 0; 
    
    
    pos = ythis->start + fromWhere;
    max = (ythis->end - pos) < maxToTest ? ythis->end : pos + maxToTest;
    ASSERT(/*static*/listStrings->head.length < 100);//static size is need
    
    
    //J2C: constructor for embedded element-ObjectJc
    init_ObjectJc(&(sFirstCharBuffer.base.object), sizeof(sFirstCharBuffer), 0); 
    ctorO_I_StringBuilderJc(/*static*/&(sFirstCharBuffer.base.object), 100, _thCxt);
    acceptToEndOfText = false;
    /**Compose a String with all first chars, to test whether a current char of src is equal. */
    
    { 
      int32 ii = -1; 
      
      
      ii = -1;
      
      while(++ii < listStrings->head.length)
        { //:String sString = (String)(iter.next());
          
          StringJc sString; 
          
          
          sString = listStrings->data[ii]/*J2C:non-persistent*/;
          if(charAt_StringJc(sString, 0) == cEndOfText_StringPartJc) 
          { 
            
            acceptToEndOfText = true;
          }
          else 
          { 
            
            append_C_StringBuilderJc(& (sFirstCharBuffer), charAt_StringJc(sString, 0), _thCxt);
          }
        }
    }
    sFirstChars = toStringNonPersist_StringBuilderJc(& ((sFirstCharBuffer).base.object), _thCxt)/*J2C:non-persistent*/;
    found = false;
    
    while(!found && pos < max)
      { 
        int32 nrofFoundString1 = -1; 
        
        
        nrofFoundString1 = -1;
        /**increment over not matching chars, test all first chars: */
        
        while(pos < max && (nrofFoundString1 = /*? assignment*/indexOf_C_StringJc(sFirstChars, charAt_StringJc(ythis->content, pos))) < 0)pos += 1;
        if(pos < max) 
        { 
          int32 ii = -1;   /*a fist matching char is found! test wether or not the whole string is matched.*/
          
          
          ii = -1;
          
          while(!found && ++ii < listStrings->head.length)
            { //:String sString = (String)(iter.next());
              
              StringJc sString; 
              int32 testLen; 
              
              StringJc _temp4_1; //J2C: temporary references for concatenation
              
              sString = listStrings->data[ii]/*J2C:non-persistent*/;
              testLen = length_StringJc(sString);
              if((max - pos) >= testLen && 
            ( _temp4_1= mtthis->substring(ythis, pos, pos + testLen, _thCxt)
            , equals_StringJc(_temp4_1, sString)
            )) 
              { 
                
                found = true;
                if(foundString != null) 
                { 
                  
                  foundString->data[0] = sString/*J2C:non-persistent*/;
                }
                if(nrofFoundString != null) 
                { 
                  
                  nrofFoundString->data[0] = ii;
                }
              }//else { nrofFoundString1 +=1; }
              
            }
          if(!found) 
          { 
            
            pos += 1;
          }//check from the next char because no string matches.
          
        }
      }
    /*no initvalue*/
    if(pos < max || (pos == max && acceptToEndOfText)) 
    { 
      
      nChars = pos - ythis->start;
    }
    else 
    { 
      
      nChars = -1;
      if(foundString != null) 
      { 
        
        foundString->data[0] = null_StringJc/*J2C:non-persistent*/;
      }
      if(nrofFoundString != null) 
      { 
        
        nrofFoundString->data[0] = -1;
      }
    }
    { STACKTRC_LEAVE;
      return nChars;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 indexOfAnyString_StringPartJc(StringPartJc_s* ythis, StringJc_Y* listStrings, int32 fromWhere, int32 maxToTest, int32_Y* nrofFoundString, StringJc_Y* foundString, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->indexOfAnyString(ythis, listStrings, fromWhere, maxToTest, nrofFoundString, foundString, _thCxt);
}


/**Searches any char contented in sChars,*/
int32 indexOfAnyCharOutsideQuotion_StringPartJc_F(StringPartJc_s* ythis, StringJc sChars, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("indexOfAnyCharOutsideQuotion_StringPartJc_F");
  
  { 
    int32 pos; 
    int32 max; 
    bool bNotFound = true; 
    
    
    pos = ythis->start + fromWhere;
    max = (ythis->end - pos) < maxToTest ? ythis->end : ythis->start + maxToTest;
    bNotFound = true;
    
    while(pos < max && bNotFound)
      { 
        char cc; 
        
        
        cc = charAt_StringJc(ythis->content, pos);
        if(cc == '\"') 
        { 
          int32 endQuotion; 
          
          
          endQuotion = mtthis->indexEndOfQuotion(ythis, '\"', pos - ythis->start, max - ythis->start, _thCxt);
          if(endQuotion < 0) 
          { 
            
            pos = max;
          }
          else 
          { 
            
            pos = endQuotion + ythis->start;
          }
        }
        else 
        { 
          
          if(indexOf_C_StringJc(sChars, cc) >= 0) 
          { 
            
            bNotFound = false;
          }
          else 
          { 
            
            pos += 1;
          }
        }
      }
    { STACKTRC_LEAVE;
      return (bNotFound) ? -1 : (pos - ythis->start);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 indexOfAnyCharOutsideQuotion_StringPartJc(StringPartJc_s* ythis, StringJc sChars, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->indexOfAnyCharOutsideQuotion(ythis, sChars, fromWhere, maxToTest, _thCxt);
}


/**Searches the end of a quotion string.*/
int32 indexEndOfQuotion_StringPartJc_F(StringPartJc_s* ythis, char cEndQuotion, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexEndOfQuotion_StringPartJc_F");
  
  { 
    int32 pos; 
    int32 max; 
    bool bNotFound = true; 
    
    
    pos = ythis->start + fromWhere + 1;
    max = (ythis->end - pos) < maxToTest ? ythis->end : pos + maxToTest;
    bNotFound = true;
    
    while(pos < max && bNotFound)
      { 
        char cc; 
        
        
        cc = charAt_StringJc(ythis->content, pos++);
        if(cc == '\\' && (pos + 1) < max) 
        { 
          
          pos += 1;//on \ overread the next char, test char after them!
          
        }
        else if(cc == cEndQuotion) 
        { 
          
          bNotFound = false;
        }
      }
    { STACKTRC_LEAVE;
      return (bNotFound ? -1 : (pos - ythis->start));
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 indexEndOfQuotion_StringPartJc(StringPartJc_s* ythis, char cEndQuotion, int32 fromWhere, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->indexEndOfQuotion(ythis, cEndQuotion, fromWhere, maxToTest, _thCxt);
}


/**Returns the position of one of the chars in sChars within the part,*/
int32 indexOfAnyChar_S_StringPartJc_F(StringPartJc_s* ythis, StringJc sChars, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("indexOfAnyChar_S_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return mtthis->indexOfAnyChar_Sii(ythis, sChars, 0, MAX_VALUE_IntegerJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 indexOfAnyChar_S_StringPartJc(StringPartJc_s* ythis, StringJc sChars, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->indexOfAnyChar_S(ythis, sChars, _thCxt);
}


/**Returns the position of the first char other than the chars in sChars within the part, started inside the part with fromIndex,*/
int32 indexOfNoChar_Si_StringPartJc_F(StringPartJc_s* ythis, StringJc sChars, int32 fromWhere, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOfNoChar_Si_StringPartJc_F");
  
  { 
    int32 pos; 
    
    
    pos = ythis->start + fromWhere;
    
    while(pos < ythis->end && indexOf_C_StringJc(sChars, charAt_StringJc(ythis->content, pos)) >= 0)pos += 1;
    { STACKTRC_LEAVE;
      return (pos >= ythis->end) ? -1 : (pos - ythis->start);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 indexOfNoChar_Si_StringPartJc(StringPartJc_s* ythis, StringJc sChars, int32 fromWhere, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->indexOfNoChar_Si(ythis, sChars, fromWhere, _thCxt);
}


/**Returns the position of the first char other than the chars in sChars within the part,*/
int32 indexOfNoChar_S_StringPartJc_F(StringPartJc_s* ythis, StringJc sChars, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("indexOfNoChar_S_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return mtthis->indexOfNoChar_Si(ythis, sChars, 0, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 indexOfNoChar_S_StringPartJc(StringPartJc_s* ythis, StringJc sChars, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->indexOfNoChar_S(ythis, sChars, _thCxt);
}


/**Sets the length of the current part to any char content in sChars (terminate chars).*/
struct StringPartJc_t* lentoAnyChar_Si_StringPartJc_F(StringPartJc_s* ythis, StringJc sChars, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("lentoAnyChar_Si_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return mtthis->lentoAnyChar_Sii(ythis, sChars, maxToTest, seekNormal_StringPartJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* lentoAnyChar_Si_StringPartJc(StringPartJc_s* ythis, StringJc sChars, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->lentoAnyChar_Si(ythis, sChars, maxToTest, _thCxt);
}


/**Sets the length of the current part to any char content in sChars (terminate chars).*/
struct StringPartJc_t* lentoAnyChar_Sii_StringPartJc_F(StringPartJc_s* ythis, StringJc sChars, int32 maxToTest, int32 mode, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("lentoAnyChar_Sii_StringPartJc_F");
  
  { 
    int32 pos = 0; 
    
    
    ythis->endLast = ythis->end;
    /*no initvalue*/
    if((mode & mSeekBackward__StringPartJc) != 0) 
    { 
      
      pos = mtthis->lastIndexOfAnyChar(ythis, sChars, 0, maxToTest, _thCxt);
    }
    else 
    { 
      
      pos = mtthis->indexOfAnyChar_Sii(ythis, sChars, 0, maxToTest, _thCxt);
    }
    if(pos < 0) 
    { 
      
      ythis->end = ythis->start;
      ythis->bFound = false;
    }
    else 
    { 
      
      ythis->end = ythis->start + pos;
      ythis->bFound = true;
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* lentoAnyChar_Sii_StringPartJc(StringPartJc_s* ythis, StringJc sChars, int32 maxToTest, int32 mode, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->lentoAnyChar_Sii(ythis, sChars, maxToTest, mode, _thCxt);
}


/**Sets the length of the current part to any terminate string given in sString.*/
struct StringPartJc_t* lentoAnyString_SYi_StringPartJc_F(StringPartJc_s* ythis, StringJc_Y* strings, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("lentoAnyString_SYi_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return mtthis->lentoAnyString_SYii(ythis, strings, maxToTest, seekNormal_StringPartJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* lentoAnyString_SYi_StringPartJc(StringPartJc_s* ythis, StringJc_Y* strings, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->lentoAnyString_SYi(ythis, strings, maxToTest, _thCxt);
}


/**Sets the length of the current part to any terminate string given in sString.*/
struct StringPartJc_t* lentoAnyString_SYii_StringPartJc_F(StringPartJc_s* ythis, StringJc_Y* strings, int32 maxToTest, int32 mode, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("lentoAnyString_SYii_StringPartJc_F");
  
  { 
    struct foundString_Y { ObjectArrayJc head; StringJc data[1]; }foundString = NULL_StringJc;   /**/
    int32 pos; 
    
    
    ythis->endLast = ythis->end;
    
    (StringJc_Y*)ctorO_ObjectArrayJc(&foundString.head.object, 1, sizeof(StringJc),&reflection_StringJc, 0);
    pos = mtthis->indexOfAnyString(ythis, strings, 0, maxToTest, null, (struct StringJc_Y_t*)(&( foundString)), _thCxt);
    if(pos < 0) 
    { 
      
      ythis->end = ythis->start;
      ythis->bFound = false;
    }
    else 
    { 
      
      if((mode & seekEnd_StringPartJc) != 0) 
      { 
        
        pos += length_StringJc(foundString.data[0]);
      }
      ythis->end = ythis->start + pos;
      ythis->bFound = true;
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* lentoAnyString_SYii_StringPartJc(StringPartJc_s* ythis, StringJc_Y* strings, int32 maxToTest, int32 mode, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->lentoAnyString_SYii(ythis, strings, maxToTest, mode, _thCxt);
}


/**Sets the length of the current part to any terminate string given in sString.*/
void lentoAnyStringWithIndent_StringPartJc_F(StringPartJc_s* ythis, StringJc_Y* strings, StringJc sIndentChars, int32 maxToTest, struct StringBuilderJc_t* buffer, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("lentoAnyStringWithIndent_StringPartJc_F");
  
  { 
    int32 indentColumn; 
    int32 startLine; 
    bool bAlsoWhiteSpaces; 
    int32 pos; 
    
    
    ythis->endLast = ythis->end;//String sRet; sRet = "";
    
    setLength_StringBuilderJc(buffer, 0, _thCxt);
    indentColumn = mtthis->getCurrentColumn(ythis, _thCxt);
    startLine = ythis->start;
    bAlsoWhiteSpaces = (charAt_StringJc(sIndentChars, length_StringJc(sIndentChars) - 1) == ' ');
    pos = mtthis->indexOfAnyString(ythis, strings, 0, maxToTest, null, null, _thCxt);
    if(pos < 0) 
    { 
      
      ythis->end = ythis->start;
      ythis->bFound = false;
    }
    else 
    { 
      bool bFinish = false; 
      
      
      ythis->bFound = true;
      ythis->end = ythis->start + pos;
      bFinish = false;
      
      while(!bFinish)
        { 
          
          pos = indexOf_CI_StringJc(ythis->content, '\n', startLine);
          if(pos < 0) pos = ythis->end;
          if(pos > ythis->end) 
          { //:next newline after terminated string, that is the last line.
            
            
            pos = ythis->end;
            bFinish = true;
          }
          else 
          { 
            
            pos += 1;
          }// '\n' including
          //append the line to output string:
          
          append_s_StringBuilderJc(buffer, substring_StringJc(ythis->content, startLine, pos, _thCxt), _thCxt);
          if(!bFinish) 
          { //:skip over indent.
            
            int32 posIndent; 
            
            
            startLine = pos;
            posIndent = startLine + indentColumn;
            if(posIndent > ythis->end) posIndent = ythis->end;
            
            while(startLine < posIndent && indexOf_C_StringJc(sIndentChars, charAt_StringJc(ythis->content, startLine)) >= 0)
              { 
                
                startLine += 1;
              }
            if(bAlsoWhiteSpaces) 
            { 
              
              
              while(indexOf_C_StringJc(zI_StringJc(" \t",2), charAt_StringJc(ythis->content, startLine)) >= 0)
                { 
                  
                  startLine += 1;
                }
            }
          }
        }
    }
    { STACKTRC_LEAVE;
      return;
    }//buffer.toString();
    
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void lentoAnyStringWithIndent_StringPartJc(StringPartJc_s* ythis, StringJc_Y* strings, StringJc sIndentChars, int32 maxToTest, struct StringBuilderJc_t* buffer, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  mtbl->lentoAnyStringWithIndent(ythis, strings, sIndentChars, maxToTest, buffer, _thCxt);
}


/**Sets the length of the current part to any char content in sChars (terminate chars),*/
struct StringPartJc_t* lentoAnyCharOutsideQuotion_StringPartJc_F(StringPartJc_s* ythis, StringJc sChars, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("lentoAnyCharOutsideQuotion_StringPartJc_F");
  
  { 
    int32 pos; 
    
    
    ythis->endLast = ythis->end;
    pos = mtthis->indexOfAnyCharOutsideQuotion(ythis, sChars, 0, maxToTest, _thCxt);
    if(pos < 0) 
    { 
      
      ythis->end = ythis->start;
      ythis->bFound = false;
    }
    else 
    { 
      
      ythis->end = ythis->start + pos;
      ythis->bFound = true;
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* lentoAnyCharOutsideQuotion_StringPartJc(StringPartJc_s* ythis, StringJc sChars, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->lentoAnyCharOutsideQuotion(ythis, sChars, maxToTest, _thCxt);
}


/**Sets the length of the current part to the end of the quotion*/
struct StringPartJc_t* lentoQuotionEnd_StringPartJc_F(StringPartJc_s* ythis, char sEndQuotion, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("lentoQuotionEnd_StringPartJc_F");
  
  { 
    int32 pos; 
    
    
    ythis->endLast = ythis->end;
    pos = mtthis->indexEndOfQuotion(ythis, sEndQuotion, 0, maxToTest, _thCxt);
    if(pos < 0) 
    { 
      
      ythis->end = ythis->start;
      ythis->bFound = false;
    }
    else 
    { 
      
      ythis->end = ythis->start + pos;
      ythis->bFound = true;
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* lentoQuotionEnd_StringPartJc(StringPartJc_s* ythis, char sEndQuotion, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->lentoQuotionEnd(ythis, sEndQuotion, maxToTest, _thCxt);
}


/**Sets the length of the current part to any char content in sChars (terminate chars).*/
struct StringPartJc_t* lentoAnyChar_S_StringPartJc_F(StringPartJc_s* ythis, StringJc sChars, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("lentoAnyChar_S_StringPartJc_F");
  
  { 
    
    mtthis->lentoAnyChar_Si(ythis, sChars, MAX_VALUE_IntegerJc, _thCxt);
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* lentoAnyChar_S_StringPartJc(StringPartJc_s* ythis, StringJc sChars, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->lentoAnyChar_S(ythis, sChars, _thCxt);
}


/**Sets the length to the end of the maximal part if the length is 0*/
struct StringPartJc_t* len0end_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("len0end_StringPartJc_F");
  
  { 
    
    if(ythis->end <= ythis->start) ythis->end = ythis->endMax;
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* len0end_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->len0end(ythis, _thCxt);
}


/**Sets the length to the end of the maximal part.*/
struct StringPartJc_t* setLengthMax_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setLengthMax_StringPartJc_F");
  
  { 
    
    ythis->end = ythis->endMax;
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* setLengthMax_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->setLengthMax(ythis, _thCxt);
}


/**Posits the end of the part before all of the chars given in the parameter string.*/
struct StringPartJc_t* lenBacktoNoChar_StringPartJc_F(StringPartJc_s* ythis, StringJc sChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("lenBacktoNoChar_StringPartJc_F");
  
  { 
    
    ythis->endLast = ythis->end;
    
    while((--ythis->end) >= ythis->start && indexOf_C_StringJc(sChars, charAt_StringJc(ythis->content, ythis->end)) >= 0)
      ;
    if(ythis->end < ythis->start) 
    { 
      
      ythis->end = ythis->start;
      ythis->bFound = false;
    }
    else ythis->bFound = true;
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* lenBacktoNoChar_StringPartJc(StringPartJc_s* ythis, StringJc sChars, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->lenBacktoNoChar(ythis, sChars, _thCxt);
}


/**Trims all leading and trailing whitespaces within the part.*/
struct StringPartJc_t* trim_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("trim_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return 
      ( mtthis->seekNoChar(ythis, s0_StringJc(" \t\n\r"), _thCxt)
      , mtthis->lenBacktoNoChar(ythis, s0_StringJc(" \t\n\r"), _thCxt)
      );
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* trim_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->trim(ythis, _thCxt);
}


/**Trims a java- or C-style line-comment from end of part and all leading and trailing whitespaces.*/
struct StringPartJc_t* trimComment_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("trimComment_StringPartJc_F");
  
  { 
    int32 posComment; 
    
    
    ythis->startLast = ythis->start;
    ythis->endLast = ythis->end;
    posComment = mtthis->indexOf_S(ythis, s0_StringJc("//"), _thCxt);
    if(posComment >= 0) ythis->end = ythis->start + posComment;
    ythis->bFound = (ythis->start > ythis->startLast);
    { STACKTRC_LEAVE;
      return mtthis->trim(ythis, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* trimComment_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->trimComment(ythis, _thCxt);
}


/**Returns the position of the char within the part,*/
int32 indexOf_c_StringPartJc_F(StringPartJc_s* ythis, char ch, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_c_StringPartJc_F");
  
  { 
    StringJc _temp1_1; //J2C: temporary references for concatenation
    
    { STACKTRC_LEAVE;
      return 
      ( _temp1_1= substring_StringJc(ythis->content, ythis->start, ythis->end, _thCxt)
      , indexOf_C_StringJc(_temp1_1, ch)
      );
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 indexOf_c_StringPartJc(StringPartJc_s* ythis, char ch, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->indexOf_c(ythis, ch, _thCxt);
}


/**Returns the position of the char within the part, started inside the part with fromIndex,*/
int32 indexOf_ci_StringPartJc_F(StringPartJc_s* ythis, char ch, int32 fromIndex, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_ci_StringPartJc_F");
  
  { 
    
    if(fromIndex >= (ythis->end - ythis->start) || fromIndex < 0) { STACKTRC_LEAVE;
      return -1;
    }
    else 
    { 
      int32 pos; 
      
      StringJc _temp2_1; //J2C: temporary references for concatenation
      
      pos = 
        ( _temp2_1= substring_StringJc(ythis->content, ythis->start + fromIndex, ythis->end, _thCxt)
        , indexOf_C_StringJc(_temp2_1, ch)
        );
      if(pos < 0) { STACKTRC_LEAVE;
        return -1;
      }
      else { STACKTRC_LEAVE;
        return pos + fromIndex;
      }
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 indexOf_ci_StringPartJc(StringPartJc_s* ythis, char ch, int32 fromIndex, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->indexOf_ci(ythis, ch, fromIndex, _thCxt);
}


/**Returns the position of the string within the part*/
int32 indexOf_S_StringPartJc_F(StringPartJc_s* ythis, StringJc sCmp, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_S_StringPartJc_F");
  
  { 
    StringJc _temp1_1; //J2C: temporary references for concatenation
    
    { STACKTRC_LEAVE;
      return 
      ( _temp1_1= substring_StringJc(ythis->content, ythis->start, ythis->end, _thCxt)
      , indexOf_s_StringJc(_temp1_1, sCmp)
      );
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 indexOf_S_StringPartJc(StringPartJc_s* ythis, StringJc sCmp, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->indexOf_S(ythis, sCmp, _thCxt);
}


/**Returns the position of the string within the part*/
int32 indexOf_Sii_StringPartJc_F(StringPartJc_s* ythis, StringJc sCmp, int32 fromIndex, int32 maxToTest, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("indexOf_Sii_StringPartJc_F");
  
  { 
    int32 max; 
    
    
    max = (ythis->end - ythis->start) < maxToTest ? ythis->end : ythis->start + maxToTest;
    if(fromIndex >= (max - ythis->start) || fromIndex < 0) { STACKTRC_LEAVE;
      return -1;
    }
    else 
    { 
      int32 pos; 
      
      StringJc _temp2_1; //J2C: temporary references for concatenation
      
      pos = 
        ( _temp2_1= substring_StringJc(ythis->content, ythis->start + fromIndex, max, _thCxt)
        , indexOf_s_StringJc(_temp2_1, sCmp)
        );
      if(pos < 0) { STACKTRC_LEAVE;
        return -1;
      }
      else { STACKTRC_LEAVE;
        return pos + fromIndex;
      }
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 indexOf_Sii_StringPartJc(StringPartJc_s* ythis, StringJc sCmp, int32 fromIndex, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->indexOf_Sii(ythis, sCmp, fromIndex, maxToTest, _thCxt);
}


/**Compares the Part of string with the given string*/
bool equals_S_StringPartJc_F(StringPartJc_s* ythis, StringJc sCmp, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("equals_S_StringPartJc_F");
  
  { 
    StringJc _temp1_1; //J2C: temporary references for concatenation
    
    { STACKTRC_LEAVE;
      return ((/*J2C:cast% from int32*/bool)(
      ( _temp1_1= substring_StringJc(ythis->content, ythis->start, ythis->end, _thCxt)
      , equals_StringJc(_temp1_1, sCmp)
      )));
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool equals_S_StringPartJc(StringPartJc_s* ythis, StringJc sCmp, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->equals_S(ythis, sCmp, _thCxt);
}


/**compares the Part of string with the given string.*/
bool startsWith_StringPartJc_F(StringPartJc_s* ythis, StringJc sCmp, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("startsWith_StringPartJc_F");
  
  { 
    int32 pos_cEndOfText; 
    
    
    pos_cEndOfText = indexOf_C_StringJc(sCmp, cEndOfText_StringPartJc);
    if(pos_cEndOfText >= 0) 
    { 
      
      if(pos_cEndOfText == 0) 
      { 
        
        { STACKTRC_LEAVE;
          return ythis->start == ythis->end;
        }
      }
      else 
      { 
        StringJc _temp3_1; //J2C: temporary references for concatenation
        
        { STACKTRC_LEAVE;
          return ((/*J2C:cast% from int32*/bool)(
          ( _temp3_1= substring_StringJc(ythis->content, ythis->start, ythis->end, _thCxt)
          , equals_StringJc(_temp3_1, sCmp)
          )));
        }
      }
    }
    else 
    { 
      StringJc _temp2_1; //J2C: temporary references for concatenation
      
      { STACKTRC_LEAVE;
        return 
        ( _temp2_1= substring_StringJc(ythis->content, ythis->start, ythis->end, _thCxt)
        , startsWith_StringJc(_temp2_1, sCmp)
        );
      }
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool startsWith_StringPartJc(StringPartJc_s* ythis, StringJc sCmp, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->startsWith(ythis, sCmp, _thCxt);
}


/**scan next content, test the requested String.*/
struct StringPartJc_t* scan_StringPartJc_F(StringPartJc_s* ythis, StringJc sTestP, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("scan_StringPartJc_F");
  
  { 
    
    if(ythis->bCurrentOk) 
    { //:      but the sTestP may contain only cEndOfText. end of text will be okay than.
      
      StringJc sTest = NULL_StringJc; 
      int32 len; 
      bool bTestToEndOfText; 
      
      
      mtthis->seekNoWhitespaceOrComments(ythis, _thCxt);
      /*no initvalue*/
      len = indexOf_C_StringJc(sTestP, cEndOfText_StringPartJc);
      bTestToEndOfText = (len >= 0);
      if(bTestToEndOfText) 
      { 
        
        sTest = substring_StringJc(sTestP, 0, len, _thCxt)/*J2C:non-persistent*/;
      }
      else 
      { 
        
        len = length_StringJc(sTestP);
        sTest = sTestP/*J2C:non-persistent*/;
      }//int len = sTest.length();
      
      if((ythis->start + len) <= ythis->endMax && equals_StringJc(sTest, substring_StringJc(ythis->content, ythis->start, ythis->start + len, _thCxt)) && (!bTestToEndOfText || ythis->start + len == ythis->end)) 
      { 
        
        ythis->start += len;
      }
      else 
      { 
        
        ythis->bCurrentOk = false;//if(report != null){ report.report(6,"ErrorScan scan(" + sTest + ")");}      //error in current scanning
        
      }
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* scan_StringPartJc(StringPartJc_s* ythis, StringJc sTestP, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->scan(ythis, sTestP, _thCxt);
}


/**Test the result of scanning and set the scan Pos Ok, if current scanning was ok*/
bool scanOk_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("scanOk_StringPartJc_F");
  
  { 
    bool bOk; 
    
    
    if(ythis->bCurrentOk) 
    { 
      
      ythis->startScan = ythis->startLast = /*? assignment*/ythis->start;//the scanOk-position is the start of maximal part.
      
      ythis->bStartScan = true;//set all idxLast... to 0
      
    }
    else 
    { 
      
      ythis->start = ythis->startLast = /*? assignment*/ythis->startScan;//return to the start
      
    }//if(report != null){ report.report(6," scanOk:" + startMin + ".." + start + ":" + (bCurrentOk ? "ok" : "error")); }
    
    bOk = ythis->bCurrentOk;
    ythis->bCurrentOk = true;//prepare to next try scanning
    
    { STACKTRC_LEAVE;
      return (bOk);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool scanOk_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->scanOk(ythis, _thCxt);
}


/*** */
struct StringPartJc_t* scanQuotion_SSSY_StringPartJc_F(StringPartJc_s* ythis, StringJc sQuotionmarkStart, StringJc sQuotionMarkEnd, StringJc_Y* sResult, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("scanQuotion_SSSY_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return mtthis->scanQuotion_SSSYi(ythis, sQuotionmarkStart, sQuotionMarkEnd, sResult, MAX_VALUE_IntegerJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* scanQuotion_SSSY_StringPartJc(StringPartJc_s* ythis, StringJc sQuotionmarkStart, StringJc sQuotionMarkEnd, StringJc_Y* sResult, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->scanQuotion_SSSY(ythis, sQuotionmarkStart, sQuotionMarkEnd, sResult, _thCxt);
}


/*** */
struct StringPartJc_t* scanQuotion_SSSYi_StringPartJc_F(StringPartJc_s* ythis, StringJc sQuotionmarkStart, StringJc sQuotionMarkEnd, StringJc_Y* sResult, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("scanQuotion_SSSYi_StringPartJc_F");
  
  { 
    
    if(mtthis->scanEntry(ythis, _thCxt)) 
    { 
      
      
        ( mtthis->scan(ythis, sQuotionmarkStart, _thCxt)
        , mtthis->lentoNonEscapedString(ythis, sQuotionMarkEnd, maxToTest, _thCxt)
        );
      if(ythis->bCurrentOk) 
      { //:TODO ...ToEndString, now use only 1 char in sQuotionMarkEnd
        
        StringJc _persistring3_1=NULL_StringJc; //J2C: temporary persistent Strings
        
        if(sResult != null) sResult->data[0] = _persistring3_1 = persist_StringJc(mtthis->getCurrentPart(ythis, _thCxt))/*J2C:non-persistent*/;
        
          ( mtthis->fromEnd(ythis, _thCxt)
          , mtthis->seek_i(ythis, length_StringJc(sQuotionMarkEnd), _thCxt)
          );
        activateGarbageCollectorAccess_BlockHeapJc(PTR_StringJc(_persistring3_1), null);
      }
      else ythis->bCurrentOk = false;
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* scanQuotion_SSSYi_StringPartJc(StringPartJc_s* ythis, StringJc sQuotionmarkStart, StringJc sQuotionMarkEnd, StringJc_Y* sResult, int32 maxToTest, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->scanQuotion_SSSYi(ythis, sQuotionmarkStart, sQuotionMarkEnd, sResult, maxToTest, _thCxt);
}


/**Scans if it is a integer number, contains exclusively of digits 0..9*/
int64 scanDigits_StringPartJc_F(StringPartJc_s* ythis, bool bHex, int32 maxNrofChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("scanDigits_StringPartJc_F");
  
  { 
    
    if(ythis->bCurrentOk) 
    { 
      int64 nn = 0; 
      bool bCont = true; 
      int32 pos; 
      int32 max; 
      
      
      nn = 0;
      bCont = true;
      pos = ythis->start;
      max = (ythis->end - pos) < maxNrofChars ? ythis->end : pos + maxNrofChars;
      do 
        { 
          
          if(pos < max) 
          { 
            char cc; 
            
            
            cc = charAt_StringJc(ythis->content, pos);
            if(cc >= '0' && cc <= '9') nn = nn * (bHex ? 16 : 10) + (cc - '0');
            else if(bHex && cc >= 'a' && cc <= 'f') nn = nn * 16 + (cc - 'a' + 10);
            else if(bHex && cc >= 'A' && cc <= 'F') nn = nn * 16 + (cc - 'A' + 10);
            else bCont = false;
            if(bCont) 
            { 
              
              pos += 1;
            }
          }
          else bCont = false;
        }while(bCont);
      if(pos > ythis->start) 
      { 
        
        ythis->start = pos;
        { STACKTRC_LEAVE;
          return nn;
        }//nLastIntegerNumber = nn;
        
      }
      else ythis->bCurrentOk = false;//scanning failed.
      
    }
    { STACKTRC_LEAVE;
      return -1;
    }//on error
    
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int64 scanDigits_StringPartJc(StringPartJc_s* ythis, bool bHex, int32 maxNrofChars, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->scanDigits(ythis, bHex, maxNrofChars, _thCxt);
}


/*** */
struct StringPartJc_t* scanStart_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("scanStart_StringPartJc_F");
  
  { 
    
    ythis->bCurrentOk = true;
    mtthis->scanOk(ythis, _thCxt);//turn all indicees to ok
    
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* scanStart_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->scanStart(ythis, _thCxt);
}

bool scanEntry_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("scanEntry_StringPartJc_F");
  
  { 
    
    if(ythis->bCurrentOk) 
    { 
      
      mtthis->seekNoWhitespaceOrComments(ythis, _thCxt);
      if(ythis->bStartScan) 
      { 
        
        ythis->idxLastIntegerNumber = -1;//idxLastFloatNumber = 0;
        
        ythis->bStartScan = false;
      }
      if(ythis->start == ythis->end) 
      { 
        
        ythis->bCurrentOk = false;//error, because nothing to scan.
        
      }
    }
    { STACKTRC_LEAVE;
      return ythis->bCurrentOk;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool scanEntry_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->scanEntry(ythis, _thCxt);
}


/**Scanns a integer number as positiv value without sign.*/
struct StringPartJc_t* scanPositivInteger_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("scanPositivInteger_StringPartJc_F");
  
  { 
    
    if(mtthis->scanEntry(ythis, _thCxt)) 
    { 
      int64 value; 
      
      
      value = mtthis->scanDigits(ythis, false, MAX_VALUE_IntegerJc, _thCxt);
      if(ythis->bCurrentOk) 
      { 
        
        if(ythis->idxLastIntegerNumber < ythis->nLastIntegerNumber.head.length - 2) 
        { 
          
          ythis->nLastIntegerNumber.data[++ythis->idxLastIntegerNumber] = value;
        }
        else { throw_s0Jc(ident_ParseExceptionJc, "to much scanned integers", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
      }
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* scanPositivInteger_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->scanPositivInteger(ythis, _thCxt);
}


/**Scans an integer expression with possible sign char '-' at first.*/
struct StringPartJc_t* scanInteger_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("scanInteger_StringPartJc_F");
  
  { 
    
    if(mtthis->scanEntry(ythis, _thCxt)) 
    { 
      bool bNegativValue = false; 
      int64 value; 
      
      
      bNegativValue = false;
      if(charAt_StringJc(ythis->content, ythis->start) == '-') 
      { 
        
        bNegativValue = true;
        mtthis->seek_i(ythis, 1, _thCxt);
      }
      value = mtthis->scanDigits(ythis, false, MAX_VALUE_IntegerJc, _thCxt);
      if(bNegativValue) 
      { 
        
        value = -value;
      }
      if(ythis->bCurrentOk) 
      { 
        
        if(ythis->idxLastIntegerNumber < ythis->nLastIntegerNumber.head.length - 2) 
        { 
          
          ythis->nLastIntegerNumber.data[++ythis->idxLastIntegerNumber] = value;
        }
        else { throw_s0Jc(ident_ParseExceptionJc, "to much scanned integers", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
      }
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* scanInteger_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->scanInteger(ythis, _thCxt);
}


/**Scans an float expression*/
struct StringPartJc_t* scanFloatNumber_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("scanFloatNumber_StringPartJc_F");
  
  { 
    
    if(mtthis->scanEntry(ythis, _thCxt)) 
    { 
      int64 nInteger = 0; 
      int64 nFractional = 0; 
      int32 nDivisorFract = 1; 
      int32 nExponent = 0; 
      char cc = 0; 
      bool bNegativValue = false; 
      bool bNegativExponent = false; 
      bool bFractionalFollowed = false; 
      
      
      nInteger = 0;
      nFractional = 0;
      nDivisorFract = 1;
      /*no initvalue*/
      /*no initvalue*/
      bNegativValue = false;
      bNegativExponent = false;
      bFractionalFollowed = false;
      if((cc = /*? assignment*/charAt_StringJc(ythis->content, ythis->start)) == '-') 
      { 
        
        bNegativValue = true;
        mtthis->seek_i(ythis, 1, _thCxt);
        cc = charAt_StringJc(ythis->content, ythis->start);
      }
      if(cc == '.') 
      { 
        
        nInteger = 0;
        bFractionalFollowed = true;
      }
      else 
      { 
        
        nInteger = mtthis->scanDigits(ythis, false, MAX_VALUE_IntegerJc, _thCxt);
        if(ythis->bCurrentOk) 
        { 
          
          if(charAt_StringJc(ythis->content, ythis->start) == '.') 
          { 
            
            bFractionalFollowed = true;
          }
        }
      }
      if(ythis->bCurrentOk && bFractionalFollowed) 
      { 
        
        mtthis->seek_i(ythis, 1, _thCxt);//over .
        
        
        while(mtthis->getCurrentChar(ythis, _thCxt) == '0')
          { 
            
            mtthis->seek_i(ythis, 1, _thCxt);
            nDivisorFract *= 10;
          }//int posFrac = start;
          
        nFractional = mtthis->scanDigits(ythis, false, MAX_VALUE_IntegerJc, _thCxt);
        if(ythis->bCurrentOk) 
        { }
        else if(nDivisorFract >= 10) 
        { 
          
          ythis->bCurrentOk = true;//it is okay, at ex."9.0" is found. There are no more digits after "0".
          
          nFractional = 0;
        }
      }
      else 
      { 
        
        nFractional = 0;
      }//nDigitsFrac = 0;}
      
      if(ythis->bCurrentOk) 
      { 
        int32 nPosExponent; 
        
        
        nPosExponent = ythis->start;
        if((cc = /*? assignment*/charAt_StringJc(ythis->content, ythis->start)) == 'e' || cc == 'E') 
        { 
          
          mtthis->seek_i(ythis, 1, _thCxt);
          if((cc = /*? assignment*/charAt_StringJc(ythis->content, ythis->start)) == '-') 
          { 
            
            bNegativExponent = true;
            mtthis->seek_i(ythis, 1, _thCxt);
            cc = charAt_StringJc(ythis->content, ythis->start);
          }
          if(cc >= '0' && cc <= '9') 
          { 
            
            nExponent = (int32)mtthis->scanDigits(ythis, false, MAX_VALUE_IntegerJc, _thCxt);
            if(!ythis->bCurrentOk) 
            { 
              
              nExponent = 0;
            }
          }
          else 
          { //: it isn't an exponent, but a String beginning with 'E' or 'e'.
            //:This string is not a part of the float number.
            
            
            ythis->start = nPosExponent;
            nExponent = 0;
          }
        }
        else 
        { 
          
          nExponent = 0;
        }
      }
      else 
      { 
        
        nExponent = 0;
      }
      if(ythis->bCurrentOk) 
      { 
        double result; 
        
        
        result = (double)nInteger;
        if(nFractional > 0) 
        { 
          double fFrac; 
          
          
          fFrac = (double)nFractional;
          
          while(fFrac >= 1.0)
            { 
              
              fFrac /= 10.0;
            }
          fFrac /= nDivisorFract;//number of 0 after . until first digit.
          
          result += fFrac;
        }
        if(bNegativValue) 
        { 
          
          result = -result;
        }
        if(nExponent != 0) 
        { 
          
          if(bNegativExponent) 
          { 
            
            nExponent = -nExponent;
          }
          result *= pow_MathJc(/*static*/10, nExponent);
        }
        if(ythis->idxLastFloatNumber < ythis->nLastFloatNumber.head.length - 2) 
        { 
          
          ythis->nLastFloatNumber.data[++ythis->idxLastFloatNumber] = result;
        }
        else { throw_s0Jc(ident_ParseExceptionJc, "to much scanned floats", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
      }
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* scanFloatNumber_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->scanFloatNumber(ythis, _thCxt);
}


/**Scans a sequence of hex chars a hex number*/
struct StringPartJc_t* scanHex_StringPartJc_F(StringPartJc_s* ythis, int32 maxNrofChars, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("scanHex_StringPartJc_F");
  
  { 
    
    if(mtthis->scanEntry(ythis, _thCxt)) 
    { 
      int64 value; 
      
      
      value = mtthis->scanDigits(ythis, true, maxNrofChars, _thCxt);
      if(ythis->bCurrentOk) 
      { 
        
        if(ythis->idxLastIntegerNumber < ythis->nLastIntegerNumber.head.length - 2) 
        { 
          
          ythis->nLastIntegerNumber.data[++ythis->idxLastIntegerNumber] = value;
        }
        else { throw_s0Jc(ident_ParseExceptionJc, "to much scanned integers", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
      }
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* scanHex_StringPartJc(StringPartJc_s* ythis, int32 maxNrofChars, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->scanHex(ythis, maxNrofChars, _thCxt);
}


/**Scans a integer number possible as hex, or decimal number.*/
struct StringPartJc_t* scanHexOrDecimal_StringPartJc_F(StringPartJc_s* ythis, int32 maxNrofChars, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("scanHexOrDecimal_StringPartJc_F");
  
  { 
    
    if(mtthis->scanEntry(ythis, _thCxt)) 
    { 
      int64 value = 0; 
      
      StringJc _temp2_1; //J2C: temporary references for concatenation
      
      /*no initvalue*/
      if(
        ( _temp2_1= substring_I_StringJc(ythis->content, ythis->start, _thCxt)
        , startsWith_StringJc(_temp2_1, s0_StringJc("0x"))
        )) 
      { 
        
        mtthis->seek_i(ythis, 2, _thCxt);
        value = mtthis->scanDigits(ythis, true, maxNrofChars, _thCxt);
      }
      else 
      { 
        
        value = mtthis->scanDigits(ythis, false, maxNrofChars, _thCxt);
      }
      if(ythis->bCurrentOk) 
      { 
        
        if(ythis->idxLastIntegerNumber < ythis->nLastIntegerNumber.head.length - 2) 
        { 
          
          ythis->nLastIntegerNumber.data[++ythis->idxLastIntegerNumber] = value;
        }
        else { throw_s0Jc(ident_ParseExceptionJc, "to much scanned integers", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
      }
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* scanHexOrDecimal_StringPartJc(StringPartJc_s* ythis, int32 maxNrofChars, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->scanHexOrDecimal(ythis, maxNrofChars, _thCxt);
}


/*** */
struct StringPartJc_t* scanIdentifier_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("scanIdentifier_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return mtthis->scanIdentifier_SS(ythis, null_StringJc, null_StringJc, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* scanIdentifier_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->scanIdentifier(ythis, _thCxt);
}


/*** */
struct StringPartJc_t* scanIdentifier_SS_StringPartJc_F(StringPartJc_s* ythis, StringJc additionalStartChars, StringJc additionalChars, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("scanIdentifier_SS_StringPartJc_F");
  
  { 
    
    if(mtthis->scanEntry(ythis, _thCxt)) 
    { 
      
      mtthis->lentoIdentifier_SS(ythis, additionalStartChars, additionalChars, _thCxt);
      if(ythis->bFound) 
      { 
        StringJc _persistring3_1=NULL_StringJc; //J2C: temporary persistent Strings
        
        set_StringJc(&(ythis->sLastString), _persistring3_1 = persist_StringJc(mtthis->getCurrentPart(ythis, _thCxt)));
        ythis->start = ythis->end;//after identifier.
        
        activateGarbageCollectorAccess_BlockHeapJc(PTR_StringJc(_persistring3_1), null);
      }
      else 
      { 
        
        ythis->bCurrentOk = false;
      }
      ythis->end = ythis->endLast;//revert the change of length, otherwise end = end of identifier.
      
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringPartJc_t* scanIdentifier_SS_StringPartJc(StringPartJc_s* ythis, StringJc additionalStartChars, StringJc additionalChars, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->scanIdentifier_SS(ythis, additionalStartChars, additionalChars, _thCxt);
}


/**Returns the last scanned integer number*/
int64 getLastScannedIntegerNumber_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLastScannedIntegerNumber_StringPartJc_F");
  
  { 
    
    if(ythis->idxLastIntegerNumber >= 0) 
    { 
      
      { STACKTRC_LEAVE;
        return ythis->nLastIntegerNumber.data[ythis->idxLastIntegerNumber--];
      }
    }
    else { throw_s0Jc(ident_ParseExceptionJc, "no integer number scanned.", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int64 getLastScannedIntegerNumber_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->getLastScannedIntegerNumber(ythis, _thCxt);
}


/**Returns the last scanned float number.*/
double getLastScannedFloatNumber_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLastScannedFloatNumber_StringPartJc_F");
  
  { 
    
    if(ythis->idxLastFloatNumber >= 0) 
    { 
      
      { STACKTRC_LEAVE;
        return ythis->nLastFloatNumber.data[ythis->idxLastFloatNumber--];
      }
    }
    else { throw_s0Jc(ident_ParseExceptionJc, "no integer number scanned.", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
double getLastScannedFloatNumber_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->getLastScannedFloatNumber(ythis, _thCxt);
}

StringJc getLastScannedString_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLastScannedString_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return ythis->sLastString;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc getLastScannedString_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->getLastScannedString(ythis, _thCxt);
}


/**Gets a String with translitaration.*/
StringJc getCircumScriptionToAnyChar_StringPartJc_F(StringPartJc_s* ythis, StringJc sCharsEnd, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("getCircumScriptionToAnyChar_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return mtthis->getCircumScriptionToAnyChar_p(ythis, sCharsEnd, false, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc getCircumScriptionToAnyChar_StringPartJc(StringPartJc_s* ythis, StringJc sCharsEnd, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->getCircumScriptionToAnyChar(ythis, sCharsEnd, _thCxt);
}

StringJc getCircumScriptionToAnyCharOutsideQuotion_StringPartJc_F(StringPartJc_s* ythis, StringJc sCharsEnd, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("getCircumScriptionToAnyCharOutsideQuotion_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return mtthis->getCircumScriptionToAnyChar_p(ythis, sCharsEnd, true, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc getCircumScriptionToAnyCharOutsideQuotion_StringPartJc(StringPartJc_s* ythis, StringJc sCharsEnd, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->getCircumScriptionToAnyCharOutsideQuotion(ythis, sCharsEnd, _thCxt);
}

StringJc getCircumScriptionToAnyChar_p_StringPartJc_F(StringPartJc_s* ythis, StringJc sCharsEnd, bool bOutsideQuotion, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("getCircumScriptionToAnyChar_p_StringPartJc_F");
  
  { 
    StringJc sResult = NULL_StringJc; 
    char cEscape = '\\'; 
    int32 posEnd; 
    int32 posEscape; 
    
    StringJc _temp1_1; //J2C: temporary references for concatenation
    
    /*no initvalue*/
    cEscape = '\\';
    posEnd = (sCharsEnd.ptr__== null) ? ythis->end : bOutsideQuotion ? mtthis->indexOfAnyCharOutsideQuotion(ythis, sCharsEnd, 0, ythis->end - ythis->start, _thCxt) : mtthis->indexOfAnyChar_S(ythis, sCharsEnd, _thCxt);
    if(posEnd < 0) posEnd = ythis->end - ythis->start;//int posEscape = indexOf(cEscape);
    //search the first escape char inside the string.
    
    posEscape = 
      ( _temp1_1= substring_StringJc(ythis->content, ythis->start, ythis->start + posEnd, _thCxt)
      , indexOf_C_StringJc(_temp1_1, cEscape)
      );
    if(posEscape < 0) 
    { //:there is no escape char in the current part to sCharsEnd,
      //:no extra conversion is necessary.
      
      StringJc _persistring2_1=NULL_StringJc; //J2C: temporary persistent Strings
      
      sResult = 
        ( mtthis->lento_i(ythis, posEnd, _thCxt)
        , _persistring2_1 = persist_StringJc(mtthis->getCurrentPart(ythis, _thCxt))
        )/*J2C:non-persistent*/;
      activateGarbageCollectorAccess_BlockHeapJc(PTR_StringJc(_persistring2_1), null);
    }
    else 
    { //:escape character is found before end
      
      StringJc _persistring2_1=NULL_StringJc; //J2C: temporary persistent Strings
      
      if(charAt_StringJc(ythis->content, ythis->start + posEnd - 1) == cEscape) 
      { //:the escape char is the char immediately before the end char.
        //:It means, the end char isn't such one and posEnd is faulty.
        //:Search the really end char:
        
        
        do 
          { //:search the end char after part of string without escape char
            
            
            posEnd = (sCharsEnd.ptr__== null) ? ythis->end : mtthis->indexOfAnyChar_Sii(ythis, sCharsEnd, posEscape + 2, MAX_VALUE_IntegerJc, _thCxt);
            if(posEnd < 0) posEnd = ythis->end;
            posEscape = mtthis->indexOf_ci(ythis, cEscape, posEscape + 2, _thCxt);
          }while((posEscape + 1) == posEnd);
      }
      mtthis->lento_i(ythis, posEnd, _thCxt);
      sResult = _persistring2_1 = persist_StringJc(resolveCircumScription_SpecialCharStringsJc(/*static*/mtthis->getCurrentPart(ythis, _thCxt), _thCxt))/*J2C:non-persistent*/;
      activateGarbageCollectorAccess_BlockHeapJc(PTR_StringJc(_persistring2_1), null);
    }
    mtthis->fromEnd(ythis, _thCxt);
    { STACKTRC_LEAVE;
      return sResult;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc getCircumScriptionToAnyChar_p_StringPartJc(StringPartJc_s* ythis, StringJc sCharsEnd, bool bOutsideQuotion, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->getCircumScriptionToAnyChar_p(ythis, sCharsEnd, bOutsideQuotion, _thCxt);
}


/**Gets the current position, useable for rewind*/
int64 getCurrentPosition_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentPosition_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return ythis->start;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int64 getCurrentPosition_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->getCurrentPosition(ythis, _thCxt);
}


/**Sets the current position at a fix position inside the maxPart.*/
void setCurrentPosition_StringPartJc_F(StringPartJc_s* ythis, int64 pos, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setCurrentPosition_StringPartJc_F");
  
  { 
    
    ythis->start = (int32)pos;
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void setCurrentPosition_StringPartJc(StringPartJc_s* ythis, int64 pos, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  mtbl->setCurrentPosition(ythis, pos, _thCxt);
}


/**Gets a substring inside the maximal part*/
StringJc substring_StringPartJc_F(StringPartJc_s* ythis, int32 pos, int32 posendP, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("substring_StringPartJc_F");
  
  { 
    int32 posend = 0; 
    
    
    /*no initvalue*/
    if(posendP <= 0) 
    { 
      
      posend = ythis->endMax - posendP;//if posendP is fault, an exception is thrown.
      
    }
    else 
    { 
      
      posend = posendP;
    }
    { STACKTRC_LEAVE;
      return substring_StringJc(ythis->content, pos + ythis->startMin, posend, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc substring_StringPartJc(StringPartJc_s* ythis, int32 pos, int32 posendP, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->substring(ythis, pos, posendP, _thCxt);
}


/**Gets the next chars from current Position.*/
StringJc getCurrent_StringPartJc_F(StringPartJc_s* ythis, int32 nChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrent_StringPartJc_F");
  
  { 
    
    if((length_StringJc(ythis->content) - ythis->start) < nChars) nChars = length_StringJc(ythis->content) - ythis->start;
    { STACKTRC_LEAVE;
      return (substring_StringJc(ythis->content, ythis->start, ythis->start + nChars, _thCxt));
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc getCurrent_StringPartJc(StringPartJc_s* ythis, int32 nChars, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->getCurrent(ythis, nChars, _thCxt);
}


/**Gets the next char at current Position.*/
char getCurrentChar_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentChar_StringPartJc_F");
  
  { 
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    if(ythis->start < length_StringJc(ythis->content)) 
    { 
      
      { STACKTRC_LEAVE;
        return charAt_StringJc(ythis->content, ythis->start);
      }
    }
    else /***/
    { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "end of StringPart:", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, ythis->start, _thCxt)
      , toString_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };// return cEndOfText;
    
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
char getCurrentChar_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->getCurrentChar(ythis, _thCxt);
}


/**Gets the current position in line (column of the text).*/
int32 getCurrentColumn_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentColumn_StringPartJc_F");
  
  { 
    int32 pos; 
    
    
    pos = lastIndexOf_CI_StringJc(ythis->content, '\n', ythis->start);
    if(pos < 0) { STACKTRC_LEAVE;
      return ythis->start;
    }//first line, no \n before
    
    else { STACKTRC_LEAVE;
      return ythis->start - pos - 1;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 getCurrentColumn_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->getCurrentColumn(ythis, _thCxt);
}


/**Returns the actual part of the string.*/
StringJc getCurrentPart_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentPart_StringPartJc_F");
  
  { 
    
    if(ythis->end > ythis->start) { STACKTRC_LEAVE;
      return substring_StringJc(ythis->content, ythis->start, ythis->end, _thCxt);
    }
    else { STACKTRC_LEAVE;
      return s0_StringJc("");
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc getCurrentPart_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->getCurrentPart(ythis, _thCxt);
}


/**Returns the last part of the string before any seek or scan operation.*/
StringJc getLastPart_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLastPart_StringPartJc_F");
  
  { 
    
    if(ythis->start > ythis->startLast) { STACKTRC_LEAVE;
      return substring_StringJc(ythis->content, ythis->startLast, ythis->start, _thCxt);
    }
    else { STACKTRC_LEAVE;
      return s0_StringJc("");
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc getLastPart_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->getLastPart(ythis, _thCxt);
}


/**Returns the actual part of the string.*/
StringJc getCurrentPart_i_StringPartJc_F(StringPartJc_s* ythis, int32 maxLength, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentPart_i_StringPartJc_F");
  
  { 
    int32 max; 
    
    
    max = (ythis->end - ythis->start) < maxLength ? ythis->end : ythis->start + maxLength;
    if(ythis->end > ythis->start) { STACKTRC_LEAVE;
      return substring_StringJc(ythis->content, ythis->start, max, _thCxt);
    }
    else { STACKTRC_LEAVE;
      return s0_StringJc("");
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc getCurrentPart_i_StringPartJc(StringPartJc_s* ythis, int32 maxLength, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->getCurrentPart_i(ythis, maxLength, _thCxt);
}


/**Returns the actual part of the string*/
StringJc toString_StringPartJc_F(ObjectJc* ithis, ThCxt* _thCxt)
{ StringPartJc_s* ythis = (StringPartJc_s*)ithis;
  Mtbl_StringPartJc const* mtthis = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  
  STACKTRC_TENTRY("toString_StringPartJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return mtthis->getCurrentPart(ythis, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc toString_StringPartJc(ObjectJc* ithis, ThCxt* _thCxt)
{ Mtbl_ObjectJc const* mtbl = (Mtbl_ObjectJc const*)getMtbl_ObjectJc(ithis, sign_Mtbl_ObjectJc);
  return mtbl->toString(ithis, _thCxt);
}


/**Returns a debug information of the content of the StringPart*/
StringJc debugString_StringPartJc_F(StringPartJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("debugString_StringPartJc_F");
  
  { 
    int32 len; 
    StringJc ret;   /**/
    
    StringBuilderJc* _stringBuilderThCxt = threadBuffer_StringBuilderJc(_thCxt);
    
    len = length_StringJc(ythis->content);
    ret = 
      ( setLength_StringBuilderJc(_stringBuilderThCxt, 0, _thCxt)
      , append_s_StringBuilderJc(_stringBuilderThCxt, substring_StringJc(ythis->content, 0, len > 20 ? 20 : len, _thCxt), _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, "<<<", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, ythis->start, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, ",", _thCxt)
      , append_I_StringBuilderJc(_stringBuilderThCxt, ythis->end, _thCxt)
      , append_z_StringBuilderJc(_stringBuilderThCxt, ">>>", _thCxt)
      , toStringNonPersist_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      )/*J2C:non-persistent*/;
    if(ythis->start < len) 
    { 
      
      /***/
      ret = 
        ( append_s_StringBuilderJc(_stringBuilderThCxt, substring_StringJc(ythis->content, ythis->start, len > (ythis->start + 20) ? ythis->start + 20 : len, _thCxt), _thCxt)
        , toStringNonPersist_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
        )/*J2C:non-persistent*/;
    }
    /***/
    ret = 
      ( append_z_StringBuilderJc(_stringBuilderThCxt, "<<<", _thCxt)
      , toStringNonPersist_StringBuilderJc(&(_stringBuilderThCxt)->base.object, _thCxt)
      )/*J2C:non-persistent*/;
    { STACKTRC_LEAVE;
      return ret;
    }//java2c: buffer in threadContext
    
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc debugString_StringPartJc(StringPartJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  return mtbl->debugString(ythis, _thCxt);
}


/**Central mehtod to invoke excpetion, usefull to set a breakpoint in debug*/
void throwIndexOutOfBoundsException_StringPartJc_F(StringPartJc_s* ythis, StringJc sMsg, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("throwIndexOutOfBoundsException_StringPartJc_F");
  
  { 
    
    { throw_sJc(ident_IndexOutOfBoundsExceptionJc, sMsg, 0, &_thCxt->stacktraceThreadContext, __LINE__); };
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void throwIndexOutOfBoundsException_StringPartJc(StringPartJc_s* ythis, StringJc sMsg, ThCxt* _thCxt)
{ Mtbl_StringPartJc const* mtbl = (Mtbl_StringPartJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringPartJc);
  mtbl->throwIndexOutOfBoundsException(ythis, sMsg, _thCxt);
}


/**Replaces up to 20 placeholder with a given content.*/
StringJc replace_StringPartJc(/*static*/ StringJc src, StringJc_Y* placeholder, StringJc_Y* value, struct StringBuilderJc_t* dst, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("replace_StringPartJc");
  
  { 
    int32 len; 
    int32 ixPos = 0; 
    int32 nrofToken; 
    struct StringPartJc_t* spPattern = null; 
    int32 posPatternStart = 0; 
    int32 posPattern = 0; 
    
    ObjectJc *newObj1_1=null; //J2C: temporary Objects for new operations
    
    len = length_StringJc(src);
    ixPos = 0;
    nrofToken = placeholder->head.length;
    if(nrofToken != value->head.length) { throw_s0Jc(ident_IllegalArgumentExceptionJc, "token and value should have same size, lesser 20", 0, &_thCxt->stacktraceThreadContext, __LINE__); return null_StringJc; };
    if(dst == null) 
    { 
      ObjectJc *newObj2_1=null; //J2C: temporary Objects for new operations
      
      dst = ctorO_I_StringBuilderJc(/*static*/(newObj2_1 = alloc_ObjectJc(sizeof_StringBuilderJc, 0, _thCxt)), len + 100, _thCxt);
      activateGarbageCollectorAccess_BlockHeapJc(newObj2_1, null);
    }//calculate about 53 chars for identifier
    
    
    spPattern = ctorO_S_StringPartJc(/*static*/(newObj1_1 = alloc_ObjectJc(sizeof_StringPartJc_s, 0, _thCxt)), src, _thCxt);
    posPatternStart = 0;
    /*no initvalue*/
    do 
      { 
        int32_Y* type; 
        
        ObjectJc *newObj2_1=null; //J2C: temporary Objects for new operations
        
        
        type = (int32_Y*)ctorO_ObjectArrayJc((newObj2_1 = alloc_ObjectJc( sizeof(ObjectArrayJc) + (1) * sizeof(int32), mIsLargeSize_objectIdentSize_ObjectJc, _thCxt)), 1, sizeof(int32),REFLECTION_int32, 0);
        posPattern = indexOfAnyString_StringPartJc_F(spPattern, placeholder, posPatternStart, length_StringPartJc_F(spPattern, _thCxt), type, null, _thCxt);
        if(posPattern >= 0) 
        { 
          int32 ixValue; 
          
          
          append_s_StringBuilderJc(dst, substring_StringJc(src, posPatternStart, posPattern, _thCxt), _thCxt);
          ixValue = type->data[0];
          append_s_StringBuilderJc(dst, value->data[ixValue], _thCxt);
          posPatternStart = posPattern + length_StringJc(placeholder->data[ixValue]);
        }
        else 
        { //:last pattern constant part:
          
          
          append_s_StringBuilderJc(dst, substring_I_StringJc(src, posPatternStart, _thCxt), _thCxt);
          posPatternStart = -1;//mark end
          
        }
        activateGarbageCollectorAccess_BlockHeapJc(newObj2_1, null);
      }while(posPatternStart >= 0);
    { STACKTRC_LEAVE;
      activateGarbageCollectorAccess_BlockHeapJc(newObj1_1, PTR_StringJc(toString_StringBuilderJc(& ((* (dst)).base.object)/*J2cT1*/, _thCxt)));
      return toString_StringBuilderJc(& ((* (dst)).base.object)/*J2cT1*/, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}



/**J2C: Reflections and Method-table *************************************************/
const MtblDef_StringPartJc mtblStringPartJc = {
{ { sign_Mtbl_StringPartJc//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((92 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, assign_S_StringPartJc_F //assign_S
, assign_XX_StringPartJc_F //assign_XX
, assignFromEnd_StringPartJc_F //assignFromEnd
, setIgnoreComment_b_StringPartJc_F //setIgnoreComment_b
, setIgnoreComment_SS_StringPartJc_F //setIgnoreComment_SS
, setIgnoreEndlineComment_b_StringPartJc_F //setIgnoreEndlineComment_b
, setIgnoreEndlineComment_S_StringPartJc_F //setIgnoreEndlineComment_S
, setIgnoreWhitespaces_StringPartJc_F //setIgnoreWhitespaces
, setBeginMaxPart_StringPartJc_F //setBeginMaxPart
, fromEnd_StringPartJc_F //fromEnd
, getLineCt_StringPartJc_F //getLineCt
, getLen_StringPartJc_F //getLen
, length_StringPartJc_F //length
, lengthMaxPart_StringPartJc_F //lengthMaxPart
, lento_i_StringPartJc_F //lento_i
, lento_c_StringPartJc_F //lento_c
, lento_S_StringPartJc_F //lento_S
, lento_Si_StringPartJc_F //lento_Si
, lentoIdentifier_StringPartJc_F //lentoIdentifier
, lentoIdentifier_SS_StringPartJc_F //lentoIdentifier_SS
, lentoAnyNonEscapedChar_StringPartJc_F //lentoAnyNonEscapedChar
, lentoNonEscapedString_StringPartJc_F //lentoNonEscapedString
, seek_i_StringPartJc_F //seek_i
, seekNoWhitespace_StringPartJc_F //seekNoWhitespace
, skipWhitespaceAndComment_StringPartJc_F //skipWhitespaceAndComment
, seekNoWhitespaceOrComments_StringPartJc_F //seekNoWhitespaceOrComments
, isFound_StringPartJc_F //isFound
, found_StringPartJc_F //found
, seekBegin_StringPartJc_F //seekBegin
, seek_Si_StringPartJc_F //seek_Si
, seekAnyString_StringPartJc_F //seekAnyString
, seek_ci_StringPartJc_F //seek_ci
, xxxseekEnd_StringPartJc_F //xxxseekEnd
, seekNoChar_StringPartJc_F //seekNoChar
, indexOfAnyChar_Sii_StringPartJc_F //indexOfAnyChar_Sii
, lastIndexOfAnyChar_StringPartJc_F //lastIndexOfAnyChar
, indexOfAnyString_StringPartJc_F //indexOfAnyString
, indexOfAnyCharOutsideQuotion_StringPartJc_F //indexOfAnyCharOutsideQuotion
, indexEndOfQuotion_StringPartJc_F //indexEndOfQuotion
, indexOfAnyChar_S_StringPartJc_F //indexOfAnyChar_S
, indexOfNoChar_Si_StringPartJc_F //indexOfNoChar_Si
, indexOfNoChar_S_StringPartJc_F //indexOfNoChar_S
, lentoAnyChar_Si_StringPartJc_F //lentoAnyChar_Si
, lentoAnyChar_Sii_StringPartJc_F //lentoAnyChar_Sii
, lentoAnyString_SYi_StringPartJc_F //lentoAnyString_SYi
, lentoAnyString_SYii_StringPartJc_F //lentoAnyString_SYii
, lentoAnyStringWithIndent_StringPartJc_F //lentoAnyStringWithIndent
, lentoAnyCharOutsideQuotion_StringPartJc_F //lentoAnyCharOutsideQuotion
, lentoQuotionEnd_StringPartJc_F //lentoQuotionEnd
, lentoAnyChar_S_StringPartJc_F //lentoAnyChar_S
, len0end_StringPartJc_F //len0end
, setLengthMax_StringPartJc_F //setLengthMax
, lenBacktoNoChar_StringPartJc_F //lenBacktoNoChar
, trim_StringPartJc_F //trim
, trimComment_StringPartJc_F //trimComment
, indexOf_c_StringPartJc_F //indexOf_c
, indexOf_ci_StringPartJc_F //indexOf_ci
, indexOf_S_StringPartJc_F //indexOf_S
, indexOf_Sii_StringPartJc_F //indexOf_Sii
, equals_S_StringPartJc_F //equals_S
, startsWith_StringPartJc_F //startsWith
, scan_StringPartJc_F //scan
, scanOk_StringPartJc_F //scanOk
, scanQuotion_SSSY_StringPartJc_F //scanQuotion_SSSY
, scanQuotion_SSSYi_StringPartJc_F //scanQuotion_SSSYi
, scanDigits_StringPartJc_F //scanDigits
, scanStart_StringPartJc_F //scanStart
, scanEntry_StringPartJc_F //scanEntry
, scanPositivInteger_StringPartJc_F //scanPositivInteger
, scanInteger_StringPartJc_F //scanInteger
, scanFloatNumber_StringPartJc_F //scanFloatNumber
, scanHex_StringPartJc_F //scanHex
, scanHexOrDecimal_StringPartJc_F //scanHexOrDecimal
, scanIdentifier_StringPartJc_F //scanIdentifier
, scanIdentifier_SS_StringPartJc_F //scanIdentifier_SS
, getLastScannedIntegerNumber_StringPartJc_F //getLastScannedIntegerNumber
, getLastScannedFloatNumber_StringPartJc_F //getLastScannedFloatNumber
, getLastScannedString_StringPartJc_F //getLastScannedString
, getCircumScriptionToAnyChar_StringPartJc_F //getCircumScriptionToAnyChar
, getCircumScriptionToAnyCharOutsideQuotion_StringPartJc_F //getCircumScriptionToAnyCharOutsideQuotion
, getCircumScriptionToAnyChar_p_StringPartJc_F //getCircumScriptionToAnyChar_p
, getCurrentPosition_StringPartJc_F //getCurrentPosition
, setCurrentPosition_StringPartJc_F //setCurrentPosition
, substring_StringPartJc_F //substring
, getCurrent_StringPartJc_F //getCurrent
, getCurrentChar_StringPartJc_F //getCurrentChar
, getCurrentColumn_StringPartJc_F //getCurrentColumn
, getCurrentPart_StringPartJc_F //getCurrentPart
, getLastPart_StringPartJc_F //getLastPart
, getCurrentPart_i_StringPartJc_F //getCurrentPart_i
, debugString_StringPartJc_F //debugString
, throwIndexOutOfBoundsException_StringPartJc_F //throwIndexOutOfBoundsException
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_ObjectJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_StringPartJc_F //toString
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_StringPartJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_StringPartJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_StringPartJc, ObjectJc) }
   }
 };

extern struct ClassJc_t const reflection_StringPartJc_s;
extern struct ClassJc_t const reflection_StringJc;
const struct Reflection_Fields_StringPartJc_s_t
{ ObjectArrayJc head; FieldJc data[25];
} reflection_Fields_StringPartJc_s =
{ CONST_ObjectArrayJc(FieldJc, 25, OBJTYPE_FieldJc, null, &reflection_Fields_StringPartJc_s)
, {
     { "start"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->start) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "end"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->end) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "startMin"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->startMin) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "endMax"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->endMax) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "content"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->content) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "nLineCt"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->nLineCt) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "bCurrentOk"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->bCurrentOk) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "bStartScan"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->bStartScan) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "startLast"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->startLast) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "endLast"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->endLast) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "startScan"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->startScan) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "bFound"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->bFound) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "nLastIntegerNumber"
    , 5 //nrofArrayElements
    , REFLECTION_int64
    , 8 << kBitPrimitiv_Modifier_reflectJc |kStaticArray_Modifier_reflectJc |kEmbeddedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->nLastIntegerNumber) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "idxLastIntegerNumber"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->idxLastIntegerNumber) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "nLastFloatNumber"
    , 5 //nrofArrayElements
    , REFLECTION_double
    , 8 << kBitPrimitiv_Modifier_reflectJc |kStaticArray_Modifier_reflectJc |kEmbeddedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->nLastFloatNumber) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "idxLastFloatNumber"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->idxLastFloatNumber) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "sLastString"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->sLastString) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "bitMode"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->bitMode) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "sCommentStart"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->sCommentStart) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "sCommentEnd"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->sCommentEnd) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "sCommentToEol"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((StringPartJc_s*)(0x1000))->sCommentToEol) - (int32)(StringPartJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringPartJc_s
    }
   , { "seekToLeft"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&seekToLeft_StringPartJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&seekToLeft_StringPartJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringPartJc_s
    }
   , { "seekBack"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&seekBack_StringPartJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&seekBack_StringPartJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringPartJc_s
    }
   , { "cStartOfText"
    , 0 //nrofArrayElements
    , REFLECTION_char
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&cStartOfText_StringPartJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&cStartOfText_StringPartJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringPartJc_s
    }
   , { "cEndOfText"
    , 0 //nrofArrayElements
    , REFLECTION_char
    , 4 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&cEndOfText_StringPartJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&cEndOfText_StringPartJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringPartJc_s
    }
} };
const ClassJc reflection_StringPartJc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "StringPartJc_s"
,  0 //position of ObjectJc
, sizeof(StringPartJc_s)
, (FieldJcArray const*)&reflection_Fields_StringPartJc_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_StringPartJc_s //superclass
, null //interfaces
, 0    //modifiers
, &mtblStringPartJc.mtbl.head
};
