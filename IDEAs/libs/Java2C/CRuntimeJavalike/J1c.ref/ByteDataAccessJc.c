/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "J1c/ByteDataAccessJc.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "Fwc/fw_Exception.h"  //reference-association: ExceptionJc
#include "Jc/SystemJc.h"  //reference-association: FloatJc


/* J2C: Method-table-references *********************************************************/
#ifndef ByteDataAccessJcMTBDEF
  #define ByteDataAccessJcMTBDEF
  typedef struct ByteDataAccessJcMTB_t { struct Mtbl_ByteDataAccessJc_t const* mtbl; struct ByteDataAccessJc_t* ref; } ByteDataAccessJcMTB;
#endif


/**This class is a base class to control the access to binary data.
The binary data may typically used or produced from a part of software written in C or C++.
There the binary data are struct-constructs.
<br>
It is able to support several kinds of struct constructs:<ul>
<li>Simple <code>struct</code> are adequate mapped with a derivated class of this class,
using the protected commonly access methods like {@link _getInt(int, int)} with predefined indexes
in special methods like getValueXyz().</li>
<li>Complex <code>struct</code> with nested <code>struct</code> inside are mapped
with one derivated class per <code>struct</code>, define one reference per nested struct
and overwriting the method {@link assignDataToFixChilds()}</li>
<li>Base <code>struct</code> inside a <code>struct</code> (inherition in C) can be mapped with
extra derivated classes for the base struct and usind the
{@link assignCasted_i(ByteDataAccess, int)}-method.</li>
<li>A pack of data with several struct may be mapped using the {@addChild(ByteDataAccess)}-method.
Thereby a parent should be defined, and the structs of the pack are children of this parent.
That structs need not be from the same type.</li>
<li>packs of struct with parent are nestable, it is constructable as a tree of pack of structs.
The parent of the pack is the tree node. It is likewise a XML tree.
The data may be also transformed to a XML data representation
or the data structure may be explained with a XML tree, but they are not
XML data straight.</li>
</ul>
This application possibilities show a capable of development system to access binary data.
The other, hand made way was calculate with indices of the byte[idx] specially user programmed.
This class helps to make such complex index calculation needlessly.
One struct at C level corresponds with one derivated class of ByteDataAccess.
But last also a generation of the java code from C/C++-header files containing the structs is able to.
So the definition of byte positions are made only on one source. The C/C++ is primary thereby.

<h2>children, currentChild, addChild</h2>
Children are used to evaluate or write different data structures after a known structure.
The children may be from several derivated types of this class.
With children and children inside children a tree of different data can be built or evaluated.

If no child is added yet, the indices have the following values:
<ul>
<li>idxCurrentChild = -1.
<li>idxCurrentChildEnd = index after known (named head-) data.
</ul>
A call of {@link next()} sets the indices to a possible but not yet defined current child:
<ul>
<li>idxCurrentChild = the index after the last known child or known (head-) data.
It is idxCurrentChildEnd from state before.
<li>idxCurrentChildEnd = -2, because the length of the child is unknown.
The -2 is used to mark call of next().
</ul>
A call of {@link addChild()} or its adequate addChildXY() sets the indices to the given current child:
<ul>
<li>idxCurrentChild = the index after known (head-) data, the index of the child.
<li>idxCurrentChildEnd = idxCurrentChild + {@link specifyLengthElement()} if this method returns >=0.
<li>idxCurrentChildEnd = idxCurrentChild + {@link specifyLengthElementHead()} if this method returns >=0.
<li>idxCurrentChildEnd = -1, because the length of the child is not known yet if both methods return -1.
</ul>
The length of the current Child may be set while evaluating the child's data.
The user should be call {@link setLengthElement(int)} with the child
or {@link setLengthCurrentChildElement(int)} with the parent, respectively with this.
<ul>
<li>idxCurrentChild = is still the index of the child.
<li>idxCurrentChildEnd = idxCurrentChild + given length.
</ul>
If this methods are not called, but next() or addChild...() is called however, without a known length
but this (the parent) knows the rules to determine the length of its possible children,
it is possible to do that. The method {@link specifyLengthCurrentChildElement()} supplied the number of bytes.
But if this method is not overwritten in the inherited class, an exception is thrown.


<br>
The UML structure of such an class in a environment may be shown with the
followed object model diagram, <br>
<code> <+>---> </code>is a composition,
<code> <>---> </code>is a aggregation, <code> <|---- </code>is a inherition.
<pre>
+-------------------------------+                 +----------+
| ByteDataAccess                |----data-------->| byte[]   |
|-------------------------------|                 +----------+
|idxBegin:int                   |
|idxChild:int                   |<---------------+ a known parent
+-------------+     |idxEnd:int                     |---parent-------+ setted in addChild()
| derivated   |     |-------------------------------|
| user        |---|>|specifyLengthElement()         |
| classes     |     |specifyLengthElementHead()     |--currentChild--+ the actual child element
+-------------+     |specifyLengthCurrentChild()    |<---------------+
+-------------------------------+
</pre>

*/


const char sign_Mtbl_ByteDataAccessJc[] = "ByteDataAccessJc"; //to mark method tables of all implementations

const int8 kNothing_ByteDataAccessJc = (int8)(0xff);

/*Constructor */
struct ByteDataAccessJc_t* ctorO_ByteDataAccessJc(ObjectJc* othis, ThCxt* _thCxt)
{ ByteDataAccessJc_s* ythis = (ByteDataAccessJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_ByteDataAccessJc");
  checkConsistence_ObjectJc(othis, sizeof(ByteDataAccessJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_ByteDataAccessJc_s, sizeof(ByteDataAccessJc_s));  
  //j2c: Initialize all class variables:
  {
  }
  { 
    
    ythis->data = null;
    ythis->bBigEndian = false;
    ythis->bExpand = false;
    ythis->idxBegin = 0;
    ythis->idxEnd = 0;
    ythis->idxCurrentChild = -1;//to mark start.
    
    ythis->idxCurrentChildEnd = 0;
    CLEARREFJc(ythis->parent);
    CLEARREFJc(ythis->currentChild);//charset = Charset.forName("ISO-8859-1");  //NOTE: String(..., Charset) is only support from Java 6
    
    set_StringJc(&(ythis->charset), z_StringJc("ISO-8859-1"));
  }
  STACKTRC_LEAVE;
  return ythis;
}



/**Conversion of characters in range 0x80..0xbf */
int32 getLengthHead_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLengthHead_ByteDataAccessJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return ythis->idxFirstChild - ythis->idxBegin;
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the elements data to the default empty data.*/
/*J2C: dynamic call variant of the override-able method: */
void specifyEmptyDefaultData_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  mtbl->specifyEmptyDefaultData(ythis, _thCxt);
}


/**Specifies the length of the head data*/
/*J2C: dynamic call variant of the override-able method: */
int32 specifyLengthElementHead_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  return mtbl->specifyLengthElementHead(ythis, _thCxt);
}


/**Returns the actual length of the whole element presenting with this class.*/
/*J2C: dynamic call variant of the override-able method: */
int32 specifyLengthElement_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  return mtbl->specifyLengthElement(ythis, _thCxt);
}


/**Returns the length of a child element at current position specified in  the derivated class.*/
int32 specifyLengthCurrentChildElement_ByteDataAccessJc_F(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("specifyLengthCurrentChildElement_ByteDataAccessJc_F");
  
  { 
    
    { throw_s0Jc(ident_IllegalArgumentExceptionJc, "The length of the child is undefined, no user specification is known", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 specifyLengthCurrentChildElement_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  return mtbl->specifyLengthCurrentChildElement(ythis, _thCxt);
}


/**Assigns new data to this element*/
void assignData_iYi_ByteDataAccessJc_F(ByteDataAccessJc_s* ythis, int8_Y* data, int32 length, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtthis = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  
  STACKTRC_TENTRY("assignData_iYi_ByteDataAccessJc_F");
  
  { 
    
    if(length == 0) 
    { 
      
      length = -1;//because elsewhere an exception is thrown. At least the head length are present.
      
    }
    mtthis->assignData_iYii(ythis, data, length, 0, _thCxt);
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void assignData_iYi_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int8_Y* data, int32 length, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  mtbl->assignData_iYi(ythis, data, length, _thCxt);
}


/**Assigns new data to this element at given index in data*/
void assignData_iYii_ByteDataAccessJc_F(ByteDataAccessJc_s* ythis, int8_Y* data, int32 lengthData, int32 index, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtthis = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  
  STACKTRC_TENTRY("assignData_iYii_ByteDataAccessJc_F");
  
  { 
    
    ythis->data = data;
    if(index < 0) 
    { 
      
      { throw_s0Jc(ident_RuntimeExceptionJc, "idx have to be >=0", 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    }
    if(lengthData == 0) 
    { 
      
      { throw_s0Jc(ident_RuntimeExceptionJc, "length ==0 is not accepted, it may be a argument mistake.", 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    }
    ythis->bExpand = (lengthData <= 0);
    ythis->idxBegin = index;
    ythis->idxCurrentChild = -1;
    ythis->idxFirstChild = ythis->idxCurrentChildEnd = /*? assignment*/index + mtthis->specifyLengthElementHead(ythis, _thCxt);//-1;         //no length of element is known, it means, no child is appended yet.
    
    ythis->idxEnd = ythis->bExpand ? ythis->idxFirstChild : lengthData;
    if(ythis->idxEnd > data->head.length) 
    { 
       //J2C: temporary Stringbuffer for String concatenation
      StringBuilderJc* _tempString2_1=null; 
      
      { throw_sJc(ident_IllegalArgumentExceptionJc, 
        ( _tempString2_1 = new_StringBuilderJc(-1, _thCxt)
        , setStringConcatBuffer_StringBuilderJc(_tempString2_1)
        , append_z_StringBuilderJc(_tempString2_1, "not enough data bytes, requested=", _thCxt)
        , append_I_StringBuilderJc(_tempString2_1, ythis->idxEnd, _thCxt)
        , append_z_StringBuilderJc(_tempString2_1, ", buffer-length=", _thCxt)
        , append_I_StringBuilderJc(_tempString2_1, data->head.length, _thCxt)
        , toString_StringBuilderJc(&(_tempString2_1)->base.object, _thCxt)
        ), 0, &_thCxt->stacktraceThreadContext, __LINE__); };
      activateGarbageCollectorAccess_BlockHeapJc(&_tempString2_1->base.object, null);
    }
    if(REFJc(ythis->parent) != null && REFJc(REFJc(ythis->parent)->currentChild) == ythis) 
    { 
      
      CLEARREFJc(REFJc(ythis->parent)->currentChild);//the child is invalid because it is new assigned.
      
    }
    CLEARREFJc(ythis->parent);
    CLEARREFJc(ythis->currentChild);
    mtthis->assignDataToFixChilds(ythis, _thCxt);
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void assignData_iYii_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int8_Y* data, int32 lengthData, int32 index, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  mtbl->assignData_iYii(ythis, data, lengthData, index, _thCxt);
}


/**Initializes a top level, the data are considered as non initalized.*/
void assignEmpty_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int8_Y* data, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtthis = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  
  STACKTRC_TENTRY("assignEmpty_ByteDataAccessJc");
  
  { 
    
    TRY
    { 
      
      mtthis->assignData_iYii(ythis, data, -1, 0, _thCxt);
    }_TRY
    CATCH(IllegalArgumentException, e)
    
      { 
        
        
      }
    END_TRY
    mtthis->specifyEmptyDefaultData(ythis, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Remove all children*/
void removeChildren_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("removeChildren_ByteDataAccessJc");
  
  { 
    
    ythis->idxCurrentChildEnd = ythis->idxFirstChild;
    if(ythis->bExpand) 
    { 
      
      ythis->idxEnd = ythis->idxFirstChild;
    }
    ythis->idxCurrentChild = -1;
    if(REFJc(ythis->currentChild) != null) 
    { 
      
      detach_ByteDataAccessJc(REFJc(ythis->currentChild), _thCxt);
      CLEARREFJc(ythis->currentChild);
    }
  }
  STACKTRC_LEAVE;
}


/**Remove all connections. Especially for children. */
void detach_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("detach_ByteDataAccessJc");
  
  { 
    
    if(REFJc(ythis->currentChild) != null) 
    { 
      
      detach_ByteDataAccessJc(REFJc(ythis->currentChild), _thCxt);
    }
    ythis->data = null;
    CLEARREFJc(ythis->parent);
    ythis->idxBegin = ythis->idxEnd = /*? assignment*/0;
    ythis->idxFirstChild = ythis->idxCurrentChild = /*? assignment*/ythis->idxCurrentChildEnd = /*? assignment*/0;
    ythis->bExpand = false;
  }
  STACKTRC_LEAVE;
}


/**Assigns this element to the same position in data, but it is another view.*/
void assignCasted_i_ByteDataAccessJc(ByteDataAccessJc_s* ythis, struct ByteDataAccessJc_t* src, int32 offsetCastToInput, int32 lengthDst, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtthis = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  
  STACKTRC_TENTRY("assignCasted_i_ByteDataAccessJc");
  
  { 
    
    ythis->bBigEndian = src->bBigEndian;
    ythis->bExpand = src->bExpand;//assignData(src.data, src.idxBegin + lengthDst + offsetCastToInput, src.idxBegin + offsetCastToInput);
    
    mtthis->assignData_iYii(ythis, src->data, src->idxEnd, src->idxBegin + offsetCastToInput, _thCxt);//lengthDst is unsused, not necessary because lengthElementHead is knwon!
    
  }
  STACKTRC_LEAVE;
}


/**Older form, see protected method {@link assignCasted_i(ByteDataAccess, int )}*/
void assignDowncast_i_ByteDataAccessJc(ByteDataAccessJc_s* ythis, struct ByteDataAccessJc_t* input, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assignDowncast_i_ByteDataAccessJc");
  
  { 
    
    assignCasted_i_ByteDataAccessJc(ythis, input, 0, -1, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**assigns the element to the current child position of parent,*/
void assignAsChild_ByteDataAccessJc(ByteDataAccessJc_s* ythis, struct ByteDataAccessJc_t* parent, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assignAsChild_ByteDataAccessJc");
  
  { 
    
    addChild_ByteDataAccessJc(parent, ythis, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**assigns the element to the given position of the parents data to present a child of the parent*/
void assignAtIndex_iiXX_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idxChildInParent, int32 lengthChild, struct ByteDataAccessJc_t* parent, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtthis = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  
  STACKTRC_TENTRY("assignAtIndex_iiXX_ByteDataAccessJc");
  
  { 
    
    ythis->bBigEndian = parent->bBigEndian;
    ythis->bExpand = parent->bExpand;
    mtthis->assignData_iYii(ythis, parent->data, parent->idxBegin + idxChildInParent + lengthChild, parent->idxBegin + idxChildInParent, _thCxt);
    mtthis->setBigEndian(ythis, parent->bBigEndian, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**assigns the element to the given position of the parents data to present a child of the parent.*/
void assignAtIndex_iXX_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idxChildInParent, struct ByteDataAccessJc_t* parent, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtthis = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  
  STACKTRC_TENTRY("assignAtIndex_iXX_ByteDataAccessJc");
  
  { 
    int32 lengthHead; 
    
    
    lengthHead = getLengthHead_ByteDataAccessJc(ythis, _thCxt);
    mtthis->assignData_iYii(ythis, parent->data, parent->idxEnd, parent->idxBegin + idxChildInParent, _thCxt);
    mtthis->setBigEndian(ythis, parent->bBigEndian, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**This method is called inside all assign...() methods.*/
void assignDataToFixChilds_ByteDataAccessJc_F(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("assignDataToFixChilds_ByteDataAccessJc_F");
  
  { 
    
    
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void assignDataToFixChilds_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  mtbl->assignDataToFixChilds(ythis, _thCxt);
}


/**adds an child Element after the current child or as first child after head.*/
bool addChild_ByteDataAccessJc(ByteDataAccessJc_s* ythis, struct ByteDataAccessJc_t* child, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtthis = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  
  STACKTRC_TENTRY("addChild_ByteDataAccessJc");
  
  { 
    ByteDataAccessJcMTB childMtb;   /**/
    
    
    mtthis->notifyAddChild(ythis, _thCxt);
    child->bBigEndian = ythis->bBigEndian;
    child->bExpand = ythis->bExpand;
    setIdxtoNextCurrentChild_ByteDataAccessJc(ythis, _thCxt);
    SETMTBJc(childMtb, child, ByteDataAccessJc);
    childMtb.mtbl->assignData_iYii( (childMtb.ref), ythis->data, ythis->bExpand ? -1 : ythis->idxEnd, ythis->idxCurrentChild, _thCxt);
    childMtb.mtbl->setBigEndian( (childMtb.ref), ythis->bBigEndian, _thCxt);
    SETREFJc(child->parent, ythis, ByteDataAccessJc_s);
    SETREFJc(ythis->currentChild, child, ByteDataAccessJc_s);
    correctIdxChildEnd_ByteDataAccessJc(ythis, child->idxCurrentChildEnd, _thCxt);
    { STACKTRC_LEAVE;
      return ythis->bExpand;
    }
  }
  STACKTRC_LEAVE;
}


/**remove the current child to assign another current child instead of the first one.*/
void removeChild_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("removeChild_ByteDataAccessJc");
  
  { 
    
    if(ythis->bExpand) { throw_s0Jc(ident_RuntimeExceptionJc, "don't call it in expand mode", 0, &_thCxt->stacktraceThreadContext, __LINE__); };//revert the current child.
    
    ythis->idxCurrentChildEnd = ythis->idxCurrentChild;
    ythis->idxCurrentChild = -1;
  }
  STACKTRC_LEAVE;
}


/**sets the idxCurrentChild to the known idxCurrentChildEnd.*/
void setIdxtoNextCurrentChild_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIdxtoNextCurrentChild_ByteDataAccessJc");
  
  { 
    
    if(ythis->idxCurrentChildEnd >= ythis->idxCurrentChild) 
    { //:This is the standard case.
      //:NOTE: idxCurrentChild = -1 is assert if no child is added before.
      
      
      ythis->idxCurrentChild = ythis->idxCurrentChildEnd;
    }
    else if(ythis->idxCurrentChildEnd == -2) 
    { }
    else 
    { 
      
      { throw_s0Jc(ident_RuntimeExceptionJc, "unexpected idxCurrentChildEnd", 0, &_thCxt->stacktraceThreadContext, __LINE__); };//its a programming error.
      
    }
    ythis->idxCurrentChildEnd = -1;//the child content is not checked, this index will be set if setLengthCurrentChildElement() is called.
    
  }
  STACKTRC_LEAVE;
}


/**sets the idxCurrentChildEnd and idxEnd*/
bool setIdxCurrentChildEnd_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setIdxCurrentChildEnd_ByteDataAccessJc");
  
  { 
    
    if(ythis->bExpand) 
    { 
      
      if(ythis->data->head.length < ythis->idxCurrentChild + nrofBytes) 
      { 
         //J2C: temporary Stringbuffer for String concatenation
        StringBuilderJc* _tempString3_1=null; 
        
        { throw_sJc(ident_IllegalArgumentExceptionJc, 
          ( _tempString3_1 = new_StringBuilderJc(-1, _thCxt)
          , setStringConcatBuffer_StringBuilderJc(_tempString3_1)
          , append_z_StringBuilderJc(_tempString3_1, "data length to small:", _thCxt)
          , append_I_StringBuilderJc(_tempString3_1, (ythis->idxCurrentChild + nrofBytes), _thCxt)
          , toString_StringBuilderJc(&(_tempString3_1)->base.object, _thCxt)
          ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
        activateGarbageCollectorAccess_BlockHeapJc(&_tempString3_1->base.object, null);
      }
    }
    else 
    { 
      
      if(ythis->idxEnd < ythis->idxCurrentChildEnd) 
      { //:not expand, but the nrof data are to few
        
         //J2C: temporary Stringbuffer for String concatenation
        StringBuilderJc* _tempString3_1=null; 
        
        { throw_sJc(ident_IllegalArgumentExceptionJc, 
          ( _tempString3_1 = new_StringBuilderJc(-1, _thCxt)
          , setStringConcatBuffer_StringBuilderJc(_tempString3_1)
          , append_z_StringBuilderJc(_tempString3_1, "to few user data:", _thCxt)
          , append_I_StringBuilderJc(_tempString3_1, (ythis->idxCurrentChild + nrofBytes), _thCxt)
          , toString_StringBuilderJc(&(_tempString3_1)->base.object, _thCxt)
          ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
        activateGarbageCollectorAccess_BlockHeapJc(&_tempString3_1->base.object, null);
      }
    }
    correctIdxChildEnd_ByteDataAccessJc(ythis, ythis->idxCurrentChild + nrofBytes, _thCxt);//also of all parents
    
    { STACKTRC_LEAVE;
      return ythis->bExpand;
    }
  }
  STACKTRC_LEAVE;
}


/**Adds a child Element at current end of data to write data.*/
void addChildEmpty_ByteDataAccessJc(ByteDataAccessJc_s* ythis, struct ByteDataAccessJc_t* child, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildEmpty_ByteDataAccessJc");
  
  { 
    
    addChild_ByteDataAccessJc(ythis, child, _thCxt);
    ((Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&(child)->base.object, sign_Mtbl_ByteDataAccessJc) )->specifyEmptyDefaultData(child, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Notifies, that a child is added*/
void notifyAddChild_ByteDataAccessJc_F(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("notifyAddChild_ByteDataAccessJc_F");
  
  { //:in default, do nothing with this.
    
    
    
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void notifyAddChild_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  mtbl->notifyAddChild(ythis, _thCxt);
}


/**Increments the idxEnd and the idxCurrentChildEnd if a new child is added*/
void correctCurrentChildEnd_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idxEndNew, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("correctCurrentChildEnd_ByteDataAccessJc");
  
  { 
    
    if(ythis->idxEnd < idxEndNew) 
    { 
      
      ythis->idxEnd = idxEndNew;
    }
    if(ythis->idxCurrentChildEnd < idxEndNew) 
    { 
      
      ythis->idxCurrentChildEnd = idxEndNew;
    }
    if(REFJc(ythis->parent) != null) 
    { 
      
      correctCurrentChildEnd_ByteDataAccessJc(REFJc(ythis->parent), idxEndNew, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Increments the idxEnd if a new child is added*/
void correctIdxChildEnd_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idxCurrentChildEndNew, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("correctIdxChildEnd_ByteDataAccessJc");
  
  { 
    
    if(ythis->bExpand) 
    { //:do it only in expand mode
      
      
      ythis->idxEnd = idxCurrentChildEndNew;
    }
    ythis->idxCurrentChildEnd = idxCurrentChildEndNew;
    if(REFJc(ythis->parent) != null) 
    { 
      
      correctIdxChildEnd_ByteDataAccessJc(REFJc(ythis->parent), idxCurrentChildEndNew, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Expands the end index of the parent, it means the management*/
void expandParent_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("expandParent_ByteDataAccessJc");
  
  { 
    
    if(ythis->idxBegin == 0 && REFJc(ythis->parent) == null) 
    { }
    else if(REFJc(ythis->parent) != null) 
    { 
      
      if(REFJc(ythis->parent)->idxEnd < ythis->idxEnd) 
      { 
        
        REFJc(ythis->parent)->idxEnd = ythis->idxEnd;
      }
      expandParent_ByteDataAccessJc(REFJc(ythis->parent), _thCxt);
    }
    else { throw_s0Jc(ident_IllegalArgumentExceptionJc, "invalid expandParent()", 0, &_thCxt->stacktraceThreadContext, __LINE__); };
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 integer value without a child instance, but returns the value as integer.*/
int64 getChildInteger_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildInteger_ByteDataAccessJc");
  
  { //:NOTE: there is no instance for this child, but it is the current child anyway.
    
    
    setIdxtoNextCurrentChild_ByteDataAccessJc(ythis, _thCxt);
    if(!setIdxCurrentChildEnd_ByteDataAccessJc(ythis, nrofBytes, _thCxt)) 
    { //:NOTE: to read from idxInChild = 0, build the difference as shown:
      
      int64 value; 
      
      
      value = _getLong_ByteDataAccessJc(ythis, ythis->idxCurrentChild - ythis->idxBegin, nrofBytes, _thCxt);
      { STACKTRC_LEAVE;
        return value;
      }
    }
    else { throw_s0Jc(ident_RuntimeExceptionJc, "Not available in expand mode.", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 float value without a child instance, but returns the value as integer.*/
float getChildFloat_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildFloat_ByteDataAccessJc");
  
  { //:NOTE: there is no instance for this child, but it is the current child anyway.
    
    
    setIdxtoNextCurrentChild_ByteDataAccessJc(ythis, _thCxt);
    if(!setIdxCurrentChildEnd_ByteDataAccessJc(ythis, 4, _thCxt)) 
    { //:NOTE: to read from idxInChild = 0, build the difference as shown:
      
      int32 intRepresentation; 
      
      
      intRepresentation = (int32)_getLong_ByteDataAccessJc(ythis, ythis->idxCurrentChild - ythis->idxBegin, 4, _thCxt);
      { STACKTRC_LEAVE;
        return intBitsToFloat_FloatJc(/*static*/intRepresentation);
      }
    }
    else { throw_s0Jc(ident_RuntimeExceptionJc, "Not available in expand mode.", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 double value without a child instance, but returns the value as integer.*/
double getChildDouble_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildDouble_ByteDataAccessJc");
  
  { //:NOTE: there is no instance for this child, but it is the current child anyway.
    
    
    setIdxtoNextCurrentChild_ByteDataAccessJc(ythis, _thCxt);
    if(!setIdxCurrentChildEnd_ByteDataAccessJc(ythis, 8, _thCxt)) 
    { //:NOTE: to read from idxInChild = 0, build the difference as shown:
      
      int64 intRepresentation; 
      
      
      intRepresentation = _getLong_ByteDataAccessJc(ythis, ythis->idxCurrentChild - ythis->idxBegin, 8, _thCxt);
      { STACKTRC_LEAVE;
        return longBitsToDouble_DoubleJc(/*static*/intRepresentation);
      }
    }
    else { throw_s0Jc(ident_RuntimeExceptionJc, "Not available in expand mode.", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 integer value without a child instance, and sets the value as integer.*/
void addChildInteger_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 nrofBytes, int64 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildInteger_ByteDataAccessJc");
  
  { 
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    
    setIdxtoNextCurrentChild_ByteDataAccessJc(ythis, _thCxt);
    if(ythis->data->head.length < ythis->idxCurrentChild + nrofBytes) { throw_sJc(ident_IllegalArgumentExceptionJc, 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "data length to small:", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, (ythis->idxCurrentChild + nrofBytes), _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); };//NOTE: there is no instance for this child, but it is the current child anyway.
    //NOTE: to read from idxInChild = 0, build the difference as shown:
    
    _setLong_ByteDataAccessJc(ythis, ythis->idxCurrentChild - ythis->idxBegin, nrofBytes, value, _thCxt);
    correctIdxChildEnd_ByteDataAccessJc(ythis, ythis->idxCurrentChild + nrofBytes, _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
  }
  STACKTRC_LEAVE;
}


/**Adds a child for 1 integer value without a child instance, and sets the value as integer.*/
void addChildFloat_ByteDataAccessJc(ByteDataAccessJc_s* ythis, float value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildFloat_ByteDataAccessJc");
  
  { 
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    
    setIdxtoNextCurrentChild_ByteDataAccessJc(ythis, _thCxt);
    if(ythis->data->head.length < ythis->idxCurrentChild + 4) { throw_sJc(ident_IllegalArgumentExceptionJc, 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "data length to small:", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, (ythis->idxCurrentChild + 4), _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); };//NOTE: there is no instance for this child, but it is the current child anyway.
    //NOTE: to read from idxInChild = 0, build the difference as shown:
    
    setFloat_if_ByteDataAccessJc(ythis, ythis->idxCurrentChild - ythis->idxBegin, value, _thCxt);
    correctIdxChildEnd_ByteDataAccessJc(ythis, ythis->idxCurrentChild + 4, _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
  }
  STACKTRC_LEAVE;
}


/**Adds a child for a String value without a child instance, but returns the value as String.*/
StringJc getChildString_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChildString_ByteDataAccessJc");
  
  { //:NOTE: there is no instance for this child, but it is the current child anyway.
    
    
    setIdxtoNextCurrentChild_ByteDataAccessJc(ythis, _thCxt);
    if(!setIdxCurrentChildEnd_ByteDataAccessJc(ythis, nrofBytes, _thCxt)) 
    { //:NOTE: to read from idxInChild = 0, build the difference as shown:
      
      
      { STACKTRC_LEAVE;
        return _getString_ByteDataAccessJc(ythis, ythis->idxCurrentChild - ythis->idxBegin, nrofBytes, _thCxt);
      }
    }
    else { throw_s0Jc(ident_RuntimeExceptionJc, "Not available in expand mode.  ", 0, &_thCxt->stacktraceThreadContext, __LINE__); return null_StringJc; };
  }
  STACKTRC_LEAVE;
}


/**Adds a child with String value.*/
void addChildString_SSb_ByteDataAccessJc(ByteDataAccessJc_s* ythis, StringJc value, StringJc sEncoding, bool preventCtrlChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildString_SSb_ByteDataAccessJc");
  
  { 
    int32 nrofBytes; 
    
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    
    setIdxtoNextCurrentChild_ByteDataAccessJc(ythis, _thCxt);
    nrofBytes = length_StringJc(value);
    if(ythis->data->head.length < ythis->idxCurrentChild + nrofBytes) { throw_sJc(ident_IllegalArgumentExceptionJc, 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "data length to small:", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, (ythis->idxCurrentChild + nrofBytes), _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); };//NOTE: there is no instance for this child, but it is the current child anyway.
    //NOTE: to read from idxInChild = 0, build the difference as shown:
    
    _setString_ByteDataAccessJc(ythis, ythis->idxCurrentChild - ythis->idxBegin, nrofBytes, value, sEncoding, preventCtrlChars, _thCxt);
    correctIdxChildEnd_ByteDataAccessJc(ythis, ythis->idxCurrentChild + nrofBytes, _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
  }
  STACKTRC_LEAVE;
}


/**Adds a child with String value.*/
void addChildString_S_ByteDataAccessJc(ByteDataAccessJc_s* ythis, StringJc value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildString_S_ByteDataAccessJc");
  
  { 
    
    TRY
    { 
      
      addChildString_tS_ByteDataAccessJc(ythis, value, null_StringJc, _thCxt);
    }_TRY
    CATCH(UnsupportedEncodingException, exc)
    
      { 
        
        { throw_EJc(ident_RuntimeExceptionJc, exc, 0, &_thCxt->stacktraceThreadContext, __LINE__); };
      }
    END_TRY//it isn't able.
    
  }
  STACKTRC_LEAVE;
}


/**Adds a child with String value.*/
void addChildString_tS_ByteDataAccessJc(ByteDataAccessJc_s* ythis, StringJc value, StringJc sEncoding, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildString_tS_ByteDataAccessJc");
  
  { 
    int32 nrofBytes; 
    
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    
    setIdxtoNextCurrentChild_ByteDataAccessJc(ythis, _thCxt);
    nrofBytes = length_StringJc(value);
    if(ythis->data->head.length < ythis->idxCurrentChild + nrofBytes) { throw_sJc(ident_IllegalArgumentExceptionJc, 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "data length to small:", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, (ythis->idxCurrentChild + nrofBytes), _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); };//NOTE: there is no instance for this child, but it is the current child anyway.
    //NOTE: to read from idxInChild = 0, build the difference as shown:
    
    { int32 ii; 
      for(ii = 0; ii < nrofBytes; ++ii)
        { 
          int8 charByte; 
          
          
          charByte = (int8)(charAt_StringJc(value, ii));
          ythis->data->data[ythis->idxCurrentChild + ii] = charByte;
        }
    }
    correctIdxChildEnd_ByteDataAccessJc(ythis, ythis->idxCurrentChild + nrofBytes, _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
  }
  STACKTRC_LEAVE;
}


/**Adds a child with String value.*/
void addChildString_t_ByteDataAccessJc(ByteDataAccessJc_s* ythis, StringJc value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addChildString_t_ByteDataAccessJc");
  
  { 
    
    TRY
    { 
      
      addChildString_tS_ByteDataAccessJc(ythis, value, null_StringJc, _thCxt);
    }_TRY
    CATCH(UnsupportedEncodingException, exc)
    
      { 
        
        { throw_EJc(ident_RuntimeExceptionJc, exc, 0, &_thCxt->stacktraceThreadContext, __LINE__); };
      }
    END_TRY//it isn't able.
    
  }
  STACKTRC_LEAVE;
}


/**Writes a String into data with given color.*/
int32 addText_ByteDataAccessJc(ByteDataAccessJc_s* ythis, StringJc ss, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addText_ByteDataAccessJc");
  
  { 
    
    if(REFJc(ythis->parent) != null || ythis->idxBegin == 0) 
    { 
      ByteStringJc chars;   /**/
      int32 srcLen; 
      int32 dataLen; 
      
      
      chars = getBytes_StringJc(ss, _thCxt);
      srcLen = length_ByteStringJc(chars);
      dataLen = ythis->data->head.length;
      { int32 ii; 
        for(ii = 0; ii < srcLen; ii++)
          { 
            int8 cc; 
            
            
            cc = ((/*J2C:cast% from ByteStringJc*/int8)(data_ByteStringJc(chars)[ii]));
            if(cc < 0x20) cc = ((/*J2C:cast% from int32*/int8)(0x3f));//'?' in ASCII
            
            if(ythis->idxEnd >= dataLen) { throw_s0Jc(ident_IllegalArgumentExceptionJc, "element to long", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
            ythis->data->data[ythis->idxEnd++] = cc;
          }
      }
      expandParent_ByteDataAccessJc(ythis, _thCxt);
      { STACKTRC_LEAVE;
        return (ythis->idxEnd - ythis->idxBegin);
      }//current nr of bytes
      
    }
    else { throw_s0Jc(ident_IllegalArgumentExceptionJc, "inadmissable add-operation", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
  }
  STACKTRC_LEAVE;
}


/**starts the calling loop of next().*/
void rewind_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("rewind_ByteDataAccessJc");
  
  { 
    
    ythis->idxCurrentChild = -1;
  }
  STACKTRC_LEAVE;
}


/**Sets the data index to the position after the current child element and returns its code.<br>*/
int32 next_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("next_ByteDataAccessJc");
  
  { 
    int8 eWhat = 0; 
    
    
    /*no initvalue*/
    setIdxtoNextCurrentChild_ByteDataAccessJc(ythis, _thCxt);
    ythis->idxCurrentChildEnd = -2;//the child content is not known, this index will be set if setLengthCurrentChildElement() is called.
    
    if(ythis->idxCurrentChild >= ythis->idxEnd) 
    { 
      
      eWhat = kEndOfElements_ByteDataAccessJc;//no more data
      
    }
    else 
    { 
      
      eWhat = ythis->data->data[ythis->idxCurrentChild];
      if(isTextByte_ByteDataAccessJc(ythis, eWhat, _thCxt)) 
      { 
        
        eWhat = kText_ByteDataAccessJc;
      }
    }
    { STACKTRC_LEAVE;
      return eWhat;
    }
  }
  STACKTRC_LEAVE;
}


/**returns true if the given number of bytes is sufficing in the data from position of next child.*/
bool sufficingBytesForNextChild_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("sufficingBytesForNextChild_ByteDataAccessJc");
  
  { 
    int32 maxNrofBytesChild; 
    
    
    maxNrofBytesChild = getMaxNrofBytesForNextChild_ByteDataAccessJc(ythis, _thCxt);
    { STACKTRC_LEAVE;
      return nrofBytes < 0 ? false : maxNrofBytesChild >= nrofBytes;
    }
  }
  STACKTRC_LEAVE;
}


/**returns the number number of bytes there are max available from position of a next current child.*/
int32 getMaxNrofBytesForNextChild_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getMaxNrofBytesForNextChild_ByteDataAccessJc");
  
  { //:if(idxCurrentChild == -1)
    
    
    
    { }
    if(ythis->idxCurrentChildEnd < ythis->idxCurrentChild) { throw_s0Jc(ident_IllegalArgumentExceptionJc, "length of current child is undefined.", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      return ythis->idxEnd - ythis->idxCurrentChildEnd;
    }
  }
  STACKTRC_LEAVE;
}


/**returns the number number of bytes there are max available from position of the current child.*/
int32 getMaxNrofBytes_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getMaxNrofBytes_ByteDataAccessJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return ythis->data->head.length - ythis->idxBegin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the length of the existing actual element.*/
int32 getLength_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLength_ByteDataAccessJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return ythis->idxEnd - ythis->idxBegin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the length of the data.*/
int32 getLengthTotal_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getLengthTotal_ByteDataAccessJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return ythis->idxEnd;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the data buffer itself*/
int8_Y* getData_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getData_ByteDataAccessJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return ythis->data;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the Element data in the assigned buffer.*/
int32 getPositionInBuffer_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getPositionInBuffer_ByteDataAccessJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return ythis->idxBegin;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the position of the current child in the assigned buffer.*/
int32 getPositionNextChildInBuffer_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getPositionNextChildInBuffer_ByteDataAccessJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return ythis->idxCurrentChildEnd;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the length of the current child element.*/
int32 getLengthCurrentChildElement_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtthis = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  
  STACKTRC_TENTRY("getLengthCurrentChildElement_ByteDataAccessJc");
  
  { 
    
    if(ythis->idxCurrentChildEnd > ythis->idxCurrentChild) 
    { //:a get method, especially getText() was called,
      //:so the end of the child is known yet, use it!
      
      
      { STACKTRC_LEAVE;
        return ythis->idxCurrentChildEnd - ythis->idxCurrentChild;
      }
    }
    else 
    { //:only the user can define the length.
      
      
      { STACKTRC_LEAVE;
        return mtthis->specifyLengthCurrentChildElement(ythis, _thCxt);
      }
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current child element after calling next().*/
void setLengthCurrentChildElement_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 lengthOfCurrentChild, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setLengthCurrentChildElement_ByteDataAccessJc");
  
  { 
    
    if(REFJc(ythis->currentChild) != null) 
    { 
      
      setLengthElement_ByteDataAccessJc(REFJc(ythis->currentChild), lengthOfCurrentChild, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Sets the length of the current element, considering all children.*/
void setLengthElement_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 length, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setLengthElement_ByteDataAccessJc");
  
  { //:if(!bExpand && )
    
    
    correctIdxChildEnd_ByteDataAccessJc(ythis, ythis->idxBegin + length, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Returns true if the current child element represents a TEXT(), direct ASCII chars,*/
bool isTextByte_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int8 nn, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("isTextByte_ByteDataAccessJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return (nn >= 0x20);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the current string or null on end*/
StringJc getText_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getText_ByteDataAccessJc");
  
  { 
    
    if(ythis->idxCurrentChild >= ythis->idxEnd) { STACKTRC_LEAVE;
      return null_StringJc;
    }
    else 
    { 
      int8 nn; 
      
      
      nn = ythis->data->data[ythis->idxCurrentChild];
      if(isTextByte_ByteDataAccessJc(ythis, nn, _thCxt)) 
      { 
        char cc = '?'; 
        struct StringBuilderJc_t* ss = null; 
        
        ObjectJc *newObj3_1=null; //J2C: temporary Objects for new operations
        
        ythis->idxCurrentChildEnd = ythis->idxCurrentChild;
        cc = '?';
        
        ss = ctorO_I_StringBuilderJc(/*static*/(newObj3_1 = alloc_ObjectJc(sizeof_StringBuilderJc, 0, _thCxt)), 20, _thCxt);
        
        while(ythis->idxCurrentChildEnd < ythis->idxEnd && isTextByte_ByteDataAccessJc(ythis, nn = /*? assignment*/ythis->data->data[ythis->idxCurrentChildEnd], _thCxt))
          { 
            
            if(nn < 0) cc = '?';//{ cc=convertHiChars(nn);}  //range between 0x80..0xbf
            
            else cc = (char)(nn);//convert 0x20...7F to character
            
            append_C_StringBuilderJc(ss, cc, _thCxt);//konvert to Unicode
            
            ythis->idxCurrentChildEnd += 1;
          }
        { STACKTRC_LEAVE;
          activateGarbageCollectorAccess_BlockHeapJc(newObj3_1, PTR_StringJc(toString_StringBuilderJc(& ((* (ss)).base.object), _thCxt)));
          return toString_StringBuilderJc(& ((* (ss)).base.object), _thCxt);
        }
      }
      else { STACKTRC_LEAVE;
        return null_StringJc;
      }//no Text
      
    }
  }
  STACKTRC_LEAVE;
}


/**Returns a String from the given position inside the actual element .*/
StringJc getString_ByteDataAccessJc_F(ByteDataAccessJc_s* ythis, int32 idx, int32 nmax, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getString_ByteDataAccessJc_F");
  
  { 
    StringJc sRet = NULL_StringJc; 
    int32 pos0; 
    
    
    /*no initvalue*/
    TRY
    { 
      
      sRet = new_BYIICharset_StringJc(/*static*/ythis->data, ythis->idxBegin + idx, nmax, s0_StringJc("ISO-8859-1"), _thCxt)/*J2C:non-persistent*/;
    }_TRY
    CATCH(UnsupportedEncodingException, e)
    
      { 
        
        sRet = null_StringJc/*J2C:non-persistent*/;
      }
    END_TRY
    pos0 = indexOf_C_StringJc(sRet, ((char)(0)));
    if(pos0 > 0) 
    { //:The data are zero terminated!
      
      
      sRet = substring_StringJc(sRet, 0, pos0, _thCxt)/*J2C:non-persistent*/;
    }
    { STACKTRC_LEAVE;
      return sRet;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc getString_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, int32 nmax, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  return mtbl->getString(ythis, idx, nmax, _thCxt);
}


/**Sets a String to the the given position inside the actual element .*/
int32 setString_ByteDataAccessJc_F(ByteDataAccessJc_s* ythis, int32 idx, int32 nmax, StringJc ss, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setString_ByteDataAccessJc_F");
  
  { 
    ByteStringJc byteRepresentation;   /*Use a */
    int32 len; 
    
    
    if(length_StringJc(ss) > nmax) 
    { 
      
      ss = substring_StringJc(ss, 0, nmax, _thCxt)/*J2C:non-persistent*/;
    }//truncate.
    
    /*no initvalue*/
    TRY
    { 
      
      byteRepresentation = getBytesEncoding_StringJc(ss, s0_StringJc("ISO-8859-1"), _thCxt);
    }_TRY
    CATCH(UnsupportedEncodingException, e)
    
      { 
        
        byteRepresentation = null_OS_PtrValue;
      }
    END_TRY
    len = length_ByteStringJc(byteRepresentation);
    if(len > nmax) 
    { 
      
      len = nmax;
    }//truncate.
    
    arraycopy_v_SystemJc(/*static*/byteRepresentation, 0, & ((ythis->data)->head.object), ythis->idxBegin + idx, len, _thCxt);
    { STACKTRC_LEAVE;
      return len;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 setString_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, int32 nmax, StringJc ss, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  return mtbl->setString(ythis, idx, nmax, ss, _thCxt);
}


/**Sets the big or little endian mode.*/
void setBigEndian_ByteDataAccessJc_F(ByteDataAccessJc_s* ythis, bool val, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setBigEndian_ByteDataAccessJc_F");
  
  { 
    
    ythis->bBigEndian = val;
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void setBigEndian_ByteDataAccessJc(ByteDataAccessJc_s* ythis, bool val, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  mtbl->setBigEndian(ythis, val, _thCxt);
}


/**Returns the content of 1 to 8 bytes inside the actual element as a long number,*/
int64 _getLong_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idxInChild, int32 nrofBytesAndSign, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_getLong_ByteDataAccessJc");
  
  { 
    int64 val = 0; 
    int32 idxStep = 0; 
    int32 idx = 0; 
    int32 nrofBytes = 0; 
    bool bSigned = 0; 
    int32 nByteCnt; 
    
    
    val = 0;
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    /*no initvalue*/
    if(nrofBytesAndSign >= 0) 
    { 
      
      nrofBytes = nrofBytesAndSign;
      bSigned = false;
    }
    else 
    { 
      
      nrofBytes = -nrofBytesAndSign;
      bSigned = true;
    }
    if(ythis->bBigEndian) 
    { 
      
      idx = ythis->idxBegin + idxInChild;
      idxStep = 1;
    }
    else 
    { 
      
      idx = ythis->idxBegin + idxInChild + nrofBytes - 1;
      idxStep = -1;
    }
    nByteCnt = nrofBytes;
    do 
      { 
        
        val |= ythis->data->data[idx] & 0xff;
        if(--nByteCnt <= 0) break;//TRICKY: break in mid of loop, no shift operation.
        
        val <<= 8;
        idx += idxStep;
      }while(true);//see break;
    
    if(bSigned) 
    { 
      int32 posSign; 
      int64 maskSign = 1; 
      
      
      posSign = (nrofBytes * 8) - 1;
      maskSign = 1 << posSign;
      if((val & maskSign) != 0) 
      { 
        int64 bitsSign = 0xffffffffffffffff; 
        
        
        bitsSign = 0xffffffffffffffff << (posSign);
        val |= bitsSign;//supplement the rest bits of long with the sign value,it's negativ.
        
      }
    }
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**sets the content of 1 to 8 bytes inside the actual element as a long number,*/
void _setLong_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, int32 nrofBytes, int64 val, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_setLong_ByteDataAccessJc");
  
  { 
    int32 idxStep = 0; 
    
    
    /*no initvalue*/
    if(ythis->bBigEndian) 
    { 
      
      idx = ythis->idxBegin + idx + nrofBytes - 1;
      idxStep = -1;
    }
    else 
    { 
      
      idx = ythis->idxBegin + idx;
      idxStep = 1;
    }
    do 
      { 
        
        ythis->data->data[idx] = (int8)(val);
        if(--nrofBytes <= 0) break;
        val >>= 8;
        idx += idxStep;
      }while(true);//see break;
    
  }
  STACKTRC_LEAVE;
}


/**sets the content inside the acutal element with the character bytes from the given String.*/
StringJc _getString_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, int32 nrofBytes, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_getString_ByteDataAccessJc");
  
  { 
    int32 idxData; 
    StringJc value = NULL_StringJc; 
    int32 end; 
    
    
    idxData = idx + ythis->idxBegin;
    
    value = new_BYIICharset_StringJc(/*static*/ythis->data, idxData, nrofBytes, ythis->charset, _thCxt);
    end = indexOf_C_StringJc(value, ((char)(0)));
    if(end >= 0) 
    { 
      
      value = substring_StringJc(value, 0, end, _thCxt)/*J2C:non-persistent*/;
    }
    { STACKTRC_LEAVE;
      return value;
    }
  }
  STACKTRC_LEAVE;
}


/**sets the content inside the actual element with the character bytes from the given String.*/
void _setString_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, int32 nrofBytes, StringJc value, StringJc sEncoding, bool preventCtrlChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("_setString_ByteDataAccessJc");
  
  { 
    int32 idxData; 
    int32 idxEnd; 
    ByteStringJc chars;   /**/
    int32 srcLen; 
    
    
    idxData = idx + ythis->idxBegin;
    idxEnd = idxData + nrofBytes;
    /*no initvalue*/
    if(sEncoding.ptr__== null) 
    { 
      
      sEncoding = z_StringJc("ISO-8859-1")/*J2C:non-persistent*/;
    }
    chars = getBytesEncoding_StringJc(value, sEncoding, _thCxt);
    srcLen = length_ByteStringJc(chars);
    { int32 ii; 
      for(ii = 0; ii < srcLen && ii < nrofBytes; ii++)
        { 
          int8 cc; 
          
          
          cc = ((/*J2C:cast% from ByteStringJc*/int8)(data_ByteStringJc(chars)[ii]));
          if(preventCtrlChars && cc < 0x20) 
          { 
            
            cc = ((/*J2C:cast% from int32*/int8)(0x3f));
          }//'?' in ASCII
          
          ythis->data->data[idxData++] = cc;
        }//fill up the rest of the string with 0-chars.
        
    }
    
    while(idxData < idxEnd)
      { 
        
        ythis->data->data[idxData++] = 0;
      }
  }
  STACKTRC_LEAVE;
}


/**copies some data to a int[], primarily to debug a content.*/
void copyData_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32_Y* dst, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("copyData_ByteDataAccessJc");
  
  { 
    int32 idxMax; 
    int32 iDst = 0; 
    
    
    idxMax = ythis->idxEnd - ythis->idxBegin;
    if(idxMax / 4 > dst->head.length) idxMax = 4 * dst->head.length;
    iDst = 0;
    { int32 idx; 
      for(idx = 0; idx < idxMax; idx += 4)
        { 
          
          dst->data[iDst++] = (int32)_getLong_ByteDataAccessJc(ythis, idx, 4, _thCxt);
        }
    }
  }
  STACKTRC_LEAVE;
}


/**Gets a float value from the content of 4 byte*/
float getFloat_i_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getFloat_i_ByteDataAccessJc");
  
  { 
    int32 intRepresentation; 
    
    
    intRepresentation = getInt32_i_ByteDataAccessJc(ythis, idx, _thCxt);
    { STACKTRC_LEAVE;
      return intBitsToFloat_FloatJc(/*static*/intRepresentation);
    }
  }
  STACKTRC_LEAVE;
}

double getDouble_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getDouble_ByteDataAccessJc");
  
  { 
    int64 intRepresentation; 
    
    
    intRepresentation = _getLong_ByteDataAccessJc(ythis, idx, 8, _thCxt);
    { STACKTRC_LEAVE;
      return longBitsToDouble_DoubleJc(/*static*/intRepresentation);
    }
  }
  STACKTRC_LEAVE;
}

int64 getInt64_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt64_ByteDataAccessJc");
  
  { 
    int32 nLo = 0; 
    int32 nHi = 0; 
    int64 val; 
    
    
    /*no initvalue*/
    /*no initvalue*/
    if(ythis->bBigEndian) 
    { 
      
      nLo = getInt32_i_ByteDataAccessJc(ythis, idx, _thCxt);
      nHi = getInt32_i_ByteDataAccessJc(ythis, idx + 4, _thCxt);
    }
    else 
    { 
      
      nLo = getInt32_i_ByteDataAccessJc(ythis, idx + 4, _thCxt);
      nHi = getInt32_i_ByteDataAccessJc(ythis, idx, _thCxt);
    }
    val = nHi << 32;
    val |= nLo & 0xffffffff;
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 4 bytes inside the actual element as a integer number between -2147483648 and 2147483647,*/
int32 getInt32_i_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt32_i_ByteDataAccessJc");
  
  { 
    int32 val = 0; 
    
    
    /*no initvalue*/
    if(ythis->bBigEndian) 
    { 
      
      val = (((int32)ythis->data->data[ythis->idxBegin + idx]) << 24) | ((((int32)ythis->data->data[ythis->idxBegin + idx + 1]) << 16) & 0xff0000) | ((((int32)ythis->data->data[ythis->idxBegin + idx + 2]) << 8) & 0xff00) | ((((int32)ythis->data->data[ythis->idxBegin + idx + 3])) & 0xff);//NOTE: the value has only 8 bits for bitwise or.
      
    }
    else 
    { 
      
      val = (((int32)ythis->data->data[ythis->idxBegin + idx + 3]) << 24) | ((((int32)ythis->data->data[ythis->idxBegin + idx + 2]) << 16) & 0xff0000) | ((((int32)ythis->data->data[ythis->idxBegin + idx + 1]) << 8) & 0xff00) | ((((int32)ythis->data->data[ythis->idxBegin + idx])) & 0xff);//NOTE: the value has only 8 bits for bitwise or.
      
    }
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}

int32 getUint32_i_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint32_i_ByteDataAccessJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return getInt32_i_ByteDataAccessJc(ythis, idx, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 2 bytes as a positive nr between 0..65535, big-endian*/
int32 getUint16_i_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint16_i_ByteDataAccessJc");
  
  { 
    int32 val = 0; 
    
    
    /*no initvalue*/
    if(ythis->bBigEndian) 
    { 
      
      val = ((((int32)ythis->data->data[ythis->idxBegin + idx]) << 8) & 0xff00) | ((((int32)ythis->data->data[ythis->idxBegin + idx + 1])) & 0xff);//NOTE: the value has only 8 bits for bitwise or.
      
    }
    else 
    { 
      
      val = ((((int32)ythis->data->data[ythis->idxBegin + idx + 1]) << 8) & 0xff00) | ((((int32)ythis->data->data[ythis->idxBegin + idx])) & 0xff);//NOTE: the value has only 8 bits for bitwise or.
      
    }
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 2 bytes as a positive nr between 0..65535 inside the actual element.*/
int16 getInt16_i_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt16_i_ByteDataAccessJc");
  
  { 
    int32 val = 0; 
    
    
    /*no initvalue*/
    if(ythis->bBigEndian) 
    { 
      
      val = ((((int16)ythis->data->data[ythis->idxBegin + idx]) << 8) & 0xff00) | ((((int16)ythis->data->data[ythis->idxBegin + idx + 1])) & 0xff);//NOTE: the value has only 8 bits for bitwise or.
      
    }
    else 
    { 
      
      val = ((((int16)ythis->data->data[ythis->idxBegin + idx + 1]) << 8) & 0xff00) | ((((int16)ythis->data->data[ythis->idxBegin + idx])) & 0xff);//NOTE: the value has only 8 bits for bitwise or.
      
    }
    { STACKTRC_LEAVE;
      return (int16)val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 1 bytes as ASCII*/
char getChar_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getChar_ByteDataAccessJc");
  
  { 
    char val = 0; 
    
    
    /*no initvalue*/
    val = (char)ythis->data->data[ythis->idxBegin + idx];
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 1 bytes as a positive or negative nr between -128..127*/
int8 getInt8_i_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt8_i_ByteDataAccessJc");
  
  { 
    int8 val = 0; 
    
    
    /*no initvalue*/
    val = ythis->data->data[ythis->idxBegin + idx];
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}


/**Returns the content of 1 bytes as a positive or negative nr between -128..127*/
int32 getUint8_i_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint8_i_ByteDataAccessJc");
  
  { 
    int32 val = 0; 
    
    
    /*no initvalue*/
    val = ythis->data->data[ythis->idxBegin + idx] & 0xff;
    { STACKTRC_LEAVE;
      return val;
    }
  }
  STACKTRC_LEAVE;
}

int32 getUint32_iii_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint32_iii_ByteDataAccessJc");
  
  { 
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "getUint16:", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
      return getUint32_i_ByteDataAccessJc(ythis, idxBytes + 4 * idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 getInt32_iii_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt32_iii_ByteDataAccessJc");
  
  { 
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "getInt32:", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
      return getInt32_i_ByteDataAccessJc(ythis, idxBytes + 4 * idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 getInt16_iii_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt16_iii_ByteDataAccessJc");
  
  { 
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "getInt16:", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
      return getInt16_i_ByteDataAccessJc(ythis, idxBytes + 2 * idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 getInt8_iii_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getInt8_iii_ByteDataAccessJc");
  
  { 
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "getInt8:", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
      return getInt8_i_ByteDataAccessJc(ythis, idxBytes + idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

int32 getUint16_iii_ByteDataAccessJc_F(ByteDataAccessJc_s* ythis, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint16_iii_ByteDataAccessJc_F");
  
  { 
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "getUint16:", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
      return getUint16_i_ByteDataAccessJc(ythis, idxBytes + 2 * idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 getUint16_iii_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  return mtbl->getUint16_iii(ythis, idxBytes, idxArray, lengthArray, _thCxt);
}

int32 getUint8_iii_ByteDataAccessJc_F(ByteDataAccessJc_s* ythis, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getUint8_iii_ByteDataAccessJc_F");
  
  { 
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "getUint8:", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
      return getInt8_i_ByteDataAccessJc(ythis, idxBytes + idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 getUint8_iii_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  return mtbl->getUint8_iii(ythis, idxBytes, idxArray, lengthArray, _thCxt);
}

float getFloat_iii_ByteDataAccessJc_F(ByteDataAccessJc_s* ythis, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getFloat_iii_ByteDataAccessJc_F");
  
  { 
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "getFloat:", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    { STACKTRC_LEAVE;
      activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
      return getFloat_i_ByteDataAccessJc(ythis, idxBytes + 4 * idxArray, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
float getFloat_iii_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idxBytes, int32 idxArray, int32 lengthArray, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtbl = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  return mtbl->getFloat_iii(ythis, idxBytes, idxArray, lengthArray, _thCxt);
}


/**Set the content of 4 byte from a float variable*/
void setFloat_if_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, float value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setFloat_if_ByteDataAccessJc");
  
  { 
    int32 intRepresentation; 
    
    
    intRepresentation = floatToRawIntBits_FloatJc(/*static*/value);
    setInt32_ii_ByteDataAccessJc(ythis, idx, intRepresentation, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Set the content of 8 byte from a double variable*/
void setDouble_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, double value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setDouble_ByteDataAccessJc");
  
  { 
    int64 intRepresentation; 
    
    
    intRepresentation = doubleToRawLongBits_DoubleJc(/*static*/value);
    _setLong_ByteDataAccessJc(ythis, idx, 8, intRepresentation, _thCxt);
  }
  STACKTRC_LEAVE;
}


/**Set the content of 4 bytes as a integer number between -2147483648 and 2147483647,*/
void setInt32_ii_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, int32 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setInt32_ii_ByteDataAccessJc");
  
  { 
    
    if(ythis->bBigEndian) 
    { 
      
      ythis->data->data[ythis->idxBegin + idx] = (int8)((value >> 24) & 0xff);
      ythis->data->data[ythis->idxBegin + idx + 1] = (int8)((value >> 16) & 0xff);
      ythis->data->data[ythis->idxBegin + idx + 2] = (int8)((value >> 8) & 0xff);
      ythis->data->data[ythis->idxBegin + idx + 3] = (int8)(value & 0xff);
    }
    else 
    { 
      
      ythis->data->data[ythis->idxBegin + idx + 3] = (int8)((value >> 24) & 0xff);
      ythis->data->data[ythis->idxBegin + idx + 2] = (int8)((value >> 16) & 0xff);
      ythis->data->data[ythis->idxBegin + idx + 1] = (int8)((value >> 8) & 0xff);
      ythis->data->data[ythis->idxBegin + idx] = (int8)(value & 0xff);
    }
  }
  STACKTRC_LEAVE;
}


/**Set the content of 1 bytes as a positive nr between 0..255, big- or little-endian.*/
void setUint8_ii_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, int32 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setUint8_ii_ByteDataAccessJc");
  
  { 
    
    setInt8_ii_ByteDataAccessJc(ythis, idx, value, _thCxt);//its the same because modulo!
    
  }
  STACKTRC_LEAVE;
}


/**Set the content of 2 bytes as a positive nr between 0..65535, big- or little-endian.*/
void setUint16_ii_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, int32 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setUint16_ii_ByteDataAccessJc");
  
  { 
    
    setInt16_ii_ByteDataAccessJc(ythis, idx, value, _thCxt);//its the same because modulo!
    
  }
  STACKTRC_LEAVE;
}


/**Set the content of 4 bytes as a positive nr between 0..2pow32-1, big- or little-endian.*/
void setUint32_il_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, int64 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setUint32_il_ByteDataAccessJc");
  
  { //:the same algorithm in source, but other action on machine level,
    //:because value is long!
    
    
    if(ythis->bBigEndian) 
    { 
      
      ythis->data->data[ythis->idxBegin + idx] = (int8)((value >> 24) & 0xff);
      ythis->data->data[ythis->idxBegin + idx + 1] = (int8)((value >> 16) & 0xff);
      ythis->data->data[ythis->idxBegin + idx + 2] = (int8)((value >> 8) & 0xff);
      ythis->data->data[ythis->idxBegin + idx + 3] = (int8)(value & 0xff);
    }
    else 
    { 
      
      ythis->data->data[ythis->idxBegin + idx + 3] = (int8)((value >> 24) & 0xff);
      ythis->data->data[ythis->idxBegin + idx + 2] = (int8)((value >> 16) & 0xff);
      ythis->data->data[ythis->idxBegin + idx + 1] = (int8)((value >> 8) & 0xff);
      ythis->data->data[ythis->idxBegin + idx] = (int8)(value & 0xff);
    }
  }
  STACKTRC_LEAVE;
}


/**Set the content of 2 bytes from an integer between -32768..32768,*/
void setInt16_ii_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, int32 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setInt16_ii_ByteDataAccessJc");
  
  { 
    
    if(ythis->bBigEndian) 
    { 
      
      ythis->data->data[ythis->idxBegin + idx] = (int8)((value >> 8) & 0xff);
      ythis->data->data[ythis->idxBegin + idx + 1] = (int8)(value & 0xff);
    }
    else 
    { 
      
      ythis->data->data[ythis->idxBegin + idx + 1] = (int8)((value >> 8) & 0xff);
      ythis->data->data[ythis->idxBegin + idx] = (int8)(value & 0xff);
    }
  }
  STACKTRC_LEAVE;
}


/**Set the content of 1 bytes as a positive nr between 0..256.*/
void setInt8_ii_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idx, int32 value, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setInt8_ii_ByteDataAccessJc");
  
  { 
    
    ythis->data->data[ythis->idxBegin + idx] = (int8)(value & 0xff);
  }
  STACKTRC_LEAVE;
}

void setUint32_iiii_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idxBytes, int32 idxArray, int32 lengthArray, int32 val, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setUint32_iiii_ByteDataAccessJc");
  
  { 
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "setUint32:", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    setUint32_il_ByteDataAccessJc(ythis, idxBytes + 4 * idxArray, val, _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
  }
  STACKTRC_LEAVE;
}

void setInt32_iiii_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idxBytes, int32 idxArray, int32 lengthArray, int32 val, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setInt32_iiii_ByteDataAccessJc");
  
  { 
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "setInt32:", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    setInt32_ii_ByteDataAccessJc(ythis, idxBytes + 4 * idxArray, val, _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
  }
  STACKTRC_LEAVE;
}

void setInt16_iiii_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idxBytes, int32 idxArray, int32 lengthArray, int32 val, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setInt16_iiii_ByteDataAccessJc");
  
  { 
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "getInt16:", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    setInt16_ii_ByteDataAccessJc(ythis, idxBytes + 2 * idxArray, val, _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
  }
  STACKTRC_LEAVE;
}

void setInt8_iiii_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idxBytes, int32 idxArray, int32 lengthArray, int32 val, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setInt8_iiii_ByteDataAccessJc");
  
  { 
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "getInt16:", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    setInt8_ii_ByteDataAccessJc(ythis, idxBytes + idxArray, val, _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
  }
  STACKTRC_LEAVE;
}

void setUint16_iiii_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idxBytes, int32 idxArray, int32 lengthArray, int32 val, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setUint16_iiii_ByteDataAccessJc");
  
  { 
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "getInt16:", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    setUint16_ii_ByteDataAccessJc(ythis, idxBytes + 2 * idxArray, val, _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
  }
  STACKTRC_LEAVE;
}

void setUint8_iiii_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idxBytes, int32 idxArray, int32 lengthArray, int32 val, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setUint8_iiii_ByteDataAccessJc");
  
  { 
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "getInt16:", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    setUint8_ii_ByteDataAccessJc(ythis, idxBytes + idxArray, val, _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
  }
  STACKTRC_LEAVE;
}

void setFloat_iiif_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 idxBytes, int32 idxArray, int32 lengthArray, float val, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setFloat_iiif_ByteDataAccessJc");
  
  { 
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    
    if(idxArray >= lengthArray || idxArray < 0) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "getInt16:", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, idxArray, _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    setFloat_if_ByteDataAccessJc(ythis, idxBytes + 4 * idxArray, val, _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
  }
  STACKTRC_LEAVE;
}


/**Copies the data into a byte[]*/
void copyDataFrom_ByteDataAccessJc(ByteDataAccessJc_s* ythis, struct ByteDataAccessJc_t* src, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("copyDataFrom_ByteDataAccessJc");
  
  { 
    int32 len; 
    
     //J2C: temporary Stringbuffer for String concatenation
    StringBuilderJc* _tempString1_1=null; 
    
    len = getLength_ByteDataAccessJc(src, _thCxt);
    if(ythis->data->head.length < len) { throw_sJc(ident_IndexOutOfBoundsExceptionJc, 
      ( _tempString1_1 = new_StringBuilderJc(-1, _thCxt)
      , setStringConcatBuffer_StringBuilderJc(_tempString1_1)
      , append_z_StringBuilderJc(_tempString1_1, "copy, dst to small", _thCxt)
      , append_I_StringBuilderJc(_tempString1_1, len, _thCxt)
      , toString_StringBuilderJc(&(_tempString1_1)->base.object, _thCxt)
      ), 0, &_thCxt->stacktraceThreadContext, __LINE__); };
    arraycopy_SystemJc(/*static*/& ((src->data)->head.object), src->idxBegin, & ((ythis->data)->head.object), ythis->idxBegin, len, _thCxt);
    activateGarbageCollectorAccess_BlockHeapJc(&_tempString1_1->base.object, null);
  }
  STACKTRC_LEAVE;
}


/**Counts the idxChild by given index, idxChild is ByteCount from idxBegin*/
void elementAt_ByteDataAccessJc(ByteDataAccessJc_s* ythis, int32 indexObjectArray, ThCxt* _thCxt)
{ Mtbl_ByteDataAccessJc const* mtthis = (Mtbl_ByteDataAccessJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_ByteDataAccessJc);
  
  STACKTRC_TENTRY("elementAt_ByteDataAccessJc");
  
  { 
    
    TRY
    { 
      
      ythis->idxCurrentChild = ythis->idxBegin + mtthis->specifyLengthElementHead(ythis, _thCxt) + mtthis->specifyLengthCurrentChildElement(ythis, _thCxt) * indexObjectArray;
    }_TRY
    CATCH(IllegalArgumentException, e)
    
      { 
        
        printStackTrace_ExceptionJc(e, _thCxt);
      }
    END_TRY
  }
  STACKTRC_LEAVE;
}

struct ByteDataAccessJc_t* getCurrentChild_ByteDataAccessJc(ByteDataAccessJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getCurrentChild_ByteDataAccessJc");
  
  { 
    
    { STACKTRC_LEAVE;
      return REFJc(ythis->currentChild);
    }
  }
  STACKTRC_LEAVE;
}


void finalize_ByteDataAccessJc_F(ObjectJc* othis, ThCxt* _thCxt)
{ ByteDataAccessJc_s* ythis = (ByteDataAccessJc_s*)othis;  //upcasting to the real class.
 STACKTRC_TENTRY("finalize_ByteDataAccessJc_F");
  CLEAR_REFJc(ythis->parent);
  CLEAR_REFJc(ythis->currentChild);
  finalize_ObjectJc_F(&ythis->base.object, _thCxt); //J2C: finalizing the superclass.
  STACKTRC_LEAVE;
}


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_ByteDataAccessJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_ByteDataAccessJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, 0 /*J2C: no Mtbl*/ }
   }
 };

extern struct ClassJc_t const reflection_ByteDataAccessJc_s;
extern struct ClassJc_t const reflection_ByteDataAccessJc_s;
extern struct ClassJc_t const reflection_StringJc;
const struct Reflection_Fields_ByteDataAccessJc_s_t
{ ObjectArrayJc head; FieldJc data[12];
} reflection_Fields_ByteDataAccessJc_s =
{ CONST_ObjectArrayJc(FieldJc, 12, OBJTYPE_FieldJc, null, &reflection_Fields_ByteDataAccessJc_s)
, {
     { "data"
    , 0 //nrofArrayElements
    , REFLECTION_int8
    , 1 << kBitPrimitiv_Modifier_reflectJc |kObjectArrayJc_Modifier_reflectJc |kReferencedContainer_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->data) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "idxBegin"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->idxBegin) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "idxEnd"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->idxEnd) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "bExpand"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->bExpand) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "idxFirstChild"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->idxFirstChild) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "idxCurrentChild"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->idxCurrentChild) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "idxCurrentChildEnd"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->idxCurrentChildEnd) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "bBigEndian"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->bBigEndian) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "parent"
    , 0 //nrofArrayElements
    , &reflection_ByteDataAccessJc_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->parent) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "currentChild"
    , 0 //nrofArrayElements
    , &reflection_ByteDataAccessJc_s
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->currentChild) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "charset"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ //bitModifiers
    , (int16)((int32)(&((ByteDataAccessJc_s*)(0x1000))->charset) - (int32)(ByteDataAccessJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_ByteDataAccessJc_s
    }
   , { "kNothing"
    , 0 //nrofArrayElements
    , REFLECTION_int8
    , 1 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&kNothing_ByteDataAccessJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&kNothing_ByteDataAccessJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_ByteDataAccessJc_s
    }
} };
const ClassJc reflection_ByteDataAccessJc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "ByteDataAccessJc_s"
,  0 //position of ObjectJc
, sizeof(ByteDataAccessJc_s)
, (FieldJcArray const*)&reflection_Fields_ByteDataAccessJc_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_ByteDataAccessJc_s //superclass
, null //interfaces
, 0    //modifiers
};
