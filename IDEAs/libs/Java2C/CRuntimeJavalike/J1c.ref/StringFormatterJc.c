/**************************************************************************
 * This file is generated by Java2C
 **copyright***************************************************************
 *************************************************************************/
#include "J1c/StringFormatterJc.h"
#include <string.h>  //because using memset()
#include <Jc/ReflectionJc.h>   //Reflection concept 
#include <Fwc/fw_Exception.h>  //basic stacktrace concept
#include "J1c/StringPartJc.h"  //new object
#include "Jc/DateJc.h"  //reference-association: format
#include "Jc/StringJc.h"  //embedded type in class data
#include "Jc/SystemJc.h"  //reference-association: SystemJc

/**This class supports a formatted output of something in a string buffer.
In completion to the capability of java.lang.String.format() (since Java-5) and the class java.util.Formatter
this class provides<ul>
<li>a presentation of some hex formats and memory content as complete line.</li>
<li>a so named picture driven formating, see {@link setIntPicture(long, String)} or {@link setFloatPicture(long, String)}</li>
<li>the possibility of set and add content</li>
</ul>
To merge java.util.Formatter and this class you should assign the same StringBuffer to both classes.
<br>
The class contains add...-methods and knows internally a current position.
The current position can be setted with {@link pos(int)}.
In the default overwrite mode the add methods do not insert in buffer with shifting the rest to right
(like StringBuffer.insert()), but they overwrite the content at the currrent position.
The wording 'add' means, the current position is increment, so the next add()-operation adds
something behind the previous add()-operation. In the insert mode the content at pos is shifted to right.
<br>
Every {@link pos(int)}-operation is successfull. If the buffer in shorter as the required position, spaces will be filled
onto the required position. So a buffer content can also be filled first right, than left.
*/


const char sign_Mtbl_StringFormatterJc[] = "StringFormatterJc"; //to mark method tables of all implementations

typedef struct MtblDef_StringFormatterJc_t { Mtbl_StringFormatterJc mtbl; MtblHeadJc end; } MtblDef_StringFormatterJc;
 extern MtblDef_StringFormatterJc const mtblStringFormatterJc;
const int16 k2left_StringFormatterJc = 2 + mBytesInWordBigEndian_StringFormatterJc;
const int16 k4left_StringFormatterJc = 4 + mBytesInWordBigEndian_StringFormatterJc;
const int16 k6left_StringFormatterJc = 6 + mBytesInWordBigEndian_StringFormatterJc;
const int16 k8left_StringFormatterJc = 8 + mBytesInWordBigEndian_StringFormatterJc;
StringJc spaces_StringFormatterJc = CONST_z_StringJc("                                                          ");
const int64 n10a_StringFormatterJc[9] = { 1000000000, 100000000, 10000000, 1000000, 100000, 10000, 1000, 100, 10};
StringJc sNeg_StringFormatterJc = CONST_z_StringJc("+-%");

/*Constructor */
struct StringFormatterJc_t* ctorO_StringFormatterJc(ObjectJc* othis, ThCxt* _thCxt)
{ StringFormatterJc_s* ythis = (StringFormatterJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringFormatterJc");
  checkConsistence_ObjectJc(othis, sizeof(StringFormatterJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_StringFormatterJc_s, sizeof(StringFormatterJc_s));  
  //j2c: Initialize all class variables:
  {
    ythis->pos = 0;
    ythis->bInsert = false;
    ythis->cDecimalSeparator = '.';
  }
  { 
    ObjectJc *newObj1_1=null; //J2C: temporary Objects for new operations
    
    SETREFJc(ythis->buffer, ctorO_StringBuilderJc(/*static*/(newObj1_1 = alloc_ObjectJc(sizeof_StringBuilderJc, 0, _thCxt)), _thCxt), StringBuilderJc);
    activateGarbageCollectorAccess_BlockHeapJc(newObj1_1, null);
  }
  STACKTRC_LEAVE;
  return ythis;
}



/*Constructor */
struct StringFormatterJc_t* ctorO_i_StringFormatterJc(ObjectJc* othis, int32 length, ThCxt* _thCxt)
{ StringFormatterJc_s* ythis = (StringFormatterJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringFormatterJc");
  checkConsistence_ObjectJc(othis, sizeof(StringFormatterJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_StringFormatterJc_s, sizeof(StringFormatterJc_s));  
  //j2c: Initialize all class variables:
  {
    ythis->pos = 0;
    ythis->bInsert = false;
    ythis->cDecimalSeparator = '.';
  }
  { 
    ObjectJc *newObj1_1=null; //J2C: temporary Objects for new operations
    
    SETREFJc(ythis->buffer, ctorO_I_StringBuilderJc(/*static*/(newObj1_1 = alloc_ObjectJc(sizeof_StringBuilderJc, 0, _thCxt)), length, _thCxt), StringBuilderJc);
    activateGarbageCollectorAccess_BlockHeapJc(newObj1_1, null);
  }
  STACKTRC_LEAVE;
  return ythis;
}



/*Constructor */
struct StringFormatterJc_t* ctorO_S_StringFormatterJc(ObjectJc* othis, StringJc str, ThCxt* _thCxt)
{ StringFormatterJc_s* ythis = (StringFormatterJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringFormatterJc");
  checkConsistence_ObjectJc(othis, sizeof(StringFormatterJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_StringFormatterJc_s, sizeof(StringFormatterJc_s));  
  //j2c: Initialize all class variables:
  {
    ythis->pos = 0;
    ythis->bInsert = false;
    ythis->cDecimalSeparator = '.';
  }
  { 
    ObjectJc *newObj1_1=null; //J2C: temporary Objects for new operations
    
    SETREFJc(ythis->buffer, ctorO_s_StringBuilderJc(/*static*/(newObj1_1 = alloc_ObjectJc(sizeof_StringBuilderJc, 0, _thCxt)), str, _thCxt), StringBuilderJc);
    activateGarbageCollectorAccess_BlockHeapJc(newObj1_1, null);
  }
  STACKTRC_LEAVE;
  return ythis;
}



/*Constructor */
struct StringFormatterJc_t* ctorO_Sb_StringFormatterJc(ObjectJc* othis, struct StringBuilderJc_t* buffer, ThCxt* _thCxt)
{ StringFormatterJc_s* ythis = (StringFormatterJc_s*)othis;  //upcasting to the real class.
  STACKTRC_TENTRY("ctorO_StringFormatterJc");
  checkConsistence_ObjectJc(othis, sizeof(StringFormatterJc_s), null, _thCxt);  
  setReflection_ObjectJc(othis, &reflection_StringFormatterJc_s, sizeof(StringFormatterJc_s));  
  //j2c: Initialize all class variables:
  {
    ythis->pos = 0;
    ythis->bInsert = false;
    ythis->cDecimalSeparator = '.';
  }
  { 
    
    SETREFJc(ythis->buffer, buffer, StringBuilderJc);
  }
  STACKTRC_LEAVE;
  return ythis;
}



/**Same as getContent, overwrites Object.toString().*/
StringJc toString_StringFormatterJc_F(ObjectJc* ithis, ThCxt* _thCxt)
{ StringFormatterJc_s* ythis = (StringFormatterJc_s*)ithis;
  
  STACKTRC_TENTRY("toString_StringFormatterJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return toString_StringBuilderJc(& ((*(REFJc(ythis->buffer))).base.object)/*J2cT1*/, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc toString_StringFormatterJc(ObjectJc* ithis, ThCxt* _thCxt)
{ Mtbl_ObjectJc const* mtbl = (Mtbl_ObjectJc const*)getMtbl_ObjectJc(ithis, sign_Mtbl_ObjectJc);
  return mtbl->toString(ithis, _thCxt);
}


/**Gets the accumulated content.*/
StringJc getContent_StringFormatterJc_F(StringFormatterJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getContent_StringFormatterJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return toString_StringBuilderJc(& ((*(REFJc(ythis->buffer))).base.object)/*J2cT1*/, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
StringJc getContent_StringFormatterJc(StringFormatterJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->getContent(ythis, _thCxt);
}


/**Sets an deviant decimal separator for floating point digigs, country-specific. */
void setDecimalSeparator_StringFormatterJc_F(StringFormatterJc_s* ythis, char sep, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setDecimalSeparator_StringFormatterJc_F");
  
  { 
    
    ythis->cDecimalSeparator = sep;
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void setDecimalSeparator_StringFormatterJc(StringFormatterJc_s* ythis, char sep, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  mtbl->setDecimalSeparator(ythis, sep, _thCxt);
}


/**Resets the internal buffer*/
struct StringFormatterJc_t* reset_StringFormatterJc_F(StringFormatterJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("reset_StringFormatterJc_F");
  
  { 
    
    ythis->pos = 0;
    setLength_StringBuilderJc(REFJc(ythis->buffer), ythis->pos, _thCxt);
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* reset_StringFormatterJc(StringFormatterJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->reset(ythis, _thCxt);
}


/**Sets the current position to the end of the string. */
struct StringFormatterJc_t* end_StringFormatterJc_F(StringFormatterJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("end_StringFormatterJc_F");
  
  { 
    
    ythis->pos = length_StringBuilderJc(REFJc(ythis->buffer));
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* end_StringFormatterJc(StringFormatterJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->end(ythis, _thCxt);
}


/**Sets the current write position to the given position. */
struct StringFormatterJc_t* pos_StringFormatterJc_F(StringFormatterJc_s* ythis, int32 newPos, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("pos_StringFormatterJc_F");
  
  { 
    int32 pos1; 
    
    
    if(newPos < 0) { throw_s0Jc(ident_IndexOutOfBoundsExceptionJc, "negativ position not supported", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
    ythis->pos = newPos;
    pos1 = length_StringBuilderJc(REFJc(ythis->buffer));
    
    while(pos1 < ythis->pos)
      { 
        
        append_C_StringBuilderJc(REFJc(ythis->buffer), ' ', _thCxt);
        pos1 += 1;
      }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* pos_StringFormatterJc(StringFormatterJc_s* ythis, int32 newPos, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->pos(ythis, newPos, _thCxt);
}


/**returns the current length of string. */
int32 length_StringFormatterJc_F(StringFormatterJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("length_StringFormatterJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return length_StringBuilderJc(REFJc(ythis->buffer));
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 length_StringFormatterJc(StringFormatterJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->length(ythis, _thCxt);
}


/**returns the current position for add in buffer.*/
int32 getPos_StringFormatterJc_F(StringFormatterJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("getPos_StringFormatterJc_F");
  
  { 
    
    { STACKTRC_LEAVE;
      return ythis->pos;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 getPos_StringFormatterJc(StringFormatterJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->getPos(ythis, _thCxt);
}


/**Adds at the current position a string.*/
struct StringFormatterJc_t* add_S_StringFormatterJc_F(StringFormatterJc_s* ythis, StringJc str, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtthis = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  
  STACKTRC_TENTRY("add_S_StringFormatterJc_F");
  
  { 
    int32 nrofChars; 
    
    
    nrofChars = length_StringJc(str);
    mtthis->prepareBufferPos(ythis, nrofChars, _thCxt);
    replace_StringBuilderJc(REFJc(ythis->buffer), ythis->pos, ythis->pos + nrofChars, str, _thCxt);
    ythis->pos += nrofChars;
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* add_S_StringFormatterJc(StringFormatterJc_s* ythis, StringJc str, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->add_S(ythis, str, _thCxt);
}


/**Adds at the current position a char[].*/
struct StringFormatterJc_t* add_cY_StringFormatterJc_F(StringFormatterJc_s* ythis, char_Y* str, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtthis = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  
  STACKTRC_TENTRY("add_cY_StringFormatterJc_F");
  
  { 
    int32 nrofChars; 
    
    
    nrofChars = str->head.length;
    
    while(nrofChars > 1 && str->data[nrofChars - 1] == 0)
      { 
        
        nrofChars -= 1;
      }
    mtthis->prepareBufferPos(ythis, nrofChars, _thCxt);
    { int32 ii; 
      for(ii = 0; ii < nrofChars; ii++)
        { 
          
          setCharAt_StringBuilderJc(REFJc(ythis->buffer), ythis->pos, str->data[ii], _thCxt);
          ythis->pos += 1;
        }
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* add_cY_StringFormatterJc(StringFormatterJc_s* ythis, char_Y* str, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->add_cY(ythis, str, _thCxt);
}


/**Inserts a String at current position with shifting the actual content to right.*/
struct StringFormatterJc_t* insert_S_StringFormatterJc_F(StringFormatterJc_s* ythis, StringJc str, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("insert_S_StringFormatterJc_F");
  
  { 
    
    insert_s_StringBuilderJc(REFJc(ythis->buffer), ythis->pos, str, _thCxt);
    ythis->pos += length_StringJc(str);
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* insert_S_StringFormatterJc(StringFormatterJc_s* ythis, StringJc str, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->insert_S(ythis, str, _thCxt);
}


/**sets the overwrite mode. It is the default. In this mode add will overwrite the current content. */
struct StringFormatterJc_t* overwrite_StringFormatterJc_F(StringFormatterJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("overwrite_StringFormatterJc_F");
  
  { 
    
    ythis->bInsert = false;
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* overwrite_StringFormatterJc(StringFormatterJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->overwrite(ythis, _thCxt);
}


/**sets the insert mode. In this mode add will shift the content at pos to right. */
struct StringFormatterJc_t* insert_StringFormatterJc_F(StringFormatterJc_s* ythis, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("insert_StringFormatterJc_F");
  
  { 
    
    ythis->bInsert = true;
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* insert_StringFormatterJc(StringFormatterJc_s* ythis, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->insert(ythis, _thCxt);
}


/**sets the insert or overwrite mode, returns the current mode before change.*/
bool setInsertMode_StringFormatterJc_F(StringFormatterJc_s* ythis, bool insert, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setInsertMode_StringFormatterJc_F");
  
  { 
    bool bInsertRet; 
    
    
    bInsertRet = ythis->bInsert;
    ythis->bInsert = insert;
    { STACKTRC_LEAVE;
      return bInsertRet;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool setInsertMode_StringFormatterJc(StringFormatterJc_s* ythis, bool insert, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->setInsertMode(ythis, insert, _thCxt);
}


/**Adds a line of ascii representation of bytes*/
struct StringFormatterJc_t* addStringLine_StringFormatterJc_F(StringFormatterJc_s* ythis, int8_Y* data, int32 idx, int32 nrofBytes, StringJc charsetName, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtthis = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  
  STACKTRC_TENTRY("addStringLine_StringFormatterJc_F");
  
  { //:to convert bytes with a given charset, but show bytes < 0x20 with '.', copy it in a independend buffer:
    
    int8_Y* data1; 
    StringJc str = NULL_StringJc; 
    int32 strLength; 
    
    ObjectJc *newObj1_1=null; //J2C: temporary Objects for new operations
    
    
    data1 = (int8_Y*)ctorO_ObjectArrayJc((newObj1_1 = alloc_ObjectJc( sizeof(ObjectArrayJc) + (nrofBytes) * sizeof(int8), mIsLargeSize_objectIdentSize_ObjectJc, _thCxt)), nrofBytes, sizeof(int8),REFLECTION_int8, 0);
    arraycopy_SystemJc(/*static*/& ((data)->head.object), idx, & ((data1)->head.object), 0, nrofBytes, _thCxt);
    { int32 ii; 
      for(ii = 0; ii < nrofBytes; ii++)
        { 
          
          if(data1->data[ii] < 0x20) 
          { 
            
            data1->data[ii] = (int8)('.');
          }//write insteads control chars.
          
        }
    }
    /*no initvalue*/
    TRY
    { 
      
      str = new_BYIICharset_StringJc(/*static*/data1, 0, nrofBytes, charsetName, _thCxt)/*J2C:non-persistent*/;
    }_TRY
    CATCH(UnsupportedEncodingException, exc)
    
      { 
        
        str = z_StringJc("??encoding error??")/*J2C:non-persistent*/;
      }
    END_TRY//not replace in buffer:
    
    strLength = length_StringJc(str);
    mtthis->prepareBufferPos(ythis, strLength, _thCxt);
    replace_StringBuilderJc(REFJc(ythis->buffer), ythis->pos, ythis->pos + strLength, str, _thCxt);
    ythis->pos += strLength;
    { STACKTRC_LEAVE;
      activateGarbageCollectorAccess_BlockHeapJc(newObj1_1, null);
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* addStringLine_StringFormatterJc(StringFormatterJc_s* ythis, int8_Y* data, int32 idx, int32 nrofBytes, StringJc charsetName, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->addStringLine(ythis, data, idx, nrofBytes, charsetName, _thCxt);
}


/**Adds at the current position a line of hex numbers.*/
struct StringFormatterJc_t* addHexLine_StringFormatterJc_F(StringFormatterJc_s* ythis, int8_Y* data, int32 idx, int32 nrofBytes, int16 mode, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtthis = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  
  STACKTRC_TENTRY("addHexLine_StringFormatterJc_F");
  
  { 
    int32 nrofBytesInWord; 
    int32 nrofWords; 
    int32 nrofBytes1; 
    int32 idx1; 
    
    
    nrofBytesInWord = mode & mNrofBytesInWord_StringFormatterJc;
    nrofWords = nrofBytes / nrofBytesInWord;
    mtthis->prepareBufferPos(ythis, 2 * nrofBytes + nrofWords, _thCxt);
    nrofBytes1 = nrofBytes;
    idx1 = idx;
    
    while(nrofBytes1 > 0)
      { 
        
        if(nrofBytes1 < nrofBytesInWord) 
        { //:the last hex word is smaller as given in mode:
          
          
          mtthis->addHexWord_(ythis, data, idx1, (int16)((mode & mBytesInWordBigEndian_StringFormatterJc) + nrofBytes1), _thCxt);
          nrofBytes1 = 0;
        }
        else 
        { //:normal operation
          
          
          mtthis->addHexWord_(ythis, data, idx1, mode, _thCxt);
          setCharAt_StringBuilderJc(REFJc(ythis->buffer), ythis->pos++, ' ', _thCxt);
          nrofBytes1 -= nrofBytesInWord;
          idx1 += nrofBytesInWord;
        }
      }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* addHexLine_StringFormatterJc(StringFormatterJc_s* ythis, int8_Y* data, int32 idx, int32 nrofBytes, int16 mode, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->addHexLine(ythis, data, idx, nrofBytes, mode, _thCxt);
}


/**Adds a hexa line with left address and ascii*/
struct StringFormatterJc_t* addHexWord_StringFormatterJc_F(StringFormatterJc_s* ythis, int8_Y* data, int32 idx, int16 mode, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtthis = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  
  STACKTRC_TENTRY("addHexWord_StringFormatterJc_F");
  
  { 
    
    mtthis->prepareBufferPos(ythis, 2 * (mode & mNrofBytesInWord_StringFormatterJc), _thCxt);
    { STACKTRC_LEAVE;
      return mtthis->addHexWord_(ythis, data, idx, mode, _thCxt);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* addHexWord_StringFormatterJc(StringFormatterJc_s* ythis, int8_Y* data, int32 idx, int16 mode, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->addHexWord(ythis, data, idx, mode, _thCxt);
}


/**Adds a number as one word readed from data in hexa form, internal routine without prepareBufferPos*/
struct StringFormatterJc_t* addHexWord__StringFormatterJc_F(StringFormatterJc_s* ythis, int8_Y* data, int32 idx, int16 mode, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addHexWord__StringFormatterJc_F");
  
  { 
    int32 nrofBytesInWord; 
    int32 incrIdx = 0; 
    
    
    nrofBytesInWord = mode & mNrofBytesInWord_StringFormatterJc;
    /*no initvalue*/
    if((mode & mBytesInWordBigEndian_StringFormatterJc) != 0) 
    { 
      
      incrIdx = 1;
    }
    else 
    { 
      
      incrIdx = -1;
      idx += nrofBytesInWord - 1;
    }
    
    while(--nrofBytesInWord >= 0)
      { 
        int8 value; 
        
        
        value = data->data[idx];
        idx += incrIdx;//TRICKY may be 1 or -1 dependend on BigEndian
        
        { int32 i; 
          for(i = 0; i < 2; i++)
            { 
              char digit; 
              
              
              digit = (char)(((value & 0xf0) >> 4) + (int8)('0'));
              if(digit > '9') 
              { 
                
                digit = (char)(digit + (int8)('a') - (int8)('9') - 1);
              }
              setCharAt_StringBuilderJc(REFJc(ythis->buffer), ythis->pos++, digit, _thCxt);
              value <<= 4;
            }
        }
      }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* addHexWord__StringFormatterJc(StringFormatterJc_s* ythis, int8_Y* data, int32 idx, int16 mode, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->addHexWord_(ythis, data, idx, mode, _thCxt);
}


/**Adds a number containing in a long variable in hexa form*/
struct StringFormatterJc_t* addHex_StringFormatterJc_F(StringFormatterJc_s* ythis, int64 value, int32 nrofDigits, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtthis = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  
  STACKTRC_TENTRY("addHex_StringFormatterJc_F");
  
  { 
    
    mtthis->prepareBufferPos(ythis, nrofDigits, _thCxt);
    
    { //:show last significant byte at right position, like normal variable or register look
      
      int32 nrofShift; 
      
      
      nrofShift = (nrofDigits * 4) - 4;
      { int32 ii; 
        for(ii = 0; ii < nrofDigits; ii++)
          { 
            char digit; 
            
            
            digit = (char)(((value >> nrofShift) & 0xf) + (int8)('0'));
            if(digit > '9') 
            { 
              
              digit = (char)(digit + (int8)('a') - (int8)('9') - 1);
            }
            setCharAt_StringBuilderJc(REFJc(ythis->buffer), ythis->pos++, digit, _thCxt);
            nrofShift -= 4;
          }
      }
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* addHex_StringFormatterJc(StringFormatterJc_s* ythis, int64 value, int32 nrofDigits, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->addHex(ythis, value, nrofDigits, _thCxt);
}


/**Adds a number containing in a long variable in hexa form*/
struct StringFormatterJc_t* addBinary_StringFormatterJc_F(StringFormatterJc_s* ythis, int32 value, StringJc sPicture, StringJc sBitCharLo, StringJc sBitCharHi, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtthis = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  
  STACKTRC_TENTRY("addBinary_StringFormatterJc_F");
  
  { 
    int32 nrofDigits = 0; 
    int32 mask = 1; 
    
    
    nrofDigits = 0;
    { int32 ii; 
      for(ii = 0; ii < length_StringJc(sPicture); ii++)
        { 
          
          if(charAt_StringJc(sPicture, ii) == '1') 
          { 
            
            nrofDigits += 1;
          }
        }
    }
    mask = 1 << (nrofDigits - 1);
    mtthis->prepareBufferPos(ythis, length_StringJc(sPicture), _thCxt);
    { int32 ii; 
      for(ii = 0; ii < length_StringJc(sPicture); ii++)
        { 
          char cBitPos; 
          
          
          cBitPos = charAt_StringJc(sPicture, ii);
          if(cBitPos == '1') 
          { 
            int32 bit; 
            char cc; 
            
            
            bit = value & mask;
            cc = bit != 0 ? charAt_StringJc(sBitCharHi, ii) : charAt_StringJc(sBitCharLo, ii);
            setCharAt_StringBuilderJc(REFJc(ythis->buffer), ythis->pos++, cc, _thCxt);
            mask = (mask >> 1) & 0x7fffffff;
          }
          else 
          { 
            
            setCharAt_StringBuilderJc(REFJc(ythis->buffer), ythis->pos++, cBitPos, _thCxt);
          }
        }
    }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* addBinary_StringFormatterJc(StringFormatterJc_s* ythis, int32 value, StringJc sPicture, StringJc sBitCharLo, StringJc sBitCharHi, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->addBinary(ythis, value, sPicture, sBitCharLo, sBitCharHi, _thCxt);
}


/**ensures, that the space in buffer started on pos is writeable with setCharAt.*/
void prepareBufferPos_StringFormatterJc_F(StringFormatterJc_s* ythis, int32 nrofChars, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("prepareBufferPos_StringFormatterJc_F");
  
  { //:if(true || bInsert)
    
    
    if(ythis->bInsert && ythis->pos < length_StringBuilderJc(REFJc(ythis->buffer))) 
    { 
      
      
      while(nrofChars > 0)
        { 
          
          if(nrofChars >= length_StringJc(spaces_StringFormatterJc)) 
          { 
            
            insert_s_StringBuilderJc(REFJc(ythis->buffer), ythis->pos, spaces_StringFormatterJc, _thCxt);
            nrofChars -= length_StringJc(spaces_StringFormatterJc);
          }
          else 
          { 
            
            insert_sII_StringBuilderJc(REFJc(ythis->buffer), ythis->pos, spaces_StringFormatterJc, 0, nrofChars, _thCxt);
            nrofChars = 0;
          }
        }//buffer.insert(pos, spaces, 0, nrofChars);
        
    }
    else 
    { 
      int32 nrofCharsToEnd; 
      
      
      nrofCharsToEnd = length_StringBuilderJc(REFJc(ythis->buffer)) - ythis->pos;
      ASSERT(/*static*/nrofCharsToEnd >= 0);
      nrofChars -= nrofCharsToEnd;//nrofChars may be < 0 if the range of overwrite is inside the exiting string.
      
      
      while(nrofChars > 0)
        { //:appends necessary space on end. the format methods overwrites this space.
          
          
          if(nrofChars >= length_StringJc(spaces_StringFormatterJc)) 
          { 
            
            append_s_StringBuilderJc(REFJc(ythis->buffer), spaces_StringFormatterJc, _thCxt);
            nrofChars -= length_StringJc(spaces_StringFormatterJc);
          }
          else 
          { 
            
            append_sII_StringBuilderJc(REFJc(ythis->buffer), spaces_StringFormatterJc, 0, nrofChars, _thCxt);
            nrofChars = 0;
          }
        }
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
void prepareBufferPos_StringFormatterJc(StringFormatterJc_s* ythis, int32 nrofChars, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  mtbl->prepareBufferPos(ythis, nrofChars, _thCxt);
}


/**Adds a number in form 12ab'cd34, it is typical to show 4-byte-values at example addresses.*/
struct StringFormatterJc_t* addHex44_StringFormatterJc_F(StringFormatterJc_s* ythis, int64 value, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtthis = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  
  STACKTRC_TENTRY("addHex44_StringFormatterJc_F");
  
  { 
    
    mtthis->addHex(ythis, (value >> 16) & 0xffff, 4, _thCxt);
    insert_C_StringBuilderJc(REFJc(ythis->buffer), ythis->pos++, '\'', _thCxt);
    mtthis->addHex(ythis, (value) & 0xffff, 4, _thCxt);
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* addHex44_StringFormatterJc(StringFormatterJc_s* ythis, int64 value, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->addHex44(ythis, value, _thCxt);
}


/**adds a double value in a fix point representation without exponent.*/
struct StringFormatterJc_t* addFloat_StringFormatterJc_F(StringFormatterJc_s* ythis, double value, int32 digitsBeforePoint, int32 digitsAfterPoint, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtthis = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  
  STACKTRC_TENTRY("addFloat_StringFormatterJc_F");
  
  { 
    int32 nrofCharsInPicture; 
    StringJc sValue; 
    int32 posPointInValue; 
    int32 nrofSpacesBefore; 
    int32 nrofZeroAfter; 
    int32 nrofValueChars; 
    
    
    nrofCharsInPicture = digitsBeforePoint + digitsAfterPoint + 2;
    mtthis->prepareBufferPos(ythis, nrofCharsInPicture, _thCxt);
    if(value < 0) 
    { 
      
      setCharAt_StringBuilderJc(REFJc(ythis->buffer), ythis->pos++, '-', _thCxt);
      value = -value;
    }
    else 
    { 
      
      setCharAt_StringBuilderJc(REFJc(ythis->buffer), ythis->pos++, ' ', _thCxt);
    }
    sValue = toString_DoubleJc(/*static*/value, _thCxt)/*J2C:non-persistent*/;
    posPointInValue = indexOf_C_StringJc(sValue, '.');
    if(ythis->cDecimalSeparator != '.') 
    { 
      
      sValue = replace_StringJc(sValue, '.', ythis->cDecimalSeparator, _thCxt)/*J2C:non-persistent*/;
    }//int posPoint = pos + digitsBeforePoint;
    
    nrofSpacesBefore = digitsBeforePoint - posPointInValue;
    nrofZeroAfter = digitsAfterPoint - (length_StringJc(sValue) - posPointInValue - 1);
    if(nrofZeroAfter < 0) 
    { 
      
      nrofZeroAfter = 0;
    }
    nrofValueChars = digitsBeforePoint - nrofSpacesBefore + 1 + digitsAfterPoint - nrofZeroAfter;
    
    while(nrofSpacesBefore > 0)
      { 
        
        setCharAt_StringBuilderJc(REFJc(ythis->buffer), ythis->pos++, ' ', _thCxt);
        nrofSpacesBefore -= 1;
      }//int digitsAfterPointInValue =sValue.length() - posPointInValue -1;
      //if(digitsAfterPointInValue > digitsAfterPoint){ digitsAfterPointInValue = digitsAfterPoint;}
    
    if(nrofSpacesBefore < 0) 
    { //:the number of digits is to large,
      
      
      nrofValueChars = nrofValueChars - (-nrofSpacesBefore) - 2;//crash situation: write only the beginn of the digit
      
      replace_StringBuilderJc(REFJc(ythis->buffer), ythis->pos, ythis->pos + 2, s0_StringJc("##"), _thCxt);
      ythis->pos += 2;
    }
    replace_StringBuilderJc(REFJc(ythis->buffer), ythis->pos, ythis->pos + nrofValueChars, substring_StringJc(sValue, 0, nrofValueChars, _thCxt), _thCxt);
    ythis->pos += nrofValueChars;
    
    while(--nrofZeroAfter >= 0)
      { 
        
        setCharAt_StringBuilderJc(REFJc(ythis->buffer), ythis->pos++, '0', _thCxt);
      }
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* addFloat_StringFormatterJc(StringFormatterJc_s* ythis, double value, int32 digitsBeforePoint, int32 digitsAfterPoint, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->addFloat(ythis, value, digitsBeforePoint, digitsAfterPoint, _thCxt);
}


/**Adds a line with representation of byte content in a fixed nice format.*/
StringJc addHexLn_StringFormatterJc(/*static*/ int8_Y* data, int32 length, int32 idxStart, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("addHexLn_StringFormatterJc");
  
  { 
    int32 idx; 
    struct StringFormatterJc_t* buffer = null; 
    StringJc strRet = CONST_z_StringJc(""); 
    
    ObjectJc *newObj1_1=null; //J2C: temporary Objects for new operations
    
    idx = idxStart;
    
    buffer = ctorO_StringFormatterJc(/*static*/(newObj1_1 = alloc_ObjectJc(sizeof_StringFormatterJc_s, 0, _thCxt)), _thCxt);
    strRet = z_StringJc("")/*J2C:non-persistent*/;
    
    while(idx < (idxStart + length))
      { 
        int32 idxLineEnd; 
        
         //J2C: temporary Stringbuffer for String concatenation
        StringBuilderJc* _tempString2_1=null; 
        
        idxLineEnd = idx + 32;
        if(idxLineEnd > length) 
        { 
          
          idxLineEnd = idxStart + length;
        }
        addHexLine_StringFormatterJc_F(buffer, data, idx, idxLineEnd - idx, k4right_StringFormatterJc, _thCxt);
        add_S_StringFormatterJc_F(buffer, s0_StringJc(" "), _thCxt);
        addStringLine_StringFormatterJc_F(buffer, data, idx, idxLineEnd - idx, s0_StringJc("ISO-8859-1"), _thCxt);
        strRet = 
        ( _tempString2_1 = new_StringBuilderJc(-1, _thCxt)
        , setStringConcatBuffer_StringBuilderJc(_tempString2_1)
        , append_s_StringBuilderJc(_tempString2_1, strRet, _thCxt)
        , append_s_StringBuilderJc(_tempString2_1, getContent_StringFormatterJc_F(buffer, _thCxt), _thCxt)
        , append_z_StringBuilderJc(_tempString2_1, "\n", _thCxt)
        , toString_StringBuilderJc(&(_tempString2_1)->base.object, _thCxt)
        )/*J2C:non-persistent*/;
        reset_StringFormatterJc_F(buffer, _thCxt);
        idx = idxLineEnd;
        activateGarbageCollectorAccess_BlockHeapJc(&_tempString2_1->base.object, null);
      }
    { STACKTRC_LEAVE;
      activateGarbageCollectorAccess_BlockHeapJc(newObj1_1, PTR_StringJc(strRet));
      return strRet;
    }
  }
  STACKTRC_LEAVE;
}

struct StringFormatterJc_t* add_c_StringFormatterJc_F(StringFormatterJc_s* ythis, char ch, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtthis = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  
  STACKTRC_TENTRY("add_c_StringFormatterJc_F");
  
  { 
    
    mtthis->prepareBufferPos(ythis, 1, _thCxt);
    setCharAt_StringBuilderJc(REFJc(ythis->buffer), ythis->pos++, ch, _thCxt);
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* add_c_StringFormatterJc(StringFormatterJc_s* ythis, char ch, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->add_c(ythis, ch, _thCxt);
}

struct StringFormatterJc_t* addDate_StringFormatterJc_F(StringFormatterJc_s* ythis, struct DateJc_t* date, struct SimpleDateFormatJc_t* format, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtthis = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  
  STACKTRC_TENTRY("addDate_StringFormatterJc_F");
  
  { 
    StringJc sDate; 
    
    StringJc _persistring1_1=NULL_StringJc; //J2C: temporary persistent Strings
    
    sDate = _persistring1_1 = persist_StringJc(format_SimpleDateFormatJc(format, (date)->val, _thCxt))/*J2C:non-persistent*/;
    mtthis->add_S(ythis, sDate, _thCxt);
    { STACKTRC_LEAVE;
      activateGarbageCollectorAccess_BlockHeapJc(PTR_StringJc(_persistring1_1), null);
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* addDate_StringFormatterJc(StringFormatterJc_s* ythis, struct DateJc_t* date, struct SimpleDateFormatJc_t* format, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->addDate(ythis, date, format, _thCxt);
}

struct StringFormatterJc_t* setAt_StringFormatterJc_F(StringFormatterJc_s* ythis, int32 pos, char ch, ThCxt* _thCxt)
{ 
  STACKTRC_TENTRY("setAt_StringFormatterJc_F");
  
  { 
    
    setCharAt_StringBuilderJc(REFJc(ythis->buffer), pos, ch, _thCxt);
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* setAt_StringFormatterJc(StringFormatterJc_s* ythis, int32 pos, char ch, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->setAt(ythis, pos, ch, _thCxt);
}


/**Sets a integer value at current position, use the picture to determine the number of characters etc.*/
struct StringFormatterJc_t* addint_StringFormatterJc_F(StringFormatterJc_s* ythis, int64 nr, StringJc sPict, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtthis = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  
  STACKTRC_TENTRY("addint_StringFormatterJc_F");
  
  { 
    
    mtthis->strPicture(ythis, nr, sPict, s0_StringJc("+-.."), '.', _thCxt);
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* addint_StringFormatterJc(StringFormatterJc_s* ythis, int64 nr, StringJc sPict, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->addint(ythis, nr, sPict, _thCxt);
}


/***/
struct StringFormatterJc_t* addIntPicture_StringFormatterJc_F(StringFormatterJc_s* ythis, int64 nr, StringJc sPict, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtthis = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  
  STACKTRC_TENTRY("addIntPicture_StringFormatterJc_F");
  
  { 
    
    mtthis->strPicture(ythis, nr, sPict, s0_StringJc("+-.."), '.', _thCxt);
    { STACKTRC_LEAVE;
      return ythis;
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
struct StringFormatterJc_t* addIntPicture_StringFormatterJc(StringFormatterJc_s* ythis, int64 nr, StringJc sPict, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->addIntPicture(ythis, nr, sPict, _thCxt);
}


/**This algorithm is taken over from C++ routines in strpict.cpp written by JcHartmut in 1993..1999.*/
bool strPicture_StringFormatterJc_F(StringFormatterJc_s* ythis, int64 src, StringJc pict, StringJc posNegPointExp, char cFracSep, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtthis = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  
  STACKTRC_TENTRY("strPicture_StringFormatterJc_F");
  
  { 
    int32 n10i = 0; 
    bool bNeg = false;   /*set if the input number is negativ, and it is negated. */
    int32 nrofCharForSign = 0;   /*number of chars for the sign, it is 0 or 1. */
    int32 nrofCharsForSignUnused = 0;   /*1 if a '-' for sign position is given and the number is positiv. */
    bool bLeftZeroSuppress = false;   /*setted if left zero-digits are suppressed, no '0' and no space should be shown. */
    struct StringPartJc_t* spPict = null; 
    int32 posSignInPicture; 
    int32 nDigits; 
    int32 nrofChars; 
    int32 ii; 
    int32 n0Digit = 0; 
    int32 n1Digit = 0; 
    int32 n2Digit = 0; 
    int32 n3Digit = 0; 
    bool bOvf = 0; 
    char cp = 0; 
    
    ObjectJc *newObj1_1=null; //J2C: temporary Objects for new operations
    
    /*no initvalue*/
    bNeg = false;
    /*no initvalue*/
    nrofCharsForSignUnused = 0;
    bLeftZeroSuppress = false;
    
    spPict = ctorO_S_StringPartJc(/*static*/(newObj1_1 = alloc_ObjectJc(sizeof_StringPartJc_s, 0, _thCxt)), pict, _thCxt);
    posSignInPicture = indexOfAnyChar_S_StringPartJc_F(spPict, sNeg_StringFormatterJc, _thCxt);
    if(posSignInPicture >= 0) 
    { 
      
      if(src < 0) 
      { 
        
        bNeg = true;
        src = -src;//Zahl negieren
        
        nrofCharForSign = 1;
      }
      else 
      { 
        
        if(charAt_StringJc(pict, posSignInPicture) != '-') 
        { 
          
          nrofCharForSign = 1;//displays the sign always.
          
        }
        else 
        { 
          
          nrofCharForSign = 0;//don't display a sign.
          
          nrofCharsForSignUnused = 0;
        }
      }
    }
    else if(src < 0) 
    { 
       //J2C: temporary Stringbuffer for String concatenation
      StringBuilderJc* _tempString2_1=null; 
      
      { throw_sJc(ident_IllegalArgumentExceptionJc, 
        ( _tempString2_1 = new_StringBuilderJc(-1, _thCxt)
        , setStringConcatBuffer_StringBuilderJc(_tempString2_1)
        , append_z_StringBuilderJc(_tempString2_1, "value should be only positive: ", _thCxt)
        , append_J_StringBuilderJc(_tempString2_1, src, _thCxt)
        , toString_StringBuilderJc(&(_tempString2_1)->base.object, _thCxt)
        ), 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
      activateGarbageCollectorAccess_BlockHeapJc(&_tempString2_1->base.object, null);
    }//if the number is negativ but a sign is not expected, the number will be shown as positiv value.
    //
    //----------------------------------------------------------------------
    
    for(n10i = ARRAYLEN(n10a_StringFormatterJc) - 1; n10i >= 0; n10i--)
      { //:meistens sind es kleine Zahlen, im Mittel geht es also schneller
        //:wenn von Hinten aus getestet wird ob die Zahl groesser ist,
        //:damit weniger Schleifendurchlauefe:
        
        
        if(src < n10a_StringFormatterJc[n10i]) break;
      }//n10[n10i] ist die Zahl, die um eine Stelle groeser ist.
      
    n10i += 1;//damit ist n10[n10i] die als erste kleinere Zahl.
    
    nDigits = ARRAYLEN(n10a_StringFormatterJc) - n10i + 1;
    nrofChars = length_StringJc(pict);
    ii = nrofChars;
    n0Digit = 0;
    n1Digit = 0;
    n2Digit = 0;
    n3Digit = 0;
    
    while(ii > 0)
      { 
        char cp; 
        
        
        cp = charAt_StringJc(pict, --ii);
        if(cp <= '2' && cp >= '0') 
        { 
          
          n2Digit += 1;//210 in Picture: Soll-Platz fuer Digits
          
          n3Digit += 1;
          if(cp == '0') 
          { 
            
            n0Digit += 1;
            n1Digit = n2Digit;
          }//mdst. Stelle auszuschreiben
          
          else if(cp == '1') n1Digit = n2Digit;
        }
        else if(cp <= '9' && cp >= '3') 
        { 
          
          n3Digit += 1;
        }
      }
    /*no initvalue*/
    if(nDigits > n3Digit) 
    { //:Zahl ist nicht darstellbar: stattdessen 99999 darstellen
      
      
      bOvf = true;//n3Digit=0;
      
      n2Digit = n3Digit;
    }
    else 
    { 
      
      bOvf = false;
      if(nDigits > n2Digit) n2Digit = nDigits;//Anzahl auszugeb. Digits oder Leerstellen
      
    }
    mtthis->prepareBufferPos(ythis, nrofChars - (n3Digit - n2Digit) - nrofCharsForSignUnused, _thCxt);
    /*no initvalue*/
    ii = 0;
    for(ii = 0; ii < nrofChars; ii++)
      { 
        char cc = 0; 
        int32 ixPosNegPointExp = 0; 
        
        
        cp = charAt_StringJc(pict, ii);
        /*no initvalue*/
        /*no initvalue*/
        if(cp >= '0' && cp <= '9') 
        { 
          
          if(--n3Digit >= n2Digit) cc = ((char)(0));//keine Ausgabe weil nicht notwendige fuehr. Stellen
          
          else 
          { //:Ausgabe aufgrund n2Digit notwendig
            
            
            if(n2Digit > nDigits) 
            { //:Anzahl auszuschreib. Stellen groesser als Zahl:
              
              
              if(n1Digit >= n2Digit) cc = '0';//fuerende Null
              
              else cc = ' ';
            }
            else 
            { //:Ziffer bestimmen:
              
              
              n1Digit = 0;//keine fuerenden 0 mehr notwendig
              
              if(bOvf) cc = '#';
              else if(src == 0) 
              { 
                
                if(n0Digit >= nDigits) cc = ((char)(0));//nichts ausgeben bei weglassbaren nachfolg. 0
                
                else cc = '0';
              }
              else if(n10i >= ARRAYLEN(n10a_StringFormatterJc)) 
              { 
                
                cc = (char)(src + '0');//das ist die Einerstelle
                
              }
              else 
              { 
                int64 src10; 
                
                
                src10 = n10a_StringFormatterJc[n10i];
                n10i += 1;//Dezimalstelle gehoert dazu
                
                cc = '0';
                
                while(src >= src10)
                  { 
                    
                    cc += (char)(1);
                    src -= src10;
                  }//in Schleife subtr. statt Divis.
                  
              }
              nDigits -= 1;
            }
            n2Digit -= 1;
          }
        }
        else if((ixPosNegPointExp = /*? assignment*/indexOf_C_StringJc(posNegPointExp, cp)) >= 0) 
        { 
          
          /**Any control character found: */
          switch(ixPosNegPointExp){
            case 0: cc = charAt_StringJc(posNegPointExp, bNeg ? 1 : 0);break;//positiv digit
            
            case 1: 
            { 
              
              if(bNeg) 
              { //:number is negativ, write a '-' always.
                
                
                cc = cp;
              }
              else 
              { //:number is positive:
                
                
                if(bLeftZeroSuppress) 
                { 
                  
                  cc = ((char)(0));
                }//write nothing if number is positiv and left zeros are suppressed.
                
                else 
                { 
                  
                  cc = ' ';
                }//write blank if a negative sign is required in picture and the number is positive.
                
              }
            }break;
            case 2: cc = cFracSep;break;//show the given fractional separator if the control-char for fract. separator is found.
            
            case 3: cc = cFracSep == '.' ? ' ' : cFracSep;break;//don't show if 10^0
            
            default: { throw_s0Jc(ident_RuntimeExceptionJc, "unexpected case", 0, &_thCxt->stacktraceThreadContext, __LINE__); return 0; };
          }/*switch*/;
        }
        else 
        { 
          
          cc = cp;//anderes Zeichen aus Picture uebertragen
          
        }
        if(cc != 0) 
        { //:cc=0 means, the char shouls not be written.
          
          
          setCharAt_StringBuilderJc(REFJc(ythis->buffer), ythis->pos++, cc, _thCxt);
        }
      }//for
      
    { STACKTRC_LEAVE;
      activateGarbageCollectorAccess_BlockHeapJc(newObj1_1, null);
      return (!bOvf);
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
bool strPicture_StringFormatterJc(StringFormatterJc_s* ythis, int64 src, StringJc pict, StringJc posNegPointExp, char cFracSep, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->strPicture(ythis, src, pict, posNegPointExp, cFracSep, _thCxt);
}


/**Writes a float value in technical representation with exponent as short char a..T*/
int32 addFloatPicture_StringFormatterJc_F(StringFormatterJc_s* ythis, float src, StringJc pict, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtthis = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  
  STACKTRC_TENTRY("addFloatPicture_StringFormatterJc_F");
  
  { //:Exponent der Zahl bestimmen:
    
    StringJc cFrac = CONST_z_StringJc("afpnum.kMGT"); 
    int32 nExp; 
    int32 srcHex; 
    int8 nExpF; 
    bool bNeg; 
    bool bIsNull; 
    int64 srcLong = 0; 
    
    
    cFrac = z_StringJc("afpnum.kMGT")/*J2C:non-persistent*/;
    nExp = indexOf_C_StringJc(cFrac, '.');
    srcHex = floatToRawIntBits_FloatJc(/*static*/src);
    nExpF = (int8)((srcHex >> 24) & 0x7f);
    if(nExpF > (40 + 0x40)) src = 9.999999E17F;
    else if(nExpF < (0x40 - 40)) src = 0.0F;//the 0 itself is a 0.
    //unused(nExpF + *pSrcHex);
    
    bNeg = (srcHex < 0);
    bIsNull = (srcHex & 0x7f800000) == 0;
    /*no initvalue*/
    if(bNeg) src = -src;
    if(!bIsNull) 
    { 
      
      
      while(src >= 1000.0F && nExp < length_StringJc(cFrac) - 1)
        { 
          
          src = src / 1000.0F;
          nExp += 1;
        }
      
      while(src < 1.0F && nExp > 0)
        { 
          
          src = src * 1000.0F;
          nExp -= 1;
        }
      if(bNeg) src = -src;
      srcLong = (int64)(src);
    }
    else 
    { 
      
      srcLong = 0;
    }
    mtthis->strPicture(ythis, srcLong, pict, s0_StringJc("+-.@"), charAt_StringJc(cFrac, nExp), _thCxt);
    { STACKTRC_LEAVE;
      return (length_StringJc(pict));
    }
  }
  STACKTRC_LEAVE;
}

/*J2C: dynamic call variant of the override-able method: */
int32 addFloatPicture_StringFormatterJc(StringFormatterJc_s* ythis, float src, StringJc pict, ThCxt* _thCxt)
{ Mtbl_StringFormatterJc const* mtbl = (Mtbl_StringFormatterJc const*)getMtbl_ObjectJc(&ythis->base.object, sign_Mtbl_StringFormatterJc);
  return mtbl->addFloatPicture(ythis, src, pict, _thCxt);
}


void finalize_StringFormatterJc_F(ObjectJc* othis, ThCxt* _thCxt)
{ StringFormatterJc_s* ythis = (StringFormatterJc_s*)othis;  //upcasting to the real class.
 STACKTRC_TENTRY("finalize_StringFormatterJc_F");
  CLEAR_REFJc(ythis->buffer);
  finalize_ObjectJc_F(&ythis->base.object, _thCxt); //J2C: finalizing the superclass.
  STACKTRC_LEAVE;
}




/**J2C: Reflections and Method-table *************************************************/
const MtblDef_StringFormatterJc mtblStringFormatterJc = {
{ { sign_Mtbl_StringFormatterJc//J2C: Head of methodtable.
  , (struct Size_Mtbl_t*)((29 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
  }
, getContent_StringFormatterJc_F //getContent
, setDecimalSeparator_StringFormatterJc_F //setDecimalSeparator
, reset_StringFormatterJc_F //reset
, end_StringFormatterJc_F //end
, pos_StringFormatterJc_F //pos
, length_StringFormatterJc_F //length
, getPos_StringFormatterJc_F //getPos
, add_S_StringFormatterJc_F //add_S
, add_cY_StringFormatterJc_F //add_cY
, insert_S_StringFormatterJc_F //insert_S
, overwrite_StringFormatterJc_F //overwrite
, insert_StringFormatterJc_F //insert
, setInsertMode_StringFormatterJc_F //setInsertMode
, addStringLine_StringFormatterJc_F //addStringLine
, addHexLine_StringFormatterJc_F //addHexLine
, addHexWord_StringFormatterJc_F //addHexWord
, addHexWord__StringFormatterJc_F //addHexWord_
, addHex_StringFormatterJc_F //addHex
, addBinary_StringFormatterJc_F //addBinary
, prepareBufferPos_StringFormatterJc_F //prepareBufferPos
, addHex44_StringFormatterJc_F //addHex44
, addFloat_StringFormatterJc_F //addFloat
, add_c_StringFormatterJc_F //add_c
, addDate_StringFormatterJc_F //addDate
, setAt_StringFormatterJc_F //setAt
, addint_StringFormatterJc_F //addint
, addIntPicture_StringFormatterJc_F //addIntPicture
, strPicture_StringFormatterJc_F //strPicture
, addFloatPicture_StringFormatterJc_F //addFloatPicture
, { { sign_Mtbl_ObjectJc//J2C: Head of methodtable.
    , (struct Size_Mtbl_t*)((5 +2) * sizeof(void*)) //size. NOTE: all elements are standard-pointer-types.
    }
  , clone_ObjectJc_F //clone
  , equals_ObjectJc_F //equals
  , finalize_StringFormatterJc_F //finalize
  , hashCode_ObjectJc_F //hashCode
  , toString_StringFormatterJc_F //toString
  }
}, { signEnd_Mtbl_ObjectJc, null } }; //Mtbl


 extern struct ClassJc_t const reflection_ObjectJc;
 static struct superClasses_StringFormatterJc_s_t
 { ObjectArrayJc head;
   ClassOffset_idxMtblJc data[1];
 }superclasses_StringFormatterJc_s =
 { CONST_ObjectArrayJc(ClassOffset_idxMtblJc, 1, OBJTYPE_ClassOffset_idxMtblJc, null, null)
 , { {&reflection_ObjectJc, OFFSET_Mtbl(Mtbl_StringFormatterJc, ObjectJc) }
   }
 };

extern struct ClassJc_t const reflection_StringFormatterJc_s;
extern struct ClassJc_t const reflection_StringBuilderJc;
extern struct ClassJc_t const reflection_StringJc;
const struct Reflection_Fields_StringFormatterJc_s_t
{ ObjectArrayJc head; FieldJc data[11];
} reflection_Fields_StringFormatterJc_s =
{ CONST_ObjectArrayJc(FieldJc, 11, OBJTYPE_FieldJc, null, &reflection_Fields_StringFormatterJc_s)
, {
     { "buffer"
    , 0 //nrofArrayElements
    , &reflection_StringBuilderJc
    , kEnhancedReference_Modifier_reflectJc /*@*/ |mObjectJc_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->buffer) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "pos"
    , 0 //nrofArrayElements
    , REFLECTION_int32
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->pos) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "bInsert"
    , 0 //nrofArrayElements
    , REFLECTION_bool
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->bInsert) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "cDecimalSeparator"
    , 0 //nrofArrayElements
    , REFLECTION_char
    , 4 << kBitPrimitiv_Modifier_reflectJc //bitModifiers
    , (int16)((int32)(&((StringFormatterJc_s*)(0x1000))->cDecimalSeparator) - (int32)(StringFormatterJc_s*)0x1000)
    , 0  //offsetToObjectifcBase
    , &reflection_StringFormatterJc_s
    }
   , { "k2left"
    , 0 //nrofArrayElements
    , REFLECTION_int16
    , 2 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&k2left_StringFormatterJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&k2left_StringFormatterJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringFormatterJc_s
    }
   , { "k4left"
    , 0 //nrofArrayElements
    , REFLECTION_int16
    , 2 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&k4left_StringFormatterJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&k4left_StringFormatterJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringFormatterJc_s
    }
   , { "k6left"
    , 0 //nrofArrayElements
    , REFLECTION_int16
    , 2 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&k6left_StringFormatterJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&k6left_StringFormatterJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringFormatterJc_s
    }
   , { "k8left"
    , 0 //nrofArrayElements
    , REFLECTION_int16
    , 2 << kBitPrimitiv_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&k8left_StringFormatterJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&k8left_StringFormatterJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringFormatterJc_s
    }
   , { "spaces"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&spaces_StringFormatterJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&spaces_StringFormatterJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringFormatterJc_s
    }
   , { "n10a"
    , 9 //nrofArrayElements
    , REFLECTION_int64
    , 8 << kBitPrimitiv_Modifier_reflectJc |kStaticArray_Modifier_reflectJc |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&n10a_StringFormatterJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&n10a_StringFormatterJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringFormatterJc_s
    }
   , { "sNeg"
    , 0 //nrofArrayElements
    , &reflection_StringJc
    , kEnhancedReference_Modifier_reflectJc /*t*/ |mSTATIC_Modifier_reflectJc //bitModifiers
    , 0 //compiler problem, not a constant,TODO: (int16)(&sNeg_StringFormatterJc) //lo part of memory address of static member
    , 0 //compiler problem, not a constant,TODO: (int16)((int32)(&sNeg_StringFormatterJc)>>16) //hi part of memory address of static member instead offsetToObjectifcBase, TRICKY because compatibilty.
    , &reflection_StringFormatterJc_s
    }
} };
const ClassJc reflection_StringFormatterJc_s = 
{ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_ObjectJc, &reflection_ClassJc) 
, "StringFormatterJc_s"
,  0 //position of ObjectJc
, sizeof(StringFormatterJc_s)
, (FieldJcArray const*)&reflection_Fields_StringFormatterJc_s
, null //method
, (ClassOffset_idxMtblJcARRAY*)&superclasses_StringFormatterJc_s //superclass
, null //interfaces
, 0    //modifiers
, &mtblStringFormatterJc.mtbl.head
};
